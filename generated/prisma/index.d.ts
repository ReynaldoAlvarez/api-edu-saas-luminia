
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Plan
 * PLAN
 *   - Catalog of subscription plans and capabilities.
 *   - `features` JSON is flexible: {"aiTeacher":true,"aiTeacherCalls":50, "storageMB":1024}
 *   Example: { name: "pro", price: 49.99, studentLimit:500 }
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Institution
 * INSTITUTION
 *   - Tenant representing an educational institution.
 *   - settings JSON can include timezone, branding, payment gateway config, certificate template ids, etc.
 *   Example settings: { "timezone":"America/La_Paz", "currency":"BOB" }
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model InstitutionSubscription
 * INSTITUTION SUBSCRIPTION
 *   - Tracks the institution's active plan periods and renewal behavior.
 *   Example: startDate = 2025-01-01, billingCycle = "monthly"
 */
export type InstitutionSubscription = $Result.DefaultSelection<Prisma.$InstitutionSubscriptionPayload>
/**
 * Model InstitutionPayment
 * INSTITUTION PAYMENT
 *   - Payments the institution makes to the SaaS owner for subscriptions/upgrades.
 *   - gatewayData stores provider response details (Stripe, PayPal, bank).
 */
export type InstitutionPayment = $Result.DefaultSelection<Prisma.$InstitutionPaymentPayload>
/**
 * Model User
 * USER
 *   - Core user model used across roles and profiles.
 *   - password null indicates SSO/social login only.
 *   - attributes JSON used by ABAC policy engine for dynamic attributes (e.g. {"department":"theology","level":"senior"})
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * ROLE
 *   - Defines roles at tenant or system level.
 *   - Use ABAC policies (ABACPolicy) for fine-grained rules; Role is used for grouping and defaults.
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * USER-ROLE pivot
 *   - Users can have multiple roles. isPrimary marks the primary active role for UI/ABAC defaults.
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model ABACPolicy
 * ABAC POLICY
 *   - Stores attribute-based policy conditions as JSON, evaluated by policy engine (Oso/Casbin/custom).
 *   - condition example: { "expression": "user.attributes.department == resource.department && user.institutionId == resource.institutionId" }
 */
export type ABACPolicy = $Result.DefaultSelection<Prisma.$ABACPolicyPayload>
/**
 * Model Career
 * CAREER (PROGRAM)
 *   - Represents a program/career (a "degree"/"path").
 *   - Example: "Discipleship" (BASIC), "Bachelor of Theology" (BACHELOR)
 */
export type Career = $Result.DefaultSelection<Prisma.$CareerPayload>
/**
 * Model AcademicPeriod
 * ACADEMIC PERIOD
 *   - Semesters or custom date ranges for a Career.
 *   - Example: "1st Semester 2026", startDate, endDate
 */
export type AcademicPeriod = $Result.DefaultSelection<Prisma.$AcademicPeriodPayload>
/**
 * Model Course
 * COURSE
 *   - Logical grouping inside a Career (e.g. "Theology I").
 *   - Only administrative roles (secretary/director/admin) should create courses (enforced by ABAC).
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Subject
 * SUBJECT
 *   - Specific subject/module under a Course (e.g. "Christology").
 *   - Administrators create subjects, then assign teachers to VirtualClassrooms.
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model VirtualClassroom
 * VIRTUAL CLASSROOM
 *   - Online classroom bound to a Subject; teacher is assigned by administrators.
 *   - aiConfig is JSON for model/prompt preferences per-classroom.
 */
export type VirtualClassroom = $Result.DefaultSelection<Prisma.$VirtualClassroomPayload>
/**
 * Model LessonPlan
 * LESSON PLAN
 *   - Plans created by teacher (optionally assisted by AI).
 *   - aiSuggestions stores structured content suggested by AI.
 */
export type LessonPlan = $Result.DefaultSelection<Prisma.$LessonPlanPayload>
/**
 * Model Student
 * STUDENT
 *   - One-to-one with user for student-specific data.
 *   - studentNumber unique per institution.
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Enrollment
 * ENROLLMENT
 *   - Student enrollment into a Course for a given AcademicPeriod.
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model StudentSubject
 * STUDENT-SUBJECT
 *   - Per-subject enrollment tracking (finalGrade, status)
 */
export type StudentSubject = $Result.DefaultSelection<Prisma.$StudentSubjectPayload>
/**
 * Model Grade
 * GRADE
 *   - Assessment entries (exams, quizzes, homework).
 *   - weight: decimal fraction (0.0 - 1.0) representing contribution to final grade.
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Attendance
 * ATTENDANCE
 *   - Per-session attendance record.
 *   - Use indexes for fast queries by classroom and date.
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model DisciplinaryRecord
 * DISCIPLINARY RECORD
 *   - Incidents, warnings or commendations.
 */
export type DisciplinaryRecord = $Result.DefaultSelection<Prisma.$DisciplinaryRecordPayload>
/**
 * Model TutorProfile
 * TUTOR PROFILE
 *   - Extra metadata for guardian/tutor users.
 */
export type TutorProfile = $Result.DefaultSelection<Prisma.$TutorProfilePayload>
/**
 * Model TutorStudent
 * TUTOR-STUDENT pivot
 *   - A tutor can be assigned to many students and vice-versa.
 */
export type TutorStudent = $Result.DefaultSelection<Prisma.$TutorStudentPayload>
/**
 * Model Certificate
 * CERTIFICATE
 *   - Store certificates for subject/course/program completions.
 *   - fileUrl points to object storage (S3/DO-Spaces).
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model FeeSchedule
 * FEE SCHEDULE & INSTALLMENTS
 *   - FeeSchedule defines total fees for a career/course and allowed installments.
 *   - FeeInstallment are the scheduled due payments.
 */
export type FeeSchedule = $Result.DefaultSelection<Prisma.$FeeSchedulePayload>
/**
 * Model FeeInstallment
 * 
 */
export type FeeInstallment = $Result.DefaultSelection<Prisma.$FeeInstallmentPayload>
/**
 * Model StudentPayment
 * STUDENT PAYMENT
 *   - Payments made by students toward installments or ad-hoc fees.
 *   - gatewayData holds provider response details.
 */
export type StudentPayment = $Result.DefaultSelection<Prisma.$StudentPaymentPayload>
/**
 * Model PaymentPlan
 * PAYMENT PLAN
 *   - Optional: a per-student plan that aggregates installments and tracks remaining balance.
 */
export type PaymentPlan = $Result.DefaultSelection<Prisma.$PaymentPlanPayload>
/**
 * Model AIAgent
 * AI AGENT / CONVERSATION / MESSAGE
 *   - Support for teacher assistants and student tutors.
 *   - AIAgent: configuration for an agent (per-institution).
 *   - AIConversation: session grouping of messages by user and agent.
 *   - AIMessage: individual messages (user/assistant/system).
 */
export type AIAgent = $Result.DefaultSelection<Prisma.$AIAgentPayload>
/**
 * Model AIConversation
 * 
 */
export type AIConversation = $Result.DefaultSelection<Prisma.$AIConversationPayload>
/**
 * Model AIMessage
 * 
 */
export type AIMessage = $Result.DefaultSelection<Prisma.$AIMessagePayload>
/**
 * Model AIUsageLog
 * AI USAGE LOG
 *   - Tracks AI calls for billing and auditing.
 *   - store minimal prompt/summary to avoid storing full user PII-sensitive content.
 */
export type AIUsageLog = $Result.DefaultSelection<Prisma.$AIUsageLogPayload>
/**
 * Model Notification
 * NOTIFICATIONS
 *   - Notification records and user preferences for channel delivery.
 *   - NotificationPreference controls user-level channels (email/push/in-app).
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Message
 * INTERNAL MESSAGING
 *   - Simple internal messaging for staff/students/tutors.
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Announcement
 * ANNOUNCEMENT
 *   - Institution-wide announcements (admin creates, all or role-targeted users receive).
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model DataBackup
 * DATA BACKUP (metadata)
 *   - Tracks backups and versions for critical data exports.
 *   - storageUrl points to object storage where the backup file is stored.
 */
export type DataBackup = $Result.DefaultSelection<Prisma.$DataBackupPayload>
/**
 * Model Template
 * TEMPLATE
 *   - Reusable templates (certificate templates, email templates, document templates).
 *   - type example: "certificate", "email", "invoice"
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model Integration
 * INTEGRATION
 *   - External API integrations (payment gateway keys, LMS connectors).
 *   - store encrypted credentials in metadata if needed.
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model ApiClient
 * API CLIENTS & KEYS
 *   - Allow third-party clients to consume the SaaS API securely.
 *   - apiKey should be hashed in DB; use raw key only at creation.
 */
export type ApiClient = $Result.DefaultSelection<Prisma.$ApiClientPayload>
/**
 * Model ApiUsageLog
 * API USAGE LOG
 *   - Tracks usage by ApiClient for rate-limiting and billing.
 */
export type ApiUsageLog = $Result.DefaultSelection<Prisma.$ApiUsageLogPayload>
/**
 * Model ApiScope
 * API SCOPE
 *   - Predefined scopes used for client permissions.
 */
export type ApiScope = $Result.DefaultSelection<Prisma.$ApiScopePayload>
/**
 * Model Webhook
 * WEBHOOKS
 *   - Outbound webhook configurations and delivery logs.
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model ApiKeyRotation
 * API KEY ROTATION
 *   - Store rotations and metadata for keys (hashes).
 */
export type ApiKeyRotation = $Result.DefaultSelection<Prisma.$ApiKeyRotationPayload>
/**
 * Model DashboardConfig
 * DASHBOARD CONFIG
 *   - Per-user dashboard customization (widgets/layout).
 */
export type DashboardConfig = $Result.DefaultSelection<Prisma.$DashboardConfigPayload>
/**
 * Model Teacher
 * TEACHER PROFILE
 *   - Extra metadata specific to teachers.
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model InstitutionLog
 * INSTITUTION LOG / AUDIT
 *   - Generic audit log for tenant-level events with optional JSON data.
 */
export type InstitutionLog = $Result.DefaultSelection<Prisma.$InstitutionLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoleName: {
  ADMIN: 'ADMIN',
  SECRETARY: 'SECRETARY',
  DIRECTOR: 'DIRECTOR',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  TUTOR: 'TUTOR',
  FINANCE: 'FINANCE',
  SUPPORT: 'SUPPORT'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const LevelType: {
  BASIC: 'BASIC',
  TECHNICAL: 'TECHNICAL',
  BACHELOR: 'BACHELOR',
  MASTER: 'MASTER',
  DOCTORATE: 'DOCTORATE',
  OTHER: 'OTHER'
};

export type LevelType = (typeof LevelType)[keyof typeof LevelType]


export const PaymentMethod: {
  CARD: 'CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  QR: 'QR',
  CASH: 'CASH',
  WALLET: 'WALLET',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const GradeType: {
  EXAM: 'EXAM',
  QUIZ: 'QUIZ',
  HOMEWORK: 'HOMEWORK',
  PROJECT: 'PROJECT',
  FINAL: 'FINAL'
};

export type GradeType = (typeof GradeType)[keyof typeof GradeType]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED',
  CANCELLED: 'CANCELLED',
  TRIAL: 'TRIAL'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const StudentStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  GRADUATED: 'GRADUATED',
  WITHDRAWN: 'WITHDRAWN',
  SUSPENDED: 'SUSPENDED'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const CertificateType: {
  SUBJECT: 'SUBJECT',
  COURSE: 'COURSE',
  PROGRAM: 'PROGRAM'
};

export type CertificateType = (typeof CertificateType)[keyof typeof CertificateType]


export const PolicyEffect: {
  ALLOW: 'ALLOW',
  DENY: 'DENY'
};

export type PolicyEffect = (typeof PolicyEffect)[keyof typeof PolicyEffect]

}

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type LevelType = $Enums.LevelType

export const LevelType: typeof $Enums.LevelType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type GradeType = $Enums.GradeType

export const GradeType: typeof $Enums.GradeType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type StudentStatus = $Enums.StudentStatus

export const StudentStatus: typeof $Enums.StudentStatus

export type CertificateType = $Enums.CertificateType

export const CertificateType: typeof $Enums.CertificateType

export type PolicyEffect = $Enums.PolicyEffect

export const PolicyEffect: typeof $Enums.PolicyEffect

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Plans
 * const plans = await prisma.plan.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Plans
   * const plans = await prisma.plan.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution`: Exposes CRUD operations for the **Institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.InstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institutionSubscription`: Exposes CRUD operations for the **InstitutionSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstitutionSubscriptions
    * const institutionSubscriptions = await prisma.institutionSubscription.findMany()
    * ```
    */
  get institutionSubscription(): Prisma.InstitutionSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institutionPayment`: Exposes CRUD operations for the **InstitutionPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstitutionPayments
    * const institutionPayments = await prisma.institutionPayment.findMany()
    * ```
    */
  get institutionPayment(): Prisma.InstitutionPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aBACPolicy`: Exposes CRUD operations for the **ABACPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ABACPolicies
    * const aBACPolicies = await prisma.aBACPolicy.findMany()
    * ```
    */
  get aBACPolicy(): Prisma.ABACPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.career`: Exposes CRUD operations for the **Career** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Careers
    * const careers = await prisma.career.findMany()
    * ```
    */
  get career(): Prisma.CareerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicPeriod`: Exposes CRUD operations for the **AcademicPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicPeriods
    * const academicPeriods = await prisma.academicPeriod.findMany()
    * ```
    */
  get academicPeriod(): Prisma.AcademicPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virtualClassroom`: Exposes CRUD operations for the **VirtualClassroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VirtualClassrooms
    * const virtualClassrooms = await prisma.virtualClassroom.findMany()
    * ```
    */
  get virtualClassroom(): Prisma.VirtualClassroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonPlan`: Exposes CRUD operations for the **LessonPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonPlans
    * const lessonPlans = await prisma.lessonPlan.findMany()
    * ```
    */
  get lessonPlan(): Prisma.LessonPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSubject`: Exposes CRUD operations for the **StudentSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSubjects
    * const studentSubjects = await prisma.studentSubject.findMany()
    * ```
    */
  get studentSubject(): Prisma.StudentSubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disciplinaryRecord`: Exposes CRUD operations for the **DisciplinaryRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisciplinaryRecords
    * const disciplinaryRecords = await prisma.disciplinaryRecord.findMany()
    * ```
    */
  get disciplinaryRecord(): Prisma.DisciplinaryRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutorProfile`: Exposes CRUD operations for the **TutorProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutorProfiles
    * const tutorProfiles = await prisma.tutorProfile.findMany()
    * ```
    */
  get tutorProfile(): Prisma.TutorProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutorStudent`: Exposes CRUD operations for the **TutorStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutorStudents
    * const tutorStudents = await prisma.tutorStudent.findMany()
    * ```
    */
  get tutorStudent(): Prisma.TutorStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeSchedule`: Exposes CRUD operations for the **FeeSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeSchedules
    * const feeSchedules = await prisma.feeSchedule.findMany()
    * ```
    */
  get feeSchedule(): Prisma.FeeScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeInstallment`: Exposes CRUD operations for the **FeeInstallment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeInstallments
    * const feeInstallments = await prisma.feeInstallment.findMany()
    * ```
    */
  get feeInstallment(): Prisma.FeeInstallmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentPayment`: Exposes CRUD operations for the **StudentPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentPayments
    * const studentPayments = await prisma.studentPayment.findMany()
    * ```
    */
  get studentPayment(): Prisma.StudentPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentPlan`: Exposes CRUD operations for the **PaymentPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentPlans
    * const paymentPlans = await prisma.paymentPlan.findMany()
    * ```
    */
  get paymentPlan(): Prisma.PaymentPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIAgent`: Exposes CRUD operations for the **AIAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIAgents
    * const aIAgents = await prisma.aIAgent.findMany()
    * ```
    */
  get aIAgent(): Prisma.AIAgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIConversation`: Exposes CRUD operations for the **AIConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIConversations
    * const aIConversations = await prisma.aIConversation.findMany()
    * ```
    */
  get aIConversation(): Prisma.AIConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIMessage`: Exposes CRUD operations for the **AIMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIMessages
    * const aIMessages = await prisma.aIMessage.findMany()
    * ```
    */
  get aIMessage(): Prisma.AIMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIUsageLog`: Exposes CRUD operations for the **AIUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsageLogs
    * const aIUsageLogs = await prisma.aIUsageLog.findMany()
    * ```
    */
  get aIUsageLog(): Prisma.AIUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataBackup`: Exposes CRUD operations for the **DataBackup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataBackups
    * const dataBackups = await prisma.dataBackup.findMany()
    * ```
    */
  get dataBackup(): Prisma.DataBackupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiClient`: Exposes CRUD operations for the **ApiClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiClients
    * const apiClients = await prisma.apiClient.findMany()
    * ```
    */
  get apiClient(): Prisma.ApiClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiUsageLog`: Exposes CRUD operations for the **ApiUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiUsageLogs
    * const apiUsageLogs = await prisma.apiUsageLog.findMany()
    * ```
    */
  get apiUsageLog(): Prisma.ApiUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiScope`: Exposes CRUD operations for the **ApiScope** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiScopes
    * const apiScopes = await prisma.apiScope.findMany()
    * ```
    */
  get apiScope(): Prisma.ApiScopeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKeyRotation`: Exposes CRUD operations for the **ApiKeyRotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeyRotations
    * const apiKeyRotations = await prisma.apiKeyRotation.findMany()
    * ```
    */
  get apiKeyRotation(): Prisma.ApiKeyRotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardConfig`: Exposes CRUD operations for the **DashboardConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardConfigs
    * const dashboardConfigs = await prisma.dashboardConfig.findMany()
    * ```
    */
  get dashboardConfig(): Prisma.DashboardConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institutionLog`: Exposes CRUD operations for the **InstitutionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstitutionLogs
    * const institutionLogs = await prisma.institutionLog.findMany()
    * ```
    */
  get institutionLog(): Prisma.InstitutionLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Plan: 'Plan',
    Institution: 'Institution',
    InstitutionSubscription: 'InstitutionSubscription',
    InstitutionPayment: 'InstitutionPayment',
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    ABACPolicy: 'ABACPolicy',
    Career: 'Career',
    AcademicPeriod: 'AcademicPeriod',
    Course: 'Course',
    Subject: 'Subject',
    VirtualClassroom: 'VirtualClassroom',
    LessonPlan: 'LessonPlan',
    Student: 'Student',
    Enrollment: 'Enrollment',
    StudentSubject: 'StudentSubject',
    Grade: 'Grade',
    Attendance: 'Attendance',
    DisciplinaryRecord: 'DisciplinaryRecord',
    TutorProfile: 'TutorProfile',
    TutorStudent: 'TutorStudent',
    Certificate: 'Certificate',
    FeeSchedule: 'FeeSchedule',
    FeeInstallment: 'FeeInstallment',
    StudentPayment: 'StudentPayment',
    PaymentPlan: 'PaymentPlan',
    AIAgent: 'AIAgent',
    AIConversation: 'AIConversation',
    AIMessage: 'AIMessage',
    AIUsageLog: 'AIUsageLog',
    Notification: 'Notification',
    NotificationPreference: 'NotificationPreference',
    Message: 'Message',
    Announcement: 'Announcement',
    DataBackup: 'DataBackup',
    Template: 'Template',
    Integration: 'Integration',
    ApiClient: 'ApiClient',
    ApiUsageLog: 'ApiUsageLog',
    ApiScope: 'ApiScope',
    Webhook: 'Webhook',
    WebhookDelivery: 'WebhookDelivery',
    ApiKeyRotation: 'ApiKeyRotation',
    DashboardConfig: 'DashboardConfig',
    Teacher: 'Teacher',
    InstitutionLog: 'InstitutionLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "plan" | "institution" | "institutionSubscription" | "institutionPayment" | "user" | "role" | "userRole" | "aBACPolicy" | "career" | "academicPeriod" | "course" | "subject" | "virtualClassroom" | "lessonPlan" | "student" | "enrollment" | "studentSubject" | "grade" | "attendance" | "disciplinaryRecord" | "tutorProfile" | "tutorStudent" | "certificate" | "feeSchedule" | "feeInstallment" | "studentPayment" | "paymentPlan" | "aIAgent" | "aIConversation" | "aIMessage" | "aIUsageLog" | "notification" | "notificationPreference" | "message" | "announcement" | "dataBackup" | "template" | "integration" | "apiClient" | "apiUsageLog" | "apiScope" | "webhook" | "webhookDelivery" | "apiKeyRotation" | "dashboardConfig" | "teacher" | "institutionLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Institution: {
        payload: Prisma.$InstitutionPayload<ExtArgs>
        fields: Prisma.InstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findMany: {
            args: Prisma.InstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          create: {
            args: Prisma.InstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          createMany: {
            args: Prisma.InstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          delete: {
            args: Prisma.InstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          update: {
            args: Prisma.InstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.InstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      InstitutionSubscription: {
        payload: Prisma.$InstitutionSubscriptionPayload<ExtArgs>
        fields: Prisma.InstitutionSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>
          }
          findMany: {
            args: Prisma.InstitutionSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>[]
          }
          create: {
            args: Prisma.InstitutionSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>
          }
          createMany: {
            args: Prisma.InstitutionSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.InstitutionSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>
          }
          update: {
            args: Prisma.InstitutionSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitutionSubscription>
          }
          groupBy: {
            args: Prisma.InstitutionSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      InstitutionPayment: {
        payload: Prisma.$InstitutionPaymentPayload<ExtArgs>
        fields: Prisma.InstitutionPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>
          }
          findFirst: {
            args: Prisma.InstitutionPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>
          }
          findMany: {
            args: Prisma.InstitutionPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>[]
          }
          create: {
            args: Prisma.InstitutionPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>
          }
          createMany: {
            args: Prisma.InstitutionPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>[]
          }
          delete: {
            args: Prisma.InstitutionPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>
          }
          update: {
            args: Prisma.InstitutionPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPaymentPayload>
          }
          aggregate: {
            args: Prisma.InstitutionPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitutionPayment>
          }
          groupBy: {
            args: Prisma.InstitutionPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionPaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      ABACPolicy: {
        payload: Prisma.$ABACPolicyPayload<ExtArgs>
        fields: Prisma.ABACPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ABACPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ABACPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>
          }
          findFirst: {
            args: Prisma.ABACPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ABACPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>
          }
          findMany: {
            args: Prisma.ABACPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>[]
          }
          create: {
            args: Prisma.ABACPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>
          }
          createMany: {
            args: Prisma.ABACPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ABACPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>[]
          }
          delete: {
            args: Prisma.ABACPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>
          }
          update: {
            args: Prisma.ABACPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>
          }
          deleteMany: {
            args: Prisma.ABACPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ABACPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ABACPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>[]
          }
          upsert: {
            args: Prisma.ABACPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABACPolicyPayload>
          }
          aggregate: {
            args: Prisma.ABACPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateABACPolicy>
          }
          groupBy: {
            args: Prisma.ABACPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ABACPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ABACPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<ABACPolicyCountAggregateOutputType> | number
          }
        }
      }
      Career: {
        payload: Prisma.$CareerPayload<ExtArgs>
        fields: Prisma.CareerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          findFirst: {
            args: Prisma.CareerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          findMany: {
            args: Prisma.CareerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          create: {
            args: Prisma.CareerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          createMany: {
            args: Prisma.CareerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          delete: {
            args: Prisma.CareerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          update: {
            args: Prisma.CareerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          deleteMany: {
            args: Prisma.CareerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CareerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          upsert: {
            args: Prisma.CareerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          aggregate: {
            args: Prisma.CareerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareer>
          }
          groupBy: {
            args: Prisma.CareerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerCountArgs<ExtArgs>
            result: $Utils.Optional<CareerCountAggregateOutputType> | number
          }
        }
      }
      AcademicPeriod: {
        payload: Prisma.$AcademicPeriodPayload<ExtArgs>
        fields: Prisma.AcademicPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          findFirst: {
            args: Prisma.AcademicPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          findMany: {
            args: Prisma.AcademicPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          create: {
            args: Prisma.AcademicPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          createMany: {
            args: Prisma.AcademicPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          delete: {
            args: Prisma.AcademicPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          update: {
            args: Prisma.AcademicPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          deleteMany: {
            args: Prisma.AcademicPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          upsert: {
            args: Prisma.AcademicPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          aggregate: {
            args: Prisma.AcademicPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicPeriod>
          }
          groupBy: {
            args: Prisma.AcademicPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicPeriodCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      VirtualClassroom: {
        payload: Prisma.$VirtualClassroomPayload<ExtArgs>
        fields: Prisma.VirtualClassroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VirtualClassroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VirtualClassroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>
          }
          findFirst: {
            args: Prisma.VirtualClassroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VirtualClassroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>
          }
          findMany: {
            args: Prisma.VirtualClassroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>[]
          }
          create: {
            args: Prisma.VirtualClassroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>
          }
          createMany: {
            args: Prisma.VirtualClassroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VirtualClassroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>[]
          }
          delete: {
            args: Prisma.VirtualClassroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>
          }
          update: {
            args: Prisma.VirtualClassroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>
          }
          deleteMany: {
            args: Prisma.VirtualClassroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VirtualClassroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VirtualClassroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>[]
          }
          upsert: {
            args: Prisma.VirtualClassroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassroomPayload>
          }
          aggregate: {
            args: Prisma.VirtualClassroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtualClassroom>
          }
          groupBy: {
            args: Prisma.VirtualClassroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<VirtualClassroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.VirtualClassroomCountArgs<ExtArgs>
            result: $Utils.Optional<VirtualClassroomCountAggregateOutputType> | number
          }
        }
      }
      LessonPlan: {
        payload: Prisma.$LessonPlanPayload<ExtArgs>
        fields: Prisma.LessonPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          findFirst: {
            args: Prisma.LessonPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          findMany: {
            args: Prisma.LessonPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>[]
          }
          create: {
            args: Prisma.LessonPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          createMany: {
            args: Prisma.LessonPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>[]
          }
          delete: {
            args: Prisma.LessonPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          update: {
            args: Prisma.LessonPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          deleteMany: {
            args: Prisma.LessonPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>[]
          }
          upsert: {
            args: Prisma.LessonPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          aggregate: {
            args: Prisma.LessonPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonPlan>
          }
          groupBy: {
            args: Prisma.LessonPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonPlanCountArgs<ExtArgs>
            result: $Utils.Optional<LessonPlanCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      StudentSubject: {
        payload: Prisma.$StudentSubjectPayload<ExtArgs>
        fields: Prisma.StudentSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          findFirst: {
            args: Prisma.StudentSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          findMany: {
            args: Prisma.StudentSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          create: {
            args: Prisma.StudentSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          createMany: {
            args: Prisma.StudentSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          delete: {
            args: Prisma.StudentSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          update: {
            args: Prisma.StudentSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          deleteMany: {
            args: Prisma.StudentSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentSubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          upsert: {
            args: Prisma.StudentSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          aggregate: {
            args: Prisma.StudentSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSubject>
          }
          groupBy: {
            args: Prisma.StudentSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSubjectCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      DisciplinaryRecord: {
        payload: Prisma.$DisciplinaryRecordPayload<ExtArgs>
        fields: Prisma.DisciplinaryRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisciplinaryRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisciplinaryRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>
          }
          findFirst: {
            args: Prisma.DisciplinaryRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisciplinaryRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>
          }
          findMany: {
            args: Prisma.DisciplinaryRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>[]
          }
          create: {
            args: Prisma.DisciplinaryRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>
          }
          createMany: {
            args: Prisma.DisciplinaryRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisciplinaryRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>[]
          }
          delete: {
            args: Prisma.DisciplinaryRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>
          }
          update: {
            args: Prisma.DisciplinaryRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>
          }
          deleteMany: {
            args: Prisma.DisciplinaryRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisciplinaryRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisciplinaryRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>[]
          }
          upsert: {
            args: Prisma.DisciplinaryRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinaryRecordPayload>
          }
          aggregate: {
            args: Prisma.DisciplinaryRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisciplinaryRecord>
          }
          groupBy: {
            args: Prisma.DisciplinaryRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisciplinaryRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisciplinaryRecordCountArgs<ExtArgs>
            result: $Utils.Optional<DisciplinaryRecordCountAggregateOutputType> | number
          }
        }
      }
      TutorProfile: {
        payload: Prisma.$TutorProfilePayload<ExtArgs>
        fields: Prisma.TutorProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutorProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutorProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>
          }
          findFirst: {
            args: Prisma.TutorProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutorProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>
          }
          findMany: {
            args: Prisma.TutorProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>[]
          }
          create: {
            args: Prisma.TutorProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>
          }
          createMany: {
            args: Prisma.TutorProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutorProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>[]
          }
          delete: {
            args: Prisma.TutorProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>
          }
          update: {
            args: Prisma.TutorProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>
          }
          deleteMany: {
            args: Prisma.TutorProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutorProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TutorProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>[]
          }
          upsert: {
            args: Prisma.TutorProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorProfilePayload>
          }
          aggregate: {
            args: Prisma.TutorProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutorProfile>
          }
          groupBy: {
            args: Prisma.TutorProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutorProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutorProfileCountArgs<ExtArgs>
            result: $Utils.Optional<TutorProfileCountAggregateOutputType> | number
          }
        }
      }
      TutorStudent: {
        payload: Prisma.$TutorStudentPayload<ExtArgs>
        fields: Prisma.TutorStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutorStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutorStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>
          }
          findFirst: {
            args: Prisma.TutorStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutorStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>
          }
          findMany: {
            args: Prisma.TutorStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>[]
          }
          create: {
            args: Prisma.TutorStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>
          }
          createMany: {
            args: Prisma.TutorStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutorStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>[]
          }
          delete: {
            args: Prisma.TutorStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>
          }
          update: {
            args: Prisma.TutorStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>
          }
          deleteMany: {
            args: Prisma.TutorStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutorStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TutorStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>[]
          }
          upsert: {
            args: Prisma.TutorStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorStudentPayload>
          }
          aggregate: {
            args: Prisma.TutorStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutorStudent>
          }
          groupBy: {
            args: Prisma.TutorStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutorStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutorStudentCountArgs<ExtArgs>
            result: $Utils.Optional<TutorStudentCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      FeeSchedule: {
        payload: Prisma.$FeeSchedulePayload<ExtArgs>
        fields: Prisma.FeeScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>
          }
          findFirst: {
            args: Prisma.FeeScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>
          }
          findMany: {
            args: Prisma.FeeScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>[]
          }
          create: {
            args: Prisma.FeeScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>
          }
          createMany: {
            args: Prisma.FeeScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>[]
          }
          delete: {
            args: Prisma.FeeScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>
          }
          update: {
            args: Prisma.FeeScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>
          }
          deleteMany: {
            args: Prisma.FeeScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>[]
          }
          upsert: {
            args: Prisma.FeeScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeSchedulePayload>
          }
          aggregate: {
            args: Prisma.FeeScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeSchedule>
          }
          groupBy: {
            args: Prisma.FeeScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<FeeScheduleCountAggregateOutputType> | number
          }
        }
      }
      FeeInstallment: {
        payload: Prisma.$FeeInstallmentPayload<ExtArgs>
        fields: Prisma.FeeInstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeInstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeInstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>
          }
          findFirst: {
            args: Prisma.FeeInstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeInstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>
          }
          findMany: {
            args: Prisma.FeeInstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>[]
          }
          create: {
            args: Prisma.FeeInstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>
          }
          createMany: {
            args: Prisma.FeeInstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeInstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>[]
          }
          delete: {
            args: Prisma.FeeInstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>
          }
          update: {
            args: Prisma.FeeInstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>
          }
          deleteMany: {
            args: Prisma.FeeInstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeInstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeInstallmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>[]
          }
          upsert: {
            args: Prisma.FeeInstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeInstallmentPayload>
          }
          aggregate: {
            args: Prisma.FeeInstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeInstallment>
          }
          groupBy: {
            args: Prisma.FeeInstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeInstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeInstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<FeeInstallmentCountAggregateOutputType> | number
          }
        }
      }
      StudentPayment: {
        payload: Prisma.$StudentPaymentPayload<ExtArgs>
        fields: Prisma.StudentPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          findFirst: {
            args: Prisma.StudentPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          findMany: {
            args: Prisma.StudentPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>[]
          }
          create: {
            args: Prisma.StudentPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          createMany: {
            args: Prisma.StudentPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>[]
          }
          delete: {
            args: Prisma.StudentPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          update: {
            args: Prisma.StudentPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          deleteMany: {
            args: Prisma.StudentPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>[]
          }
          upsert: {
            args: Prisma.StudentPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPaymentPayload>
          }
          aggregate: {
            args: Prisma.StudentPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentPayment>
          }
          groupBy: {
            args: Prisma.StudentPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentPaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentPlan: {
        payload: Prisma.$PaymentPlanPayload<ExtArgs>
        fields: Prisma.PaymentPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          findFirst: {
            args: Prisma.PaymentPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          findMany: {
            args: Prisma.PaymentPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
          }
          create: {
            args: Prisma.PaymentPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          createMany: {
            args: Prisma.PaymentPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
          }
          delete: {
            args: Prisma.PaymentPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          update: {
            args: Prisma.PaymentPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          deleteMany: {
            args: Prisma.PaymentPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
          }
          upsert: {
            args: Prisma.PaymentPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
          }
          aggregate: {
            args: Prisma.PaymentPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentPlan>
          }
          groupBy: {
            args: Prisma.PaymentPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentPlanCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentPlanCountAggregateOutputType> | number
          }
        }
      }
      AIAgent: {
        payload: Prisma.$AIAgentPayload<ExtArgs>
        fields: Prisma.AIAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>
          }
          findFirst: {
            args: Prisma.AIAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>
          }
          findMany: {
            args: Prisma.AIAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>[]
          }
          create: {
            args: Prisma.AIAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>
          }
          createMany: {
            args: Prisma.AIAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIAgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>[]
          }
          delete: {
            args: Prisma.AIAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>
          }
          update: {
            args: Prisma.AIAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>
          }
          deleteMany: {
            args: Prisma.AIAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIAgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>[]
          }
          upsert: {
            args: Prisma.AIAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentPayload>
          }
          aggregate: {
            args: Prisma.AIAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIAgent>
          }
          groupBy: {
            args: Prisma.AIAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIAgentCountArgs<ExtArgs>
            result: $Utils.Optional<AIAgentCountAggregateOutputType> | number
          }
        }
      }
      AIConversation: {
        payload: Prisma.$AIConversationPayload<ExtArgs>
        fields: Prisma.AIConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findFirst: {
            args: Prisma.AIConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          findMany: {
            args: Prisma.AIConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          create: {
            args: Prisma.AIConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          createMany: {
            args: Prisma.AIConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          delete: {
            args: Prisma.AIConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          update: {
            args: Prisma.AIConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          deleteMany: {
            args: Prisma.AIConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>[]
          }
          upsert: {
            args: Prisma.AIConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIConversationPayload>
          }
          aggregate: {
            args: Prisma.AIConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIConversation>
          }
          groupBy: {
            args: Prisma.AIConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AIConversationCountAggregateOutputType> | number
          }
        }
      }
      AIMessage: {
        payload: Prisma.$AIMessagePayload<ExtArgs>
        fields: Prisma.AIMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>
          }
          findFirst: {
            args: Prisma.AIMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>
          }
          findMany: {
            args: Prisma.AIMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>[]
          }
          create: {
            args: Prisma.AIMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>
          }
          createMany: {
            args: Prisma.AIMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>[]
          }
          delete: {
            args: Prisma.AIMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>
          }
          update: {
            args: Prisma.AIMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>
          }
          deleteMany: {
            args: Prisma.AIMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>[]
          }
          upsert: {
            args: Prisma.AIMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIMessagePayload>
          }
          aggregate: {
            args: Prisma.AIMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIMessage>
          }
          groupBy: {
            args: Prisma.AIMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AIMessageCountAggregateOutputType> | number
          }
        }
      }
      AIUsageLog: {
        payload: Prisma.$AIUsageLogPayload<ExtArgs>
        fields: Prisma.AIUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findFirst: {
            args: Prisma.AIUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findMany: {
            args: Prisma.AIUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          create: {
            args: Prisma.AIUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          createMany: {
            args: Prisma.AIUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          delete: {
            args: Prisma.AIUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          update: {
            args: Prisma.AIUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.AIUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.AIUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          aggregate: {
            args: Prisma.AIUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsageLog>
          }
          groupBy: {
            args: Prisma.AIUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      DataBackup: {
        payload: Prisma.$DataBackupPayload<ExtArgs>
        fields: Prisma.DataBackupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataBackupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataBackupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>
          }
          findFirst: {
            args: Prisma.DataBackupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataBackupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>
          }
          findMany: {
            args: Prisma.DataBackupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>[]
          }
          create: {
            args: Prisma.DataBackupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>
          }
          createMany: {
            args: Prisma.DataBackupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataBackupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>[]
          }
          delete: {
            args: Prisma.DataBackupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>
          }
          update: {
            args: Prisma.DataBackupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>
          }
          deleteMany: {
            args: Prisma.DataBackupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataBackupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataBackupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>[]
          }
          upsert: {
            args: Prisma.DataBackupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataBackupPayload>
          }
          aggregate: {
            args: Prisma.DataBackupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataBackup>
          }
          groupBy: {
            args: Prisma.DataBackupGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataBackupGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataBackupCountArgs<ExtArgs>
            result: $Utils.Optional<DataBackupCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      ApiClient: {
        payload: Prisma.$ApiClientPayload<ExtArgs>
        fields: Prisma.ApiClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>
          }
          findFirst: {
            args: Prisma.ApiClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>
          }
          findMany: {
            args: Prisma.ApiClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>[]
          }
          create: {
            args: Prisma.ApiClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>
          }
          createMany: {
            args: Prisma.ApiClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>[]
          }
          delete: {
            args: Prisma.ApiClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>
          }
          update: {
            args: Prisma.ApiClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>
          }
          deleteMany: {
            args: Prisma.ApiClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>[]
          }
          upsert: {
            args: Prisma.ApiClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiClientPayload>
          }
          aggregate: {
            args: Prisma.ApiClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiClient>
          }
          groupBy: {
            args: Prisma.ApiClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiClientCountArgs<ExtArgs>
            result: $Utils.Optional<ApiClientCountAggregateOutputType> | number
          }
        }
      }
      ApiUsageLog: {
        payload: Prisma.$ApiUsageLogPayload<ExtArgs>
        fields: Prisma.ApiUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          findFirst: {
            args: Prisma.ApiUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          findMany: {
            args: Prisma.ApiUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>[]
          }
          create: {
            args: Prisma.ApiUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          createMany: {
            args: Prisma.ApiUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>[]
          }
          delete: {
            args: Prisma.ApiUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          update: {
            args: Prisma.ApiUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.ApiUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          aggregate: {
            args: Prisma.ApiUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiUsageLog>
          }
          groupBy: {
            args: Prisma.ApiUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ApiScope: {
        payload: Prisma.$ApiScopePayload<ExtArgs>
        fields: Prisma.ApiScopeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiScopeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiScopeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>
          }
          findFirst: {
            args: Prisma.ApiScopeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiScopeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>
          }
          findMany: {
            args: Prisma.ApiScopeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>[]
          }
          create: {
            args: Prisma.ApiScopeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>
          }
          createMany: {
            args: Prisma.ApiScopeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiScopeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>[]
          }
          delete: {
            args: Prisma.ApiScopeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>
          }
          update: {
            args: Prisma.ApiScopeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>
          }
          deleteMany: {
            args: Prisma.ApiScopeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiScopeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiScopeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>[]
          }
          upsert: {
            args: Prisma.ApiScopeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiScopePayload>
          }
          aggregate: {
            args: Prisma.ApiScopeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiScope>
          }
          groupBy: {
            args: Prisma.ApiScopeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiScopeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiScopeCountArgs<ExtArgs>
            result: $Utils.Optional<ApiScopeCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      ApiKeyRotation: {
        payload: Prisma.$ApiKeyRotationPayload<ExtArgs>
        fields: Prisma.ApiKeyRotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyRotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyRotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyRotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyRotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>
          }
          findMany: {
            args: Prisma.ApiKeyRotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>[]
          }
          create: {
            args: Prisma.ApiKeyRotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>
          }
          createMany: {
            args: Prisma.ApiKeyRotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyRotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyRotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>
          }
          update: {
            args: Prisma.ApiKeyRotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyRotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyRotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyRotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyRotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyRotationPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyRotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeyRotation>
          }
          groupBy: {
            args: Prisma.ApiKeyRotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyRotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyRotationCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyRotationCountAggregateOutputType> | number
          }
        }
      }
      DashboardConfig: {
        payload: Prisma.$DashboardConfigPayload<ExtArgs>
        fields: Prisma.DashboardConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          findFirst: {
            args: Prisma.DashboardConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          findMany: {
            args: Prisma.DashboardConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>[]
          }
          create: {
            args: Prisma.DashboardConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          createMany: {
            args: Prisma.DashboardConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>[]
          }
          delete: {
            args: Prisma.DashboardConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          update: {
            args: Prisma.DashboardConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          deleteMany: {
            args: Prisma.DashboardConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>[]
          }
          upsert: {
            args: Prisma.DashboardConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          aggregate: {
            args: Prisma.DashboardConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardConfig>
          }
          groupBy: {
            args: Prisma.DashboardConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardConfigCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardConfigCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      InstitutionLog: {
        payload: Prisma.$InstitutionLogPayload<ExtArgs>
        fields: Prisma.InstitutionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>
          }
          findFirst: {
            args: Prisma.InstitutionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>
          }
          findMany: {
            args: Prisma.InstitutionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>[]
          }
          create: {
            args: Prisma.InstitutionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>
          }
          createMany: {
            args: Prisma.InstitutionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>[]
          }
          delete: {
            args: Prisma.InstitutionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>
          }
          update: {
            args: Prisma.InstitutionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionLogPayload>
          }
          aggregate: {
            args: Prisma.InstitutionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitutionLog>
          }
          groupBy: {
            args: Prisma.InstitutionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionLogCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    plan?: PlanOmit
    institution?: InstitutionOmit
    institutionSubscription?: InstitutionSubscriptionOmit
    institutionPayment?: InstitutionPaymentOmit
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    aBACPolicy?: ABACPolicyOmit
    career?: CareerOmit
    academicPeriod?: AcademicPeriodOmit
    course?: CourseOmit
    subject?: SubjectOmit
    virtualClassroom?: VirtualClassroomOmit
    lessonPlan?: LessonPlanOmit
    student?: StudentOmit
    enrollment?: EnrollmentOmit
    studentSubject?: StudentSubjectOmit
    grade?: GradeOmit
    attendance?: AttendanceOmit
    disciplinaryRecord?: DisciplinaryRecordOmit
    tutorProfile?: TutorProfileOmit
    tutorStudent?: TutorStudentOmit
    certificate?: CertificateOmit
    feeSchedule?: FeeScheduleOmit
    feeInstallment?: FeeInstallmentOmit
    studentPayment?: StudentPaymentOmit
    paymentPlan?: PaymentPlanOmit
    aIAgent?: AIAgentOmit
    aIConversation?: AIConversationOmit
    aIMessage?: AIMessageOmit
    aIUsageLog?: AIUsageLogOmit
    notification?: NotificationOmit
    notificationPreference?: NotificationPreferenceOmit
    message?: MessageOmit
    announcement?: AnnouncementOmit
    dataBackup?: DataBackupOmit
    template?: TemplateOmit
    integration?: IntegrationOmit
    apiClient?: ApiClientOmit
    apiUsageLog?: ApiUsageLogOmit
    apiScope?: ApiScopeOmit
    webhook?: WebhookOmit
    webhookDelivery?: WebhookDeliveryOmit
    apiKeyRotation?: ApiKeyRotationOmit
    dashboardConfig?: DashboardConfigOmit
    teacher?: TeacherOmit
    institutionLog?: InstitutionLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    institutions: number
    InstitutionSubscription: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institutions?: boolean | PlanCountOutputTypeCountInstitutionsArgs
    InstitutionSubscription?: boolean | PlanCountOutputTypeCountInstitutionSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountInstitutionSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionSubscriptionWhereInput
  }


  /**
   * Count Type InstitutionCountOutputType
   */

  export type InstitutionCountOutputType = {
    users: number
    roles: number
    careers: number
    subscriptions: number
    institutionPayments: number
    institutionLogs: number
    aiUsageLogs: number
    templates: number
    integrations: number
    apiClients: number
    announcements: number
    backups: number
    feeSchedules: number
    ABACPolicy: number
    students: number
    tutorProfile: number
    studentPayments: number
    aiAgents: number
    webhooks: number
  }

  export type InstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | InstitutionCountOutputTypeCountUsersArgs
    roles?: boolean | InstitutionCountOutputTypeCountRolesArgs
    careers?: boolean | InstitutionCountOutputTypeCountCareersArgs
    subscriptions?: boolean | InstitutionCountOutputTypeCountSubscriptionsArgs
    institutionPayments?: boolean | InstitutionCountOutputTypeCountInstitutionPaymentsArgs
    institutionLogs?: boolean | InstitutionCountOutputTypeCountInstitutionLogsArgs
    aiUsageLogs?: boolean | InstitutionCountOutputTypeCountAiUsageLogsArgs
    templates?: boolean | InstitutionCountOutputTypeCountTemplatesArgs
    integrations?: boolean | InstitutionCountOutputTypeCountIntegrationsArgs
    apiClients?: boolean | InstitutionCountOutputTypeCountApiClientsArgs
    announcements?: boolean | InstitutionCountOutputTypeCountAnnouncementsArgs
    backups?: boolean | InstitutionCountOutputTypeCountBackupsArgs
    feeSchedules?: boolean | InstitutionCountOutputTypeCountFeeSchedulesArgs
    ABACPolicy?: boolean | InstitutionCountOutputTypeCountABACPolicyArgs
    students?: boolean | InstitutionCountOutputTypeCountStudentsArgs
    tutorProfile?: boolean | InstitutionCountOutputTypeCountTutorProfileArgs
    studentPayments?: boolean | InstitutionCountOutputTypeCountStudentPaymentsArgs
    aiAgents?: boolean | InstitutionCountOutputTypeCountAiAgentsArgs
    webhooks?: boolean | InstitutionCountOutputTypeCountWebhooksArgs
  }

  // Custom InputTypes
  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionCountOutputType
     */
    select?: InstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountCareersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionSubscriptionWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountInstitutionPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionPaymentWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountInstitutionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionLogWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountAiUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountApiClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiClientWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataBackupWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountFeeSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeScheduleWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountABACPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABACPolicyWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountTutorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorProfileWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountStudentPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountAiAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAgentWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }


  /**
   * Count Type InstitutionSubscriptionCountOutputType
   */

  export type InstitutionSubscriptionCountOutputType = {
    payments: number
  }

  export type InstitutionSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InstitutionSubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InstitutionSubscriptionCountOutputType without action
   */
  export type InstitutionSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscriptionCountOutputType
     */
    select?: InstitutionSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionSubscriptionCountOutputType without action
   */
  export type InstitutionSubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionPaymentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    dashboards: number
    aiUsages: number
    userRoles: number
    logs: number
    sentMessages: number
    receivedMessages: number
    notifications: number
    careers: number
    courses: number
    lessonPlans: number
    virtualClassrooms: number
    grades: number
    attendances: number
    disciplinaryRecord: number
    certificate: number
    aIConversation: number
    notificationPreference: number
    announcement: number
    dataBackups: number
    templates: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboards?: boolean | UserCountOutputTypeCountDashboardsArgs
    aiUsages?: boolean | UserCountOutputTypeCountAiUsagesArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    careers?: boolean | UserCountOutputTypeCountCareersArgs
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    lessonPlans?: boolean | UserCountOutputTypeCountLessonPlansArgs
    virtualClassrooms?: boolean | UserCountOutputTypeCountVirtualClassroomsArgs
    grades?: boolean | UserCountOutputTypeCountGradesArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    disciplinaryRecord?: boolean | UserCountOutputTypeCountDisciplinaryRecordArgs
    certificate?: boolean | UserCountOutputTypeCountCertificateArgs
    aIConversation?: boolean | UserCountOutputTypeCountAIConversationArgs
    notificationPreference?: boolean | UserCountOutputTypeCountNotificationPreferenceArgs
    announcement?: boolean | UserCountOutputTypeCountAnnouncementArgs
    dataBackups?: boolean | UserCountOutputTypeCountDataBackupsArgs
    templates?: boolean | UserCountOutputTypeCountTemplatesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDashboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardConfigWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCareersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVirtualClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassroomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisciplinaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisciplinaryRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAIConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataBackupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type CareerCountOutputType
   */

  export type CareerCountOutputType = {
    courses: number
    periods: number
    students: number
    feeSchedule: number
  }

  export type CareerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | CareerCountOutputTypeCountCoursesArgs
    periods?: boolean | CareerCountOutputTypeCountPeriodsArgs
    students?: boolean | CareerCountOutputTypeCountStudentsArgs
    feeSchedule?: boolean | CareerCountOutputTypeCountFeeScheduleArgs
  }

  // Custom InputTypes
  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerCountOutputType
     */
    select?: CareerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicPeriodWhereInput
  }

  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountFeeScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeScheduleWhereInput
  }


  /**
   * Count Type AcademicPeriodCountOutputType
   */

  export type AcademicPeriodCountOutputType = {
    courses: number
    enrollments: number
  }

  export type AcademicPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | AcademicPeriodCountOutputTypeCountCoursesArgs
    enrollments?: boolean | AcademicPeriodCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriodCountOutputType
     */
    select?: AcademicPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    subjects: number
    enrollments: number
    certificate: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | CourseCountOutputTypeCountSubjectsArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    certificate?: boolean | CourseCountOutputTypeCountCertificateArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    classrooms: number
    studentSubjects: number
    disciplinaryRecord: number
    certificate: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classrooms?: boolean | SubjectCountOutputTypeCountClassroomsArgs
    studentSubjects?: boolean | SubjectCountOutputTypeCountStudentSubjectsArgs
    disciplinaryRecord?: boolean | SubjectCountOutputTypeCountDisciplinaryRecordArgs
    certificate?: boolean | SubjectCountOutputTypeCountCertificateArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassroomWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountStudentSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountDisciplinaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisciplinaryRecordWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type VirtualClassroomCountOutputType
   */

  export type VirtualClassroomCountOutputType = {
    lessonPlans: number
    attendances: number
    aiUsages: number
    studentSubject: number
  }

  export type VirtualClassroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessonPlans?: boolean | VirtualClassroomCountOutputTypeCountLessonPlansArgs
    attendances?: boolean | VirtualClassroomCountOutputTypeCountAttendancesArgs
    aiUsages?: boolean | VirtualClassroomCountOutputTypeCountAiUsagesArgs
    studentSubject?: boolean | VirtualClassroomCountOutputTypeCountStudentSubjectArgs
  }

  // Custom InputTypes
  /**
   * VirtualClassroomCountOutputType without action
   */
  export type VirtualClassroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroomCountOutputType
     */
    select?: VirtualClassroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VirtualClassroomCountOutputType without action
   */
  export type VirtualClassroomCountOutputTypeCountLessonPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonPlanWhereInput
  }

  /**
   * VirtualClassroomCountOutputType without action
   */
  export type VirtualClassroomCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * VirtualClassroomCountOutputType without action
   */
  export type VirtualClassroomCountOutputTypeCountAiUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
  }

  /**
   * VirtualClassroomCountOutputType without action
   */
  export type VirtualClassroomCountOutputTypeCountStudentSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    enrollments: number
    subjects: number
    attendances: number
    tutorAssignments: number
    payments: number
    certificates: number
    disciplinaryRecord: number
    paymentPlan: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    subjects?: boolean | StudentCountOutputTypeCountSubjectsArgs
    attendances?: boolean | StudentCountOutputTypeCountAttendancesArgs
    tutorAssignments?: boolean | StudentCountOutputTypeCountTutorAssignmentsArgs
    payments?: boolean | StudentCountOutputTypeCountPaymentsArgs
    certificates?: boolean | StudentCountOutputTypeCountCertificatesArgs
    disciplinaryRecord?: boolean | StudentCountOutputTypeCountDisciplinaryRecordArgs
    paymentPlan?: boolean | StudentCountOutputTypeCountPaymentPlanArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTutorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorStudentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDisciplinaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisciplinaryRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPaymentPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentPlanWhereInput
  }


  /**
   * Count Type StudentSubjectCountOutputType
   */

  export type StudentSubjectCountOutputType = {
    grades: number
  }

  export type StudentSubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | StudentSubjectCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * StudentSubjectCountOutputType without action
   */
  export type StudentSubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubjectCountOutputType
     */
    select?: StudentSubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentSubjectCountOutputType without action
   */
  export type StudentSubjectCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }


  /**
   * Count Type TutorProfileCountOutputType
   */

  export type TutorProfileCountOutputType = {
    tutorAssignments: number
  }

  export type TutorProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutorAssignments?: boolean | TutorProfileCountOutputTypeCountTutorAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * TutorProfileCountOutputType without action
   */
  export type TutorProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfileCountOutputType
     */
    select?: TutorProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutorProfileCountOutputType without action
   */
  export type TutorProfileCountOutputTypeCountTutorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorStudentWhereInput
  }


  /**
   * Count Type FeeScheduleCountOutputType
   */

  export type FeeScheduleCountOutputType = {
    installmentsList: number
    paymentPlan: number
  }

  export type FeeScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installmentsList?: boolean | FeeScheduleCountOutputTypeCountInstallmentsListArgs
    paymentPlan?: boolean | FeeScheduleCountOutputTypeCountPaymentPlanArgs
  }

  // Custom InputTypes
  /**
   * FeeScheduleCountOutputType without action
   */
  export type FeeScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeScheduleCountOutputType
     */
    select?: FeeScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeScheduleCountOutputType without action
   */
  export type FeeScheduleCountOutputTypeCountInstallmentsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeInstallmentWhereInput
  }

  /**
   * FeeScheduleCountOutputType without action
   */
  export type FeeScheduleCountOutputTypeCountPaymentPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentPlanWhereInput
  }


  /**
   * Count Type FeeInstallmentCountOutputType
   */

  export type FeeInstallmentCountOutputType = {
    studentPayments: number
  }

  export type FeeInstallmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentPayments?: boolean | FeeInstallmentCountOutputTypeCountStudentPaymentsArgs
  }

  // Custom InputTypes
  /**
   * FeeInstallmentCountOutputType without action
   */
  export type FeeInstallmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallmentCountOutputType
     */
    select?: FeeInstallmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeInstallmentCountOutputType without action
   */
  export type FeeInstallmentCountOutputTypeCountStudentPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
  }


  /**
   * Count Type AIAgentCountOutputType
   */

  export type AIAgentCountOutputType = {
    conversations: number
    classrooms: number
  }

  export type AIAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | AIAgentCountOutputTypeCountConversationsArgs
    classrooms?: boolean | AIAgentCountOutputTypeCountClassroomsArgs
  }

  // Custom InputTypes
  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentCountOutputType
     */
    select?: AIAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
  }

  /**
   * AIAgentCountOutputType without action
   */
  export type AIAgentCountOutputTypeCountClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassroomWhereInput
  }


  /**
   * Count Type AIConversationCountOutputType
   */

  export type AIConversationCountOutputType = {
    messages: number
  }

  export type AIConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AIConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * AIConversationCountOutputType without action
   */
  export type AIConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversationCountOutputType
     */
    select?: AIConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIConversationCountOutputType without action
   */
  export type AIConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIMessageWhereInput
  }


  /**
   * Count Type ApiClientCountOutputType
   */

  export type ApiClientCountOutputType = {
    usageLogs: number
    rotations: number
  }

  export type ApiClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | ApiClientCountOutputTypeCountUsageLogsArgs
    rotations?: boolean | ApiClientCountOutputTypeCountRotationsArgs
  }

  // Custom InputTypes
  /**
   * ApiClientCountOutputType without action
   */
  export type ApiClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClientCountOutputType
     */
    select?: ApiClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiClientCountOutputType without action
   */
  export type ApiClientCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageLogWhereInput
  }

  /**
   * ApiClientCountOutputType without action
   */
  export type ApiClientCountOutputTypeCountRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyRotationWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    deliveries: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: Decimal | null
    studentLimit: number | null
    teacherLimit: number | null
    adminLimit: number | null
    courseLimit: number | null
    aiTeacherCallsMonthly: number | null
    aiStudentMinutesMonthly: number | null
    certificateMonthly: number | null
    virtualClassroomLimit: number | null
    storageMB: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: Decimal | null
    studentLimit: number | null
    teacherLimit: number | null
    adminLimit: number | null
    courseLimit: number | null
    aiTeacherCallsMonthly: number | null
    aiStudentMinutesMonthly: number | null
    certificateMonthly: number | null
    virtualClassroomLimit: number | null
    storageMB: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    studentLimit: number | null
    teacherLimit: number | null
    adminLimit: number | null
    courseLimit: number | null
    aiTeacherCallsMonthly: number | null
    aiStudentMinutesMonthly: number | null
    certificateMonthly: number | null
    virtualClassroomLimit: number | null
    storageMB: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    studentLimit: number | null
    teacherLimit: number | null
    adminLimit: number | null
    courseLimit: number | null
    aiTeacherCallsMonthly: number | null
    aiStudentMinutesMonthly: number | null
    certificateMonthly: number | null
    virtualClassroomLimit: number | null
    storageMB: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    price: number
    currency: number
    studentLimit: number
    teacherLimit: number
    adminLimit: number
    courseLimit: number
    aiTeacherCallsMonthly: number
    aiStudentMinutesMonthly: number
    certificateMonthly: number
    virtualClassroomLimit: number
    storageMB: number
    features: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
    studentLimit?: true
    teacherLimit?: true
    adminLimit?: true
    courseLimit?: true
    aiTeacherCallsMonthly?: true
    aiStudentMinutesMonthly?: true
    certificateMonthly?: true
    virtualClassroomLimit?: true
    storageMB?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
    studentLimit?: true
    teacherLimit?: true
    adminLimit?: true
    courseLimit?: true
    aiTeacherCallsMonthly?: true
    aiStudentMinutesMonthly?: true
    certificateMonthly?: true
    virtualClassroomLimit?: true
    storageMB?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    currency?: true
    studentLimit?: true
    teacherLimit?: true
    adminLimit?: true
    courseLimit?: true
    aiTeacherCallsMonthly?: true
    aiStudentMinutesMonthly?: true
    certificateMonthly?: true
    virtualClassroomLimit?: true
    storageMB?: true
    isActive?: true
    createdAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    currency?: true
    studentLimit?: true
    teacherLimit?: true
    adminLimit?: true
    courseLimit?: true
    aiTeacherCallsMonthly?: true
    aiStudentMinutesMonthly?: true
    certificateMonthly?: true
    virtualClassroomLimit?: true
    storageMB?: true
    isActive?: true
    createdAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    currency?: true
    studentLimit?: true
    teacherLimit?: true
    adminLimit?: true
    courseLimit?: true
    aiTeacherCallsMonthly?: true
    aiStudentMinutesMonthly?: true
    certificateMonthly?: true
    virtualClassroomLimit?: true
    storageMB?: true
    features?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    price: Decimal
    currency: string
    studentLimit: number
    teacherLimit: number
    adminLimit: number
    courseLimit: number
    aiTeacherCallsMonthly: number
    aiStudentMinutesMonthly: number
    certificateMonthly: number
    virtualClassroomLimit: number
    storageMB: number
    features: JsonValue | null
    isActive: boolean
    createdAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    studentLimit?: boolean
    teacherLimit?: boolean
    adminLimit?: boolean
    courseLimit?: boolean
    aiTeacherCallsMonthly?: boolean
    aiStudentMinutesMonthly?: boolean
    certificateMonthly?: boolean
    virtualClassroomLimit?: boolean
    storageMB?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    institutions?: boolean | Plan$institutionsArgs<ExtArgs>
    InstitutionSubscription?: boolean | Plan$InstitutionSubscriptionArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    studentLimit?: boolean
    teacherLimit?: boolean
    adminLimit?: boolean
    courseLimit?: boolean
    aiTeacherCallsMonthly?: boolean
    aiStudentMinutesMonthly?: boolean
    certificateMonthly?: boolean
    virtualClassroomLimit?: boolean
    storageMB?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    studentLimit?: boolean
    teacherLimit?: boolean
    adminLimit?: boolean
    courseLimit?: boolean
    aiTeacherCallsMonthly?: boolean
    aiStudentMinutesMonthly?: boolean
    certificateMonthly?: boolean
    virtualClassroomLimit?: boolean
    storageMB?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    studentLimit?: boolean
    teacherLimit?: boolean
    adminLimit?: boolean
    courseLimit?: boolean
    aiTeacherCallsMonthly?: boolean
    aiStudentMinutesMonthly?: boolean
    certificateMonthly?: boolean
    virtualClassroomLimit?: boolean
    storageMB?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "price" | "currency" | "studentLimit" | "teacherLimit" | "adminLimit" | "courseLimit" | "aiTeacherCallsMonthly" | "aiStudentMinutesMonthly" | "certificateMonthly" | "virtualClassroomLimit" | "storageMB" | "features" | "isActive" | "createdAt", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institutions?: boolean | Plan$institutionsArgs<ExtArgs>
    InstitutionSubscription?: boolean | Plan$InstitutionSubscriptionArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      institutions: Prisma.$InstitutionPayload<ExtArgs>[]
      InstitutionSubscription: Prisma.$InstitutionSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      price: Prisma.Decimal
      currency: string
      studentLimit: number
      teacherLimit: number
      adminLimit: number
      courseLimit: number
      aiTeacherCallsMonthly: number
      aiStudentMinutesMonthly: number
      certificateMonthly: number
      virtualClassroomLimit: number
      storageMB: number
      features: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institutions<T extends Plan$institutionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$institutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    InstitutionSubscription<T extends Plan$InstitutionSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Plan$InstitutionSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly slug: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Decimal'>
    readonly currency: FieldRef<"Plan", 'String'>
    readonly studentLimit: FieldRef<"Plan", 'Int'>
    readonly teacherLimit: FieldRef<"Plan", 'Int'>
    readonly adminLimit: FieldRef<"Plan", 'Int'>
    readonly courseLimit: FieldRef<"Plan", 'Int'>
    readonly aiTeacherCallsMonthly: FieldRef<"Plan", 'Int'>
    readonly aiStudentMinutesMonthly: FieldRef<"Plan", 'Int'>
    readonly certificateMonthly: FieldRef<"Plan", 'Int'>
    readonly virtualClassroomLimit: FieldRef<"Plan", 'Int'>
    readonly storageMB: FieldRef<"Plan", 'Int'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.institutions
   */
  export type Plan$institutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    cursor?: InstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Plan.InstitutionSubscription
   */
  export type Plan$InstitutionSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    where?: InstitutionSubscriptionWhereInput
    orderBy?: InstitutionSubscriptionOrderByWithRelationInput | InstitutionSubscriptionOrderByWithRelationInput[]
    cursor?: InstitutionSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionSubscriptionScalarFieldEnum | InstitutionSubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    contactEmail: string | null
    phone: string | null
    planId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    contactEmail: string | null
    phone: string | null
    planId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    contactEmail: number
    phone: number
    address: number
    planId: number
    settings: number
    status: number
    createdAt: number
    _all: number
  }


  export type InstitutionMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    contactEmail?: true
    phone?: true
    planId?: true
    status?: true
    createdAt?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    contactEmail?: true
    phone?: true
    planId?: true
    status?: true
    createdAt?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    contactEmail?: true
    phone?: true
    address?: true
    planId?: true
    settings?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institution to aggregate.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type InstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithAggregationInput | InstitutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: InstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: string
    name: string
    slug: string
    contactEmail: string
    phone: string | null
    address: JsonValue | null
    planId: string | null
    settings: JsonValue | null
    status: string | null
    createdAt: Date
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends InstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    contactEmail?: boolean
    phone?: boolean
    address?: boolean
    planId?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
    plan?: boolean | Institution$planArgs<ExtArgs>
    users?: boolean | Institution$usersArgs<ExtArgs>
    roles?: boolean | Institution$rolesArgs<ExtArgs>
    careers?: boolean | Institution$careersArgs<ExtArgs>
    subscriptions?: boolean | Institution$subscriptionsArgs<ExtArgs>
    institutionPayments?: boolean | Institution$institutionPaymentsArgs<ExtArgs>
    institutionLogs?: boolean | Institution$institutionLogsArgs<ExtArgs>
    aiUsageLogs?: boolean | Institution$aiUsageLogsArgs<ExtArgs>
    templates?: boolean | Institution$templatesArgs<ExtArgs>
    integrations?: boolean | Institution$integrationsArgs<ExtArgs>
    apiClients?: boolean | Institution$apiClientsArgs<ExtArgs>
    announcements?: boolean | Institution$announcementsArgs<ExtArgs>
    backups?: boolean | Institution$backupsArgs<ExtArgs>
    feeSchedules?: boolean | Institution$feeSchedulesArgs<ExtArgs>
    ABACPolicy?: boolean | Institution$ABACPolicyArgs<ExtArgs>
    students?: boolean | Institution$studentsArgs<ExtArgs>
    tutorProfile?: boolean | Institution$tutorProfileArgs<ExtArgs>
    studentPayments?: boolean | Institution$studentPaymentsArgs<ExtArgs>
    aiAgents?: boolean | Institution$aiAgentsArgs<ExtArgs>
    webhooks?: boolean | Institution$webhooksArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    contactEmail?: boolean
    phone?: boolean
    address?: boolean
    planId?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
    plan?: boolean | Institution$planArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    contactEmail?: boolean
    phone?: boolean
    address?: boolean
    planId?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
    plan?: boolean | Institution$planArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    contactEmail?: boolean
    phone?: boolean
    address?: boolean
    planId?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "contactEmail" | "phone" | "address" | "planId" | "settings" | "status" | "createdAt", ExtArgs["result"]["institution"]>
  export type InstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Institution$planArgs<ExtArgs>
    users?: boolean | Institution$usersArgs<ExtArgs>
    roles?: boolean | Institution$rolesArgs<ExtArgs>
    careers?: boolean | Institution$careersArgs<ExtArgs>
    subscriptions?: boolean | Institution$subscriptionsArgs<ExtArgs>
    institutionPayments?: boolean | Institution$institutionPaymentsArgs<ExtArgs>
    institutionLogs?: boolean | Institution$institutionLogsArgs<ExtArgs>
    aiUsageLogs?: boolean | Institution$aiUsageLogsArgs<ExtArgs>
    templates?: boolean | Institution$templatesArgs<ExtArgs>
    integrations?: boolean | Institution$integrationsArgs<ExtArgs>
    apiClients?: boolean | Institution$apiClientsArgs<ExtArgs>
    announcements?: boolean | Institution$announcementsArgs<ExtArgs>
    backups?: boolean | Institution$backupsArgs<ExtArgs>
    feeSchedules?: boolean | Institution$feeSchedulesArgs<ExtArgs>
    ABACPolicy?: boolean | Institution$ABACPolicyArgs<ExtArgs>
    students?: boolean | Institution$studentsArgs<ExtArgs>
    tutorProfile?: boolean | Institution$tutorProfileArgs<ExtArgs>
    studentPayments?: boolean | Institution$studentPaymentsArgs<ExtArgs>
    aiAgents?: boolean | Institution$aiAgentsArgs<ExtArgs>
    webhooks?: boolean | Institution$webhooksArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstitutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Institution$planArgs<ExtArgs>
  }
  export type InstitutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Institution$planArgs<ExtArgs>
  }

  export type $InstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institution"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      careers: Prisma.$CareerPayload<ExtArgs>[]
      subscriptions: Prisma.$InstitutionSubscriptionPayload<ExtArgs>[]
      institutionPayments: Prisma.$InstitutionPaymentPayload<ExtArgs>[]
      institutionLogs: Prisma.$InstitutionLogPayload<ExtArgs>[]
      aiUsageLogs: Prisma.$AIUsageLogPayload<ExtArgs>[]
      templates: Prisma.$TemplatePayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      apiClients: Prisma.$ApiClientPayload<ExtArgs>[]
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      backups: Prisma.$DataBackupPayload<ExtArgs>[]
      feeSchedules: Prisma.$FeeSchedulePayload<ExtArgs>[]
      ABACPolicy: Prisma.$ABACPolicyPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      tutorProfile: Prisma.$TutorProfilePayload<ExtArgs>[]
      studentPayments: Prisma.$StudentPaymentPayload<ExtArgs>[]
      aiAgents: Prisma.$AIAgentPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      contactEmail: string
      phone: string | null
      address: Prisma.JsonValue | null
      planId: string | null
      settings: Prisma.JsonValue | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>

  type InstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface InstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institution'], meta: { name: 'Institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {InstitutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionFindUniqueArgs>(args: SelectSubset<T, InstitutionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionFindFirstArgs>(args?: SelectSubset<T, InstitutionFindFirstArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionFindManyArgs>(args?: SelectSubset<T, InstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {InstitutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends InstitutionCreateArgs>(args: SelectSubset<T, InstitutionCreateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {InstitutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionCreateManyArgs>(args?: SelectSubset<T, InstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutions and returns the data saved in the database.
     * @param {InstitutionCreateManyAndReturnArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Institution.
     * @param {InstitutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends InstitutionDeleteArgs>(args: SelectSubset<T, InstitutionDeleteArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {InstitutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionUpdateArgs>(args: SelectSubset<T, InstitutionUpdateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {InstitutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionDeleteManyArgs>(args?: SelectSubset<T, InstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionUpdateManyArgs>(args: SelectSubset<T, InstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions and returns the data updated in the database.
     * @param {InstitutionUpdateManyAndReturnArgs} args - Arguments to update many Institutions.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Institution.
     * @param {InstitutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionUpsertArgs>(args: SelectSubset<T, InstitutionUpsertArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionCountArgs>(
      args?: Subset<T, InstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institution model
   */
  readonly fields: InstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends Institution$planArgs<ExtArgs> = {}>(args?: Subset<T, Institution$planArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Institution$usersArgs<ExtArgs> = {}>(args?: Subset<T, Institution$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Institution$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    careers<T extends Institution$careersArgs<ExtArgs> = {}>(args?: Subset<T, Institution$careersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Institution$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institutionPayments<T extends Institution$institutionPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$institutionPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institutionLogs<T extends Institution$institutionLogsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$institutionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiUsageLogs<T extends Institution$aiUsageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$aiUsageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templates<T extends Institution$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends Institution$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiClients<T extends Institution$apiClientsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$apiClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends Institution$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    backups<T extends Institution$backupsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$backupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeSchedules<T extends Institution$feeSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$feeSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ABACPolicy<T extends Institution$ABACPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Institution$ABACPolicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Institution$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutorProfile<T extends Institution$tutorProfileArgs<ExtArgs> = {}>(args?: Subset<T, Institution$tutorProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentPayments<T extends Institution$studentPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$studentPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiAgents<T extends Institution$aiAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$aiAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    webhooks<T extends Institution$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Institution$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly slug: FieldRef<"Institution", 'String'>
    readonly contactEmail: FieldRef<"Institution", 'String'>
    readonly phone: FieldRef<"Institution", 'String'>
    readonly address: FieldRef<"Institution", 'Json'>
    readonly planId: FieldRef<"Institution", 'String'>
    readonly settings: FieldRef<"Institution", 'Json'>
    readonly status: FieldRef<"Institution", 'String'>
    readonly createdAt: FieldRef<"Institution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Institution findUnique
   */
  export type InstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findUniqueOrThrow
   */
  export type InstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findFirst
   */
  export type InstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findFirstOrThrow
   */
  export type InstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findMany
   */
  export type InstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institutions to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution create
   */
  export type InstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Institution.
     */
    data: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
  }

  /**
   * Institution createMany
   */
  export type InstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institution createManyAndReturn
   */
  export type InstitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Institution update
   */
  export type InstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Institution.
     */
    data: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
    /**
     * Choose, which Institution to update.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution updateMany
   */
  export type InstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution updateManyAndReturn
   */
  export type InstitutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Institution upsert
   */
  export type InstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Institution to update in case it exists.
     */
    where: InstitutionWhereUniqueInput
    /**
     * In case the Institution found by the `where` argument doesn't exist, create a new Institution with this data.
     */
    create: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
    /**
     * In case the Institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
  }

  /**
   * Institution delete
   */
  export type InstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter which Institution to delete.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution deleteMany
   */
  export type InstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutions to delete
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to delete.
     */
    limit?: number
  }

  /**
   * Institution.plan
   */
  export type Institution$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * Institution.users
   */
  export type Institution$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Institution.roles
   */
  export type Institution$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Institution.careers
   */
  export type Institution$careersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    where?: CareerWhereInput
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    cursor?: CareerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Institution.subscriptions
   */
  export type Institution$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    where?: InstitutionSubscriptionWhereInput
    orderBy?: InstitutionSubscriptionOrderByWithRelationInput | InstitutionSubscriptionOrderByWithRelationInput[]
    cursor?: InstitutionSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionSubscriptionScalarFieldEnum | InstitutionSubscriptionScalarFieldEnum[]
  }

  /**
   * Institution.institutionPayments
   */
  export type Institution$institutionPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    where?: InstitutionPaymentWhereInput
    orderBy?: InstitutionPaymentOrderByWithRelationInput | InstitutionPaymentOrderByWithRelationInput[]
    cursor?: InstitutionPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionPaymentScalarFieldEnum | InstitutionPaymentScalarFieldEnum[]
  }

  /**
   * Institution.institutionLogs
   */
  export type Institution$institutionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    where?: InstitutionLogWhereInput
    orderBy?: InstitutionLogOrderByWithRelationInput | InstitutionLogOrderByWithRelationInput[]
    cursor?: InstitutionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionLogScalarFieldEnum | InstitutionLogScalarFieldEnum[]
  }

  /**
   * Institution.aiUsageLogs
   */
  export type Institution$aiUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    cursor?: AIUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * Institution.templates
   */
  export type Institution$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Institution.integrations
   */
  export type Institution$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Institution.apiClients
   */
  export type Institution$apiClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    where?: ApiClientWhereInput
    orderBy?: ApiClientOrderByWithRelationInput | ApiClientOrderByWithRelationInput[]
    cursor?: ApiClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiClientScalarFieldEnum | ApiClientScalarFieldEnum[]
  }

  /**
   * Institution.announcements
   */
  export type Institution$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Institution.backups
   */
  export type Institution$backupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    where?: DataBackupWhereInput
    orderBy?: DataBackupOrderByWithRelationInput | DataBackupOrderByWithRelationInput[]
    cursor?: DataBackupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataBackupScalarFieldEnum | DataBackupScalarFieldEnum[]
  }

  /**
   * Institution.feeSchedules
   */
  export type Institution$feeSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    where?: FeeScheduleWhereInput
    orderBy?: FeeScheduleOrderByWithRelationInput | FeeScheduleOrderByWithRelationInput[]
    cursor?: FeeScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeScheduleScalarFieldEnum | FeeScheduleScalarFieldEnum[]
  }

  /**
   * Institution.ABACPolicy
   */
  export type Institution$ABACPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    where?: ABACPolicyWhereInput
    orderBy?: ABACPolicyOrderByWithRelationInput | ABACPolicyOrderByWithRelationInput[]
    cursor?: ABACPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ABACPolicyScalarFieldEnum | ABACPolicyScalarFieldEnum[]
  }

  /**
   * Institution.students
   */
  export type Institution$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Institution.tutorProfile
   */
  export type Institution$tutorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    where?: TutorProfileWhereInput
    orderBy?: TutorProfileOrderByWithRelationInput | TutorProfileOrderByWithRelationInput[]
    cursor?: TutorProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorProfileScalarFieldEnum | TutorProfileScalarFieldEnum[]
  }

  /**
   * Institution.studentPayments
   */
  export type Institution$studentPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    cursor?: StudentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * Institution.aiAgents
   */
  export type Institution$aiAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    where?: AIAgentWhereInput
    orderBy?: AIAgentOrderByWithRelationInput | AIAgentOrderByWithRelationInput[]
    cursor?: AIAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIAgentScalarFieldEnum | AIAgentScalarFieldEnum[]
  }

  /**
   * Institution.webhooks
   */
  export type Institution$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
  }


  /**
   * Model InstitutionSubscription
   */

  export type AggregateInstitutionSubscription = {
    _count: InstitutionSubscriptionCountAggregateOutputType | null
    _min: InstitutionSubscriptionMinAggregateOutputType | null
    _max: InstitutionSubscriptionMaxAggregateOutputType | null
  }

  export type InstitutionSubscriptionMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SubscriptionStatus | null
    autoRenew: boolean | null
    billingCycle: string | null
    createdAt: Date | null
  }

  export type InstitutionSubscriptionMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SubscriptionStatus | null
    autoRenew: boolean | null
    billingCycle: string | null
    createdAt: Date | null
  }

  export type InstitutionSubscriptionCountAggregateOutputType = {
    id: number
    institutionId: number
    planId: number
    startDate: number
    endDate: number
    status: number
    autoRenew: number
    billingCycle: number
    createdAt: number
    _all: number
  }


  export type InstitutionSubscriptionMinAggregateInputType = {
    id?: true
    institutionId?: true
    planId?: true
    startDate?: true
    endDate?: true
    status?: true
    autoRenew?: true
    billingCycle?: true
    createdAt?: true
  }

  export type InstitutionSubscriptionMaxAggregateInputType = {
    id?: true
    institutionId?: true
    planId?: true
    startDate?: true
    endDate?: true
    status?: true
    autoRenew?: true
    billingCycle?: true
    createdAt?: true
  }

  export type InstitutionSubscriptionCountAggregateInputType = {
    id?: true
    institutionId?: true
    planId?: true
    startDate?: true
    endDate?: true
    status?: true
    autoRenew?: true
    billingCycle?: true
    createdAt?: true
    _all?: true
  }

  export type InstitutionSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstitutionSubscription to aggregate.
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionSubscriptions to fetch.
     */
    orderBy?: InstitutionSubscriptionOrderByWithRelationInput | InstitutionSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstitutionSubscriptions
    **/
    _count?: true | InstitutionSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionSubscriptionMaxAggregateInputType
  }

  export type GetInstitutionSubscriptionAggregateType<T extends InstitutionSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutionSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutionSubscription[P]>
      : GetScalarType<T[P], AggregateInstitutionSubscription[P]>
  }




  export type InstitutionSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionSubscriptionWhereInput
    orderBy?: InstitutionSubscriptionOrderByWithAggregationInput | InstitutionSubscriptionOrderByWithAggregationInput[]
    by: InstitutionSubscriptionScalarFieldEnum[] | InstitutionSubscriptionScalarFieldEnum
    having?: InstitutionSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionSubscriptionCountAggregateInputType | true
    _min?: InstitutionSubscriptionMinAggregateInputType
    _max?: InstitutionSubscriptionMaxAggregateInputType
  }

  export type InstitutionSubscriptionGroupByOutputType = {
    id: string
    institutionId: string
    planId: string
    startDate: Date
    endDate: Date | null
    status: $Enums.SubscriptionStatus
    autoRenew: boolean
    billingCycle: string | null
    createdAt: Date
    _count: InstitutionSubscriptionCountAggregateOutputType | null
    _min: InstitutionSubscriptionMinAggregateOutputType | null
    _max: InstitutionSubscriptionMaxAggregateOutputType | null
  }

  type GetInstitutionSubscriptionGroupByPayload<T extends InstitutionSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoRenew?: boolean
    billingCycle?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    payments?: boolean | InstitutionSubscription$paymentsArgs<ExtArgs>
    _count?: boolean | InstitutionSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institutionSubscription"]>

  export type InstitutionSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoRenew?: boolean
    billingCycle?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institutionSubscription"]>

  export type InstitutionSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoRenew?: boolean
    billingCycle?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institutionSubscription"]>

  export type InstitutionSubscriptionSelectScalar = {
    id?: boolean
    institutionId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    autoRenew?: boolean
    billingCycle?: boolean
    createdAt?: boolean
  }

  export type InstitutionSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "planId" | "startDate" | "endDate" | "status" | "autoRenew" | "billingCycle" | "createdAt", ExtArgs["result"]["institutionSubscription"]>
  export type InstitutionSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    payments?: boolean | InstitutionSubscription$paymentsArgs<ExtArgs>
    _count?: boolean | InstitutionSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstitutionSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type InstitutionSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $InstitutionSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstitutionSubscription"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      payments: Prisma.$InstitutionPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      planId: string
      startDate: Date
      endDate: Date | null
      status: $Enums.SubscriptionStatus
      autoRenew: boolean
      billingCycle: string | null
      createdAt: Date
    }, ExtArgs["result"]["institutionSubscription"]>
    composites: {}
  }

  type InstitutionSubscriptionGetPayload<S extends boolean | null | undefined | InstitutionSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionSubscriptionPayload, S>

  type InstitutionSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionSubscriptionCountAggregateInputType | true
    }

  export interface InstitutionSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstitutionSubscription'], meta: { name: 'InstitutionSubscription' } }
    /**
     * Find zero or one InstitutionSubscription that matches the filter.
     * @param {InstitutionSubscriptionFindUniqueArgs} args - Arguments to find a InstitutionSubscription
     * @example
     * // Get one InstitutionSubscription
     * const institutionSubscription = await prisma.institutionSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionSubscriptionFindUniqueArgs>(args: SelectSubset<T, InstitutionSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstitutionSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a InstitutionSubscription
     * @example
     * // Get one InstitutionSubscription
     * const institutionSubscription = await prisma.institutionSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstitutionSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionFindFirstArgs} args - Arguments to find a InstitutionSubscription
     * @example
     * // Get one InstitutionSubscription
     * const institutionSubscription = await prisma.institutionSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionSubscriptionFindFirstArgs>(args?: SelectSubset<T, InstitutionSubscriptionFindFirstArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstitutionSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionFindFirstOrThrowArgs} args - Arguments to find a InstitutionSubscription
     * @example
     * // Get one InstitutionSubscription
     * const institutionSubscription = await prisma.institutionSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstitutionSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstitutionSubscriptions
     * const institutionSubscriptions = await prisma.institutionSubscription.findMany()
     * 
     * // Get first 10 InstitutionSubscriptions
     * const institutionSubscriptions = await prisma.institutionSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionSubscriptionWithIdOnly = await prisma.institutionSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionSubscriptionFindManyArgs>(args?: SelectSubset<T, InstitutionSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstitutionSubscription.
     * @param {InstitutionSubscriptionCreateArgs} args - Arguments to create a InstitutionSubscription.
     * @example
     * // Create one InstitutionSubscription
     * const InstitutionSubscription = await prisma.institutionSubscription.create({
     *   data: {
     *     // ... data to create a InstitutionSubscription
     *   }
     * })
     * 
     */
    create<T extends InstitutionSubscriptionCreateArgs>(args: SelectSubset<T, InstitutionSubscriptionCreateArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstitutionSubscriptions.
     * @param {InstitutionSubscriptionCreateManyArgs} args - Arguments to create many InstitutionSubscriptions.
     * @example
     * // Create many InstitutionSubscriptions
     * const institutionSubscription = await prisma.institutionSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionSubscriptionCreateManyArgs>(args?: SelectSubset<T, InstitutionSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstitutionSubscriptions and returns the data saved in the database.
     * @param {InstitutionSubscriptionCreateManyAndReturnArgs} args - Arguments to create many InstitutionSubscriptions.
     * @example
     * // Create many InstitutionSubscriptions
     * const institutionSubscription = await prisma.institutionSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstitutionSubscriptions and only return the `id`
     * const institutionSubscriptionWithIdOnly = await prisma.institutionSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstitutionSubscription.
     * @param {InstitutionSubscriptionDeleteArgs} args - Arguments to delete one InstitutionSubscription.
     * @example
     * // Delete one InstitutionSubscription
     * const InstitutionSubscription = await prisma.institutionSubscription.delete({
     *   where: {
     *     // ... filter to delete one InstitutionSubscription
     *   }
     * })
     * 
     */
    delete<T extends InstitutionSubscriptionDeleteArgs>(args: SelectSubset<T, InstitutionSubscriptionDeleteArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstitutionSubscription.
     * @param {InstitutionSubscriptionUpdateArgs} args - Arguments to update one InstitutionSubscription.
     * @example
     * // Update one InstitutionSubscription
     * const institutionSubscription = await prisma.institutionSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionSubscriptionUpdateArgs>(args: SelectSubset<T, InstitutionSubscriptionUpdateArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstitutionSubscriptions.
     * @param {InstitutionSubscriptionDeleteManyArgs} args - Arguments to filter InstitutionSubscriptions to delete.
     * @example
     * // Delete a few InstitutionSubscriptions
     * const { count } = await prisma.institutionSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionSubscriptionDeleteManyArgs>(args?: SelectSubset<T, InstitutionSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstitutionSubscriptions
     * const institutionSubscription = await prisma.institutionSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionSubscriptionUpdateManyArgs>(args: SelectSubset<T, InstitutionSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionSubscriptions and returns the data updated in the database.
     * @param {InstitutionSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many InstitutionSubscriptions.
     * @example
     * // Update many InstitutionSubscriptions
     * const institutionSubscription = await prisma.institutionSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstitutionSubscriptions and only return the `id`
     * const institutionSubscriptionWithIdOnly = await prisma.institutionSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstitutionSubscription.
     * @param {InstitutionSubscriptionUpsertArgs} args - Arguments to update or create a InstitutionSubscription.
     * @example
     * // Update or create a InstitutionSubscription
     * const institutionSubscription = await prisma.institutionSubscription.upsert({
     *   create: {
     *     // ... data to create a InstitutionSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstitutionSubscription we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionSubscriptionUpsertArgs>(args: SelectSubset<T, InstitutionSubscriptionUpsertArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstitutionSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionCountArgs} args - Arguments to filter InstitutionSubscriptions to count.
     * @example
     * // Count the number of InstitutionSubscriptions
     * const count = await prisma.institutionSubscription.count({
     *   where: {
     *     // ... the filter for the InstitutionSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionSubscriptionCountArgs>(
      args?: Subset<T, InstitutionSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstitutionSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionSubscriptionAggregateArgs>(args: Subset<T, InstitutionSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionSubscriptionAggregateType<T>>

    /**
     * Group by InstitutionSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstitutionSubscription model
   */
  readonly fields: InstitutionSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstitutionSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends InstitutionSubscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionSubscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstitutionSubscription model
   */
  interface InstitutionSubscriptionFieldRefs {
    readonly id: FieldRef<"InstitutionSubscription", 'String'>
    readonly institutionId: FieldRef<"InstitutionSubscription", 'String'>
    readonly planId: FieldRef<"InstitutionSubscription", 'String'>
    readonly startDate: FieldRef<"InstitutionSubscription", 'DateTime'>
    readonly endDate: FieldRef<"InstitutionSubscription", 'DateTime'>
    readonly status: FieldRef<"InstitutionSubscription", 'SubscriptionStatus'>
    readonly autoRenew: FieldRef<"InstitutionSubscription", 'Boolean'>
    readonly billingCycle: FieldRef<"InstitutionSubscription", 'String'>
    readonly createdAt: FieldRef<"InstitutionSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstitutionSubscription findUnique
   */
  export type InstitutionSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionSubscription to fetch.
     */
    where: InstitutionSubscriptionWhereUniqueInput
  }

  /**
   * InstitutionSubscription findUniqueOrThrow
   */
  export type InstitutionSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionSubscription to fetch.
     */
    where: InstitutionSubscriptionWhereUniqueInput
  }

  /**
   * InstitutionSubscription findFirst
   */
  export type InstitutionSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionSubscription to fetch.
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionSubscriptions to fetch.
     */
    orderBy?: InstitutionSubscriptionOrderByWithRelationInput | InstitutionSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstitutionSubscriptions.
     */
    cursor?: InstitutionSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstitutionSubscriptions.
     */
    distinct?: InstitutionSubscriptionScalarFieldEnum | InstitutionSubscriptionScalarFieldEnum[]
  }

  /**
   * InstitutionSubscription findFirstOrThrow
   */
  export type InstitutionSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionSubscription to fetch.
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionSubscriptions to fetch.
     */
    orderBy?: InstitutionSubscriptionOrderByWithRelationInput | InstitutionSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstitutionSubscriptions.
     */
    cursor?: InstitutionSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstitutionSubscriptions.
     */
    distinct?: InstitutionSubscriptionScalarFieldEnum | InstitutionSubscriptionScalarFieldEnum[]
  }

  /**
   * InstitutionSubscription findMany
   */
  export type InstitutionSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionSubscriptions to fetch.
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionSubscriptions to fetch.
     */
    orderBy?: InstitutionSubscriptionOrderByWithRelationInput | InstitutionSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstitutionSubscriptions.
     */
    cursor?: InstitutionSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionSubscriptions.
     */
    skip?: number
    distinct?: InstitutionSubscriptionScalarFieldEnum | InstitutionSubscriptionScalarFieldEnum[]
  }

  /**
   * InstitutionSubscription create
   */
  export type InstitutionSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a InstitutionSubscription.
     */
    data: XOR<InstitutionSubscriptionCreateInput, InstitutionSubscriptionUncheckedCreateInput>
  }

  /**
   * InstitutionSubscription createMany
   */
  export type InstitutionSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstitutionSubscriptions.
     */
    data: InstitutionSubscriptionCreateManyInput | InstitutionSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstitutionSubscription createManyAndReturn
   */
  export type InstitutionSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many InstitutionSubscriptions.
     */
    data: InstitutionSubscriptionCreateManyInput | InstitutionSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstitutionSubscription update
   */
  export type InstitutionSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a InstitutionSubscription.
     */
    data: XOR<InstitutionSubscriptionUpdateInput, InstitutionSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which InstitutionSubscription to update.
     */
    where: InstitutionSubscriptionWhereUniqueInput
  }

  /**
   * InstitutionSubscription updateMany
   */
  export type InstitutionSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstitutionSubscriptions.
     */
    data: XOR<InstitutionSubscriptionUpdateManyMutationInput, InstitutionSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which InstitutionSubscriptions to update
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * Limit how many InstitutionSubscriptions to update.
     */
    limit?: number
  }

  /**
   * InstitutionSubscription updateManyAndReturn
   */
  export type InstitutionSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update InstitutionSubscriptions.
     */
    data: XOR<InstitutionSubscriptionUpdateManyMutationInput, InstitutionSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which InstitutionSubscriptions to update
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * Limit how many InstitutionSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstitutionSubscription upsert
   */
  export type InstitutionSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the InstitutionSubscription to update in case it exists.
     */
    where: InstitutionSubscriptionWhereUniqueInput
    /**
     * In case the InstitutionSubscription found by the `where` argument doesn't exist, create a new InstitutionSubscription with this data.
     */
    create: XOR<InstitutionSubscriptionCreateInput, InstitutionSubscriptionUncheckedCreateInput>
    /**
     * In case the InstitutionSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionSubscriptionUpdateInput, InstitutionSubscriptionUncheckedUpdateInput>
  }

  /**
   * InstitutionSubscription delete
   */
  export type InstitutionSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which InstitutionSubscription to delete.
     */
    where: InstitutionSubscriptionWhereUniqueInput
  }

  /**
   * InstitutionSubscription deleteMany
   */
  export type InstitutionSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstitutionSubscriptions to delete
     */
    where?: InstitutionSubscriptionWhereInput
    /**
     * Limit how many InstitutionSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * InstitutionSubscription.payments
   */
  export type InstitutionSubscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    where?: InstitutionPaymentWhereInput
    orderBy?: InstitutionPaymentOrderByWithRelationInput | InstitutionPaymentOrderByWithRelationInput[]
    cursor?: InstitutionPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionPaymentScalarFieldEnum | InstitutionPaymentScalarFieldEnum[]
  }

  /**
   * InstitutionSubscription without action
   */
  export type InstitutionSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model InstitutionPayment
   */

  export type AggregateInstitutionPayment = {
    _count: InstitutionPaymentCountAggregateOutputType | null
    _avg: InstitutionPaymentAvgAggregateOutputType | null
    _sum: InstitutionPaymentSumAggregateOutputType | null
    _min: InstitutionPaymentMinAggregateOutputType | null
    _max: InstitutionPaymentMaxAggregateOutputType | null
  }

  export type InstitutionPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InstitutionPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InstitutionPaymentMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    subscriptionId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    reference: string | null
    createdAt: Date | null
  }

  export type InstitutionPaymentMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    subscriptionId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    reference: string | null
    createdAt: Date | null
  }

  export type InstitutionPaymentCountAggregateOutputType = {
    id: number
    institutionId: number
    subscriptionId: number
    amount: number
    currency: number
    method: number
    status: number
    gatewayData: number
    reference: number
    createdAt: number
    _all: number
  }


  export type InstitutionPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type InstitutionPaymentSumAggregateInputType = {
    amount?: true
  }

  export type InstitutionPaymentMinAggregateInputType = {
    id?: true
    institutionId?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    createdAt?: true
  }

  export type InstitutionPaymentMaxAggregateInputType = {
    id?: true
    institutionId?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    createdAt?: true
  }

  export type InstitutionPaymentCountAggregateInputType = {
    id?: true
    institutionId?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    gatewayData?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type InstitutionPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstitutionPayment to aggregate.
     */
    where?: InstitutionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionPayments to fetch.
     */
    orderBy?: InstitutionPaymentOrderByWithRelationInput | InstitutionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstitutionPayments
    **/
    _count?: true | InstitutionPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutionPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutionPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionPaymentMaxAggregateInputType
  }

  export type GetInstitutionPaymentAggregateType<T extends InstitutionPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutionPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutionPayment[P]>
      : GetScalarType<T[P], AggregateInstitutionPayment[P]>
  }




  export type InstitutionPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionPaymentWhereInput
    orderBy?: InstitutionPaymentOrderByWithAggregationInput | InstitutionPaymentOrderByWithAggregationInput[]
    by: InstitutionPaymentScalarFieldEnum[] | InstitutionPaymentScalarFieldEnum
    having?: InstitutionPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionPaymentCountAggregateInputType | true
    _avg?: InstitutionPaymentAvgAggregateInputType
    _sum?: InstitutionPaymentSumAggregateInputType
    _min?: InstitutionPaymentMinAggregateInputType
    _max?: InstitutionPaymentMaxAggregateInputType
  }

  export type InstitutionPaymentGroupByOutputType = {
    id: string
    institutionId: string
    subscriptionId: string | null
    amount: Decimal
    currency: string
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    gatewayData: JsonValue | null
    reference: string | null
    createdAt: Date
    _count: InstitutionPaymentCountAggregateOutputType | null
    _avg: InstitutionPaymentAvgAggregateOutputType | null
    _sum: InstitutionPaymentSumAggregateOutputType | null
    _min: InstitutionPaymentMinAggregateOutputType | null
    _max: InstitutionPaymentMaxAggregateOutputType | null
  }

  type GetInstitutionPaymentGroupByPayload<T extends InstitutionPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionPaymentGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayData?: boolean
    reference?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    subscription?: boolean | InstitutionPayment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["institutionPayment"]>

  export type InstitutionPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayData?: boolean
    reference?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    subscription?: boolean | InstitutionPayment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["institutionPayment"]>

  export type InstitutionPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayData?: boolean
    reference?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    subscription?: boolean | InstitutionPayment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["institutionPayment"]>

  export type InstitutionPaymentSelectScalar = {
    id?: boolean
    institutionId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayData?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type InstitutionPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "subscriptionId" | "amount" | "currency" | "method" | "status" | "gatewayData" | "reference" | "createdAt", ExtArgs["result"]["institutionPayment"]>
  export type InstitutionPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    subscription?: boolean | InstitutionPayment$subscriptionArgs<ExtArgs>
  }
  export type InstitutionPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    subscription?: boolean | InstitutionPayment$subscriptionArgs<ExtArgs>
  }
  export type InstitutionPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    subscription?: boolean | InstitutionPayment$subscriptionArgs<ExtArgs>
  }

  export type $InstitutionPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstitutionPayment"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      subscription: Prisma.$InstitutionSubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      subscriptionId: string | null
      amount: Prisma.Decimal
      currency: string
      method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      gatewayData: Prisma.JsonValue | null
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["institutionPayment"]>
    composites: {}
  }

  type InstitutionPaymentGetPayload<S extends boolean | null | undefined | InstitutionPaymentDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPaymentPayload, S>

  type InstitutionPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionPaymentCountAggregateInputType | true
    }

  export interface InstitutionPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstitutionPayment'], meta: { name: 'InstitutionPayment' } }
    /**
     * Find zero or one InstitutionPayment that matches the filter.
     * @param {InstitutionPaymentFindUniqueArgs} args - Arguments to find a InstitutionPayment
     * @example
     * // Get one InstitutionPayment
     * const institutionPayment = await prisma.institutionPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionPaymentFindUniqueArgs>(args: SelectSubset<T, InstitutionPaymentFindUniqueArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstitutionPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionPaymentFindUniqueOrThrowArgs} args - Arguments to find a InstitutionPayment
     * @example
     * // Get one InstitutionPayment
     * const institutionPayment = await prisma.institutionPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstitutionPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentFindFirstArgs} args - Arguments to find a InstitutionPayment
     * @example
     * // Get one InstitutionPayment
     * const institutionPayment = await prisma.institutionPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionPaymentFindFirstArgs>(args?: SelectSubset<T, InstitutionPaymentFindFirstArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstitutionPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentFindFirstOrThrowArgs} args - Arguments to find a InstitutionPayment
     * @example
     * // Get one InstitutionPayment
     * const institutionPayment = await prisma.institutionPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstitutionPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstitutionPayments
     * const institutionPayments = await prisma.institutionPayment.findMany()
     * 
     * // Get first 10 InstitutionPayments
     * const institutionPayments = await prisma.institutionPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionPaymentWithIdOnly = await prisma.institutionPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionPaymentFindManyArgs>(args?: SelectSubset<T, InstitutionPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstitutionPayment.
     * @param {InstitutionPaymentCreateArgs} args - Arguments to create a InstitutionPayment.
     * @example
     * // Create one InstitutionPayment
     * const InstitutionPayment = await prisma.institutionPayment.create({
     *   data: {
     *     // ... data to create a InstitutionPayment
     *   }
     * })
     * 
     */
    create<T extends InstitutionPaymentCreateArgs>(args: SelectSubset<T, InstitutionPaymentCreateArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstitutionPayments.
     * @param {InstitutionPaymentCreateManyArgs} args - Arguments to create many InstitutionPayments.
     * @example
     * // Create many InstitutionPayments
     * const institutionPayment = await prisma.institutionPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionPaymentCreateManyArgs>(args?: SelectSubset<T, InstitutionPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstitutionPayments and returns the data saved in the database.
     * @param {InstitutionPaymentCreateManyAndReturnArgs} args - Arguments to create many InstitutionPayments.
     * @example
     * // Create many InstitutionPayments
     * const institutionPayment = await prisma.institutionPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstitutionPayments and only return the `id`
     * const institutionPaymentWithIdOnly = await prisma.institutionPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstitutionPayment.
     * @param {InstitutionPaymentDeleteArgs} args - Arguments to delete one InstitutionPayment.
     * @example
     * // Delete one InstitutionPayment
     * const InstitutionPayment = await prisma.institutionPayment.delete({
     *   where: {
     *     // ... filter to delete one InstitutionPayment
     *   }
     * })
     * 
     */
    delete<T extends InstitutionPaymentDeleteArgs>(args: SelectSubset<T, InstitutionPaymentDeleteArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstitutionPayment.
     * @param {InstitutionPaymentUpdateArgs} args - Arguments to update one InstitutionPayment.
     * @example
     * // Update one InstitutionPayment
     * const institutionPayment = await prisma.institutionPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionPaymentUpdateArgs>(args: SelectSubset<T, InstitutionPaymentUpdateArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstitutionPayments.
     * @param {InstitutionPaymentDeleteManyArgs} args - Arguments to filter InstitutionPayments to delete.
     * @example
     * // Delete a few InstitutionPayments
     * const { count } = await prisma.institutionPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionPaymentDeleteManyArgs>(args?: SelectSubset<T, InstitutionPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstitutionPayments
     * const institutionPayment = await prisma.institutionPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionPaymentUpdateManyArgs>(args: SelectSubset<T, InstitutionPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionPayments and returns the data updated in the database.
     * @param {InstitutionPaymentUpdateManyAndReturnArgs} args - Arguments to update many InstitutionPayments.
     * @example
     * // Update many InstitutionPayments
     * const institutionPayment = await prisma.institutionPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstitutionPayments and only return the `id`
     * const institutionPaymentWithIdOnly = await prisma.institutionPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstitutionPayment.
     * @param {InstitutionPaymentUpsertArgs} args - Arguments to update or create a InstitutionPayment.
     * @example
     * // Update or create a InstitutionPayment
     * const institutionPayment = await prisma.institutionPayment.upsert({
     *   create: {
     *     // ... data to create a InstitutionPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstitutionPayment we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionPaymentUpsertArgs>(args: SelectSubset<T, InstitutionPaymentUpsertArgs<ExtArgs>>): Prisma__InstitutionPaymentClient<$Result.GetResult<Prisma.$InstitutionPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstitutionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentCountArgs} args - Arguments to filter InstitutionPayments to count.
     * @example
     * // Count the number of InstitutionPayments
     * const count = await prisma.institutionPayment.count({
     *   where: {
     *     // ... the filter for the InstitutionPayments we want to count
     *   }
     * })
    **/
    count<T extends InstitutionPaymentCountArgs>(
      args?: Subset<T, InstitutionPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstitutionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionPaymentAggregateArgs>(args: Subset<T, InstitutionPaymentAggregateArgs>): Prisma.PrismaPromise<GetInstitutionPaymentAggregateType<T>>

    /**
     * Group by InstitutionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionPaymentGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstitutionPayment model
   */
  readonly fields: InstitutionPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstitutionPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends InstitutionPayment$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionPayment$subscriptionArgs<ExtArgs>>): Prisma__InstitutionSubscriptionClient<$Result.GetResult<Prisma.$InstitutionSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstitutionPayment model
   */
  interface InstitutionPaymentFieldRefs {
    readonly id: FieldRef<"InstitutionPayment", 'String'>
    readonly institutionId: FieldRef<"InstitutionPayment", 'String'>
    readonly subscriptionId: FieldRef<"InstitutionPayment", 'String'>
    readonly amount: FieldRef<"InstitutionPayment", 'Decimal'>
    readonly currency: FieldRef<"InstitutionPayment", 'String'>
    readonly method: FieldRef<"InstitutionPayment", 'PaymentMethod'>
    readonly status: FieldRef<"InstitutionPayment", 'PaymentStatus'>
    readonly gatewayData: FieldRef<"InstitutionPayment", 'Json'>
    readonly reference: FieldRef<"InstitutionPayment", 'String'>
    readonly createdAt: FieldRef<"InstitutionPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstitutionPayment findUnique
   */
  export type InstitutionPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionPayment to fetch.
     */
    where: InstitutionPaymentWhereUniqueInput
  }

  /**
   * InstitutionPayment findUniqueOrThrow
   */
  export type InstitutionPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionPayment to fetch.
     */
    where: InstitutionPaymentWhereUniqueInput
  }

  /**
   * InstitutionPayment findFirst
   */
  export type InstitutionPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionPayment to fetch.
     */
    where?: InstitutionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionPayments to fetch.
     */
    orderBy?: InstitutionPaymentOrderByWithRelationInput | InstitutionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstitutionPayments.
     */
    cursor?: InstitutionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstitutionPayments.
     */
    distinct?: InstitutionPaymentScalarFieldEnum | InstitutionPaymentScalarFieldEnum[]
  }

  /**
   * InstitutionPayment findFirstOrThrow
   */
  export type InstitutionPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionPayment to fetch.
     */
    where?: InstitutionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionPayments to fetch.
     */
    orderBy?: InstitutionPaymentOrderByWithRelationInput | InstitutionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstitutionPayments.
     */
    cursor?: InstitutionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstitutionPayments.
     */
    distinct?: InstitutionPaymentScalarFieldEnum | InstitutionPaymentScalarFieldEnum[]
  }

  /**
   * InstitutionPayment findMany
   */
  export type InstitutionPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionPayments to fetch.
     */
    where?: InstitutionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionPayments to fetch.
     */
    orderBy?: InstitutionPaymentOrderByWithRelationInput | InstitutionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstitutionPayments.
     */
    cursor?: InstitutionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionPayments.
     */
    skip?: number
    distinct?: InstitutionPaymentScalarFieldEnum | InstitutionPaymentScalarFieldEnum[]
  }

  /**
   * InstitutionPayment create
   */
  export type InstitutionPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a InstitutionPayment.
     */
    data: XOR<InstitutionPaymentCreateInput, InstitutionPaymentUncheckedCreateInput>
  }

  /**
   * InstitutionPayment createMany
   */
  export type InstitutionPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstitutionPayments.
     */
    data: InstitutionPaymentCreateManyInput | InstitutionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstitutionPayment createManyAndReturn
   */
  export type InstitutionPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many InstitutionPayments.
     */
    data: InstitutionPaymentCreateManyInput | InstitutionPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstitutionPayment update
   */
  export type InstitutionPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a InstitutionPayment.
     */
    data: XOR<InstitutionPaymentUpdateInput, InstitutionPaymentUncheckedUpdateInput>
    /**
     * Choose, which InstitutionPayment to update.
     */
    where: InstitutionPaymentWhereUniqueInput
  }

  /**
   * InstitutionPayment updateMany
   */
  export type InstitutionPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstitutionPayments.
     */
    data: XOR<InstitutionPaymentUpdateManyMutationInput, InstitutionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which InstitutionPayments to update
     */
    where?: InstitutionPaymentWhereInput
    /**
     * Limit how many InstitutionPayments to update.
     */
    limit?: number
  }

  /**
   * InstitutionPayment updateManyAndReturn
   */
  export type InstitutionPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * The data used to update InstitutionPayments.
     */
    data: XOR<InstitutionPaymentUpdateManyMutationInput, InstitutionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which InstitutionPayments to update
     */
    where?: InstitutionPaymentWhereInput
    /**
     * Limit how many InstitutionPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstitutionPayment upsert
   */
  export type InstitutionPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the InstitutionPayment to update in case it exists.
     */
    where: InstitutionPaymentWhereUniqueInput
    /**
     * In case the InstitutionPayment found by the `where` argument doesn't exist, create a new InstitutionPayment with this data.
     */
    create: XOR<InstitutionPaymentCreateInput, InstitutionPaymentUncheckedCreateInput>
    /**
     * In case the InstitutionPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionPaymentUpdateInput, InstitutionPaymentUncheckedUpdateInput>
  }

  /**
   * InstitutionPayment delete
   */
  export type InstitutionPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
    /**
     * Filter which InstitutionPayment to delete.
     */
    where: InstitutionPaymentWhereUniqueInput
  }

  /**
   * InstitutionPayment deleteMany
   */
  export type InstitutionPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstitutionPayments to delete
     */
    where?: InstitutionPaymentWhereInput
    /**
     * Limit how many InstitutionPayments to delete.
     */
    limit?: number
  }

  /**
   * InstitutionPayment.subscription
   */
  export type InstitutionPayment$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionSubscription
     */
    select?: InstitutionSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionSubscription
     */
    omit?: InstitutionSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionSubscriptionInclude<ExtArgs> | null
    where?: InstitutionSubscriptionWhereInput
  }

  /**
   * InstitutionPayment without action
   */
  export type InstitutionPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionPayment
     */
    select?: InstitutionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionPayment
     */
    omit?: InstitutionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionPaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    email: string | null
    password: string | null
    fullName: string | null
    ci: string | null
    phone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    email: string | null
    password: string | null
    fullName: string | null
    ci: string | null
    phone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    institutionId: number
    email: number
    password: number
    fullName: number
    ci: number
    phone: number
    isActive: number
    attributes: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    institutionId?: true
    email?: true
    password?: true
    fullName?: true
    ci?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    institutionId?: true
    email?: true
    password?: true
    fullName?: true
    ci?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    institutionId?: true
    email?: true
    password?: true
    fullName?: true
    ci?: true
    phone?: true
    isActive?: true
    attributes?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    institutionId: string | null
    email: string
    password: string | null
    fullName: string
    ci: string | null
    phone: string | null
    isActive: boolean
    attributes: JsonValue | null
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    ci?: boolean
    phone?: boolean
    isActive?: boolean
    attributes?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    institution?: boolean | User$institutionArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    tutorProfile?: boolean | User$tutorProfileArgs<ExtArgs>
    dashboards?: boolean | User$dashboardsArgs<ExtArgs>
    aiUsages?: boolean | User$aiUsagesArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    careers?: boolean | User$careersArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    lessonPlans?: boolean | User$lessonPlansArgs<ExtArgs>
    virtualClassrooms?: boolean | User$virtualClassroomsArgs<ExtArgs>
    grades?: boolean | User$gradesArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    disciplinaryRecord?: boolean | User$disciplinaryRecordArgs<ExtArgs>
    certificate?: boolean | User$certificateArgs<ExtArgs>
    aIConversation?: boolean | User$aIConversationArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    announcement?: boolean | User$announcementArgs<ExtArgs>
    dataBackups?: boolean | User$dataBackupsArgs<ExtArgs>
    templates?: boolean | User$templatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    ci?: boolean
    phone?: boolean
    isActive?: boolean
    attributes?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    institution?: boolean | User$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    ci?: boolean
    phone?: boolean
    isActive?: boolean
    attributes?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    institution?: boolean | User$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    institutionId?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    ci?: boolean
    phone?: boolean
    isActive?: boolean
    attributes?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "email" | "password" | "fullName" | "ci" | "phone" | "isActive" | "attributes" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | User$institutionArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    tutorProfile?: boolean | User$tutorProfileArgs<ExtArgs>
    dashboards?: boolean | User$dashboardsArgs<ExtArgs>
    aiUsages?: boolean | User$aiUsagesArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    careers?: boolean | User$careersArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    lessonPlans?: boolean | User$lessonPlansArgs<ExtArgs>
    virtualClassrooms?: boolean | User$virtualClassroomsArgs<ExtArgs>
    grades?: boolean | User$gradesArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    disciplinaryRecord?: boolean | User$disciplinaryRecordArgs<ExtArgs>
    certificate?: boolean | User$certificateArgs<ExtArgs>
    aIConversation?: boolean | User$aIConversationArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    announcement?: boolean | User$announcementArgs<ExtArgs>
    dataBackups?: boolean | User$dataBackupsArgs<ExtArgs>
    templates?: boolean | User$templatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | User$institutionArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | User$institutionArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      tutorProfile: Prisma.$TutorProfilePayload<ExtArgs> | null
      dashboards: Prisma.$DashboardConfigPayload<ExtArgs>[]
      aiUsages: Prisma.$AIUsageLogPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      logs: Prisma.$InstitutionLogPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      careers: Prisma.$CareerPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      lessonPlans: Prisma.$LessonPlanPayload<ExtArgs>[]
      virtualClassrooms: Prisma.$VirtualClassroomPayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      disciplinaryRecord: Prisma.$DisciplinaryRecordPayload<ExtArgs>[]
      certificate: Prisma.$CertificatePayload<ExtArgs>[]
      aIConversation: Prisma.$AIConversationPayload<ExtArgs>[]
      notificationPreference: Prisma.$NotificationPreferencePayload<ExtArgs>[]
      announcement: Prisma.$AnnouncementPayload<ExtArgs>[]
      dataBackups: Prisma.$DataBackupPayload<ExtArgs>[]
      templates: Prisma.$TemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string | null
      email: string
      password: string | null
      fullName: string
      ci: string | null
      phone: string | null
      isActive: boolean
      attributes: Prisma.JsonValue | null
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends User$institutionArgs<ExtArgs> = {}>(args?: Subset<T, User$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutorProfile<T extends User$tutorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$tutorProfileArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dashboards<T extends User$dashboardsArgs<ExtArgs> = {}>(args?: Subset<T, User$dashboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiUsages<T extends User$aiUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$aiUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    careers<T extends User$careersArgs<ExtArgs> = {}>(args?: Subset<T, User$careersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonPlans<T extends User$lessonPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    virtualClassrooms<T extends User$virtualClassroomsArgs<ExtArgs> = {}>(args?: Subset<T, User$virtualClassroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grades<T extends User$gradesArgs<ExtArgs> = {}>(args?: Subset<T, User$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disciplinaryRecord<T extends User$disciplinaryRecordArgs<ExtArgs> = {}>(args?: Subset<T, User$disciplinaryRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificate<T extends User$certificateArgs<ExtArgs> = {}>(args?: Subset<T, User$certificateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aIConversation<T extends User$aIConversationArgs<ExtArgs> = {}>(args?: Subset<T, User$aIConversationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreference<T extends User$notificationPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcement<T extends User$announcementArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataBackups<T extends User$dataBackupsArgs<ExtArgs> = {}>(args?: Subset<T, User$dataBackupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templates<T extends User$templatesArgs<ExtArgs> = {}>(args?: Subset<T, User$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly institutionId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly ci: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly attributes: FieldRef<"User", 'Json'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.institution
   */
  export type User$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.tutorProfile
   */
  export type User$tutorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    where?: TutorProfileWhereInput
  }

  /**
   * User.dashboards
   */
  export type User$dashboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    where?: DashboardConfigWhereInput
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    cursor?: DashboardConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * User.aiUsages
   */
  export type User$aiUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    cursor?: AIUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    where?: InstitutionLogWhereInput
    orderBy?: InstitutionLogOrderByWithRelationInput | InstitutionLogOrderByWithRelationInput[]
    cursor?: InstitutionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionLogScalarFieldEnum | InstitutionLogScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.careers
   */
  export type User$careersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    where?: CareerWhereInput
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    cursor?: CareerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.lessonPlans
   */
  export type User$lessonPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    where?: LessonPlanWhereInput
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    cursor?: LessonPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * User.virtualClassrooms
   */
  export type User$virtualClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    where?: VirtualClassroomWhereInput
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    cursor?: VirtualClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassroomScalarFieldEnum | VirtualClassroomScalarFieldEnum[]
  }

  /**
   * User.grades
   */
  export type User$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.disciplinaryRecord
   */
  export type User$disciplinaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    where?: DisciplinaryRecordWhereInput
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    cursor?: DisciplinaryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisciplinaryRecordScalarFieldEnum | DisciplinaryRecordScalarFieldEnum[]
  }

  /**
   * User.certificate
   */
  export type User$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.aIConversation
   */
  export type User$aIConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    cursor?: AIConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * User.notificationPreference
   */
  export type User$notificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    cursor?: NotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * User.announcement
   */
  export type User$announcementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.dataBackups
   */
  export type User$dataBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    where?: DataBackupWhereInput
    orderBy?: DataBackupOrderByWithRelationInput | DataBackupOrderByWithRelationInput[]
    cursor?: DataBackupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataBackupScalarFieldEnum | DataBackupScalarFieldEnum[]
  }

  /**
   * User.templates
   */
  export type User$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: $Enums.RoleName | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: $Enums.RoleName | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    description: number
    isSystem: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    institutionId: string | null
    name: $Enums.RoleName
    description: string | null
    isSystem: boolean
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    institution?: boolean | Role$institutionArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    institution?: boolean | Role$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    institution?: boolean | Role$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "description" | "isSystem" | "createdAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | Role$institutionArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | Role$institutionArgs<ExtArgs>
  }
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | Role$institutionArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string | null
      name: $Enums.RoleName
      description: string | null
      isSystem: boolean
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends Role$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Role$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly institutionId: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'RoleName'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.institution
   */
  export type Role$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    isPrimary: number
    assignedAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    isPrimary?: true
    assignedAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    isPrimary?: true
    assignedAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    isPrimary?: true
    assignedAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    isPrimary: boolean
    assignedAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "isPrimary" | "assignedAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      isPrimary: boolean
      assignedAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly isPrimary: FieldRef<"UserRole", 'Boolean'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model ABACPolicy
   */

  export type AggregateABACPolicy = {
    _count: ABACPolicyCountAggregateOutputType | null
    _min: ABACPolicyMinAggregateOutputType | null
    _max: ABACPolicyMaxAggregateOutputType | null
  }

  export type ABACPolicyMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    description: string | null
    resource: string | null
    action: string | null
    effect: $Enums.PolicyEffect | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ABACPolicyMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    description: string | null
    resource: string | null
    action: string | null
    effect: $Enums.PolicyEffect | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ABACPolicyCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    description: number
    resource: number
    action: number
    condition: number
    effect: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ABACPolicyMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    effect?: true
    isActive?: true
    createdAt?: true
  }

  export type ABACPolicyMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    effect?: true
    isActive?: true
    createdAt?: true
  }

  export type ABACPolicyCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    condition?: true
    effect?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ABACPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABACPolicy to aggregate.
     */
    where?: ABACPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABACPolicies to fetch.
     */
    orderBy?: ABACPolicyOrderByWithRelationInput | ABACPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ABACPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABACPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABACPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ABACPolicies
    **/
    _count?: true | ABACPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ABACPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ABACPolicyMaxAggregateInputType
  }

  export type GetABACPolicyAggregateType<T extends ABACPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateABACPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateABACPolicy[P]>
      : GetScalarType<T[P], AggregateABACPolicy[P]>
  }




  export type ABACPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABACPolicyWhereInput
    orderBy?: ABACPolicyOrderByWithAggregationInput | ABACPolicyOrderByWithAggregationInput[]
    by: ABACPolicyScalarFieldEnum[] | ABACPolicyScalarFieldEnum
    having?: ABACPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ABACPolicyCountAggregateInputType | true
    _min?: ABACPolicyMinAggregateInputType
    _max?: ABACPolicyMaxAggregateInputType
  }

  export type ABACPolicyGroupByOutputType = {
    id: string
    institutionId: string | null
    name: string
    description: string | null
    resource: string
    action: string
    condition: JsonValue | null
    effect: $Enums.PolicyEffect
    isActive: boolean
    createdAt: Date
    _count: ABACPolicyCountAggregateOutputType | null
    _min: ABACPolicyMinAggregateOutputType | null
    _max: ABACPolicyMaxAggregateOutputType | null
  }

  type GetABACPolicyGroupByPayload<T extends ABACPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ABACPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ABACPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ABACPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], ABACPolicyGroupByOutputType[P]>
        }
      >
    >


  export type ABACPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    condition?: boolean
    effect?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | ABACPolicy$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["aBACPolicy"]>

  export type ABACPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    condition?: boolean
    effect?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | ABACPolicy$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["aBACPolicy"]>

  export type ABACPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    condition?: boolean
    effect?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | ABACPolicy$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["aBACPolicy"]>

  export type ABACPolicySelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    condition?: boolean
    effect?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ABACPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "description" | "resource" | "action" | "condition" | "effect" | "isActive" | "createdAt", ExtArgs["result"]["aBACPolicy"]>
  export type ABACPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | ABACPolicy$institutionArgs<ExtArgs>
  }
  export type ABACPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | ABACPolicy$institutionArgs<ExtArgs>
  }
  export type ABACPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | ABACPolicy$institutionArgs<ExtArgs>
  }

  export type $ABACPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ABACPolicy"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string | null
      name: string
      description: string | null
      resource: string
      action: string
      condition: Prisma.JsonValue | null
      effect: $Enums.PolicyEffect
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["aBACPolicy"]>
    composites: {}
  }

  type ABACPolicyGetPayload<S extends boolean | null | undefined | ABACPolicyDefaultArgs> = $Result.GetResult<Prisma.$ABACPolicyPayload, S>

  type ABACPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ABACPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ABACPolicyCountAggregateInputType | true
    }

  export interface ABACPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ABACPolicy'], meta: { name: 'ABACPolicy' } }
    /**
     * Find zero or one ABACPolicy that matches the filter.
     * @param {ABACPolicyFindUniqueArgs} args - Arguments to find a ABACPolicy
     * @example
     * // Get one ABACPolicy
     * const aBACPolicy = await prisma.aBACPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ABACPolicyFindUniqueArgs>(args: SelectSubset<T, ABACPolicyFindUniqueArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ABACPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ABACPolicyFindUniqueOrThrowArgs} args - Arguments to find a ABACPolicy
     * @example
     * // Get one ABACPolicy
     * const aBACPolicy = await prisma.aBACPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ABACPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, ABACPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABACPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyFindFirstArgs} args - Arguments to find a ABACPolicy
     * @example
     * // Get one ABACPolicy
     * const aBACPolicy = await prisma.aBACPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ABACPolicyFindFirstArgs>(args?: SelectSubset<T, ABACPolicyFindFirstArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABACPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyFindFirstOrThrowArgs} args - Arguments to find a ABACPolicy
     * @example
     * // Get one ABACPolicy
     * const aBACPolicy = await prisma.aBACPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ABACPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, ABACPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ABACPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ABACPolicies
     * const aBACPolicies = await prisma.aBACPolicy.findMany()
     * 
     * // Get first 10 ABACPolicies
     * const aBACPolicies = await prisma.aBACPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aBACPolicyWithIdOnly = await prisma.aBACPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ABACPolicyFindManyArgs>(args?: SelectSubset<T, ABACPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ABACPolicy.
     * @param {ABACPolicyCreateArgs} args - Arguments to create a ABACPolicy.
     * @example
     * // Create one ABACPolicy
     * const ABACPolicy = await prisma.aBACPolicy.create({
     *   data: {
     *     // ... data to create a ABACPolicy
     *   }
     * })
     * 
     */
    create<T extends ABACPolicyCreateArgs>(args: SelectSubset<T, ABACPolicyCreateArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ABACPolicies.
     * @param {ABACPolicyCreateManyArgs} args - Arguments to create many ABACPolicies.
     * @example
     * // Create many ABACPolicies
     * const aBACPolicy = await prisma.aBACPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ABACPolicyCreateManyArgs>(args?: SelectSubset<T, ABACPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ABACPolicies and returns the data saved in the database.
     * @param {ABACPolicyCreateManyAndReturnArgs} args - Arguments to create many ABACPolicies.
     * @example
     * // Create many ABACPolicies
     * const aBACPolicy = await prisma.aBACPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ABACPolicies and only return the `id`
     * const aBACPolicyWithIdOnly = await prisma.aBACPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ABACPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, ABACPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ABACPolicy.
     * @param {ABACPolicyDeleteArgs} args - Arguments to delete one ABACPolicy.
     * @example
     * // Delete one ABACPolicy
     * const ABACPolicy = await prisma.aBACPolicy.delete({
     *   where: {
     *     // ... filter to delete one ABACPolicy
     *   }
     * })
     * 
     */
    delete<T extends ABACPolicyDeleteArgs>(args: SelectSubset<T, ABACPolicyDeleteArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ABACPolicy.
     * @param {ABACPolicyUpdateArgs} args - Arguments to update one ABACPolicy.
     * @example
     * // Update one ABACPolicy
     * const aBACPolicy = await prisma.aBACPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ABACPolicyUpdateArgs>(args: SelectSubset<T, ABACPolicyUpdateArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ABACPolicies.
     * @param {ABACPolicyDeleteManyArgs} args - Arguments to filter ABACPolicies to delete.
     * @example
     * // Delete a few ABACPolicies
     * const { count } = await prisma.aBACPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ABACPolicyDeleteManyArgs>(args?: SelectSubset<T, ABACPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABACPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ABACPolicies
     * const aBACPolicy = await prisma.aBACPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ABACPolicyUpdateManyArgs>(args: SelectSubset<T, ABACPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABACPolicies and returns the data updated in the database.
     * @param {ABACPolicyUpdateManyAndReturnArgs} args - Arguments to update many ABACPolicies.
     * @example
     * // Update many ABACPolicies
     * const aBACPolicy = await prisma.aBACPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ABACPolicies and only return the `id`
     * const aBACPolicyWithIdOnly = await prisma.aBACPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ABACPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, ABACPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ABACPolicy.
     * @param {ABACPolicyUpsertArgs} args - Arguments to update or create a ABACPolicy.
     * @example
     * // Update or create a ABACPolicy
     * const aBACPolicy = await prisma.aBACPolicy.upsert({
     *   create: {
     *     // ... data to create a ABACPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ABACPolicy we want to update
     *   }
     * })
     */
    upsert<T extends ABACPolicyUpsertArgs>(args: SelectSubset<T, ABACPolicyUpsertArgs<ExtArgs>>): Prisma__ABACPolicyClient<$Result.GetResult<Prisma.$ABACPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ABACPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyCountArgs} args - Arguments to filter ABACPolicies to count.
     * @example
     * // Count the number of ABACPolicies
     * const count = await prisma.aBACPolicy.count({
     *   where: {
     *     // ... the filter for the ABACPolicies we want to count
     *   }
     * })
    **/
    count<T extends ABACPolicyCountArgs>(
      args?: Subset<T, ABACPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ABACPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ABACPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ABACPolicyAggregateArgs>(args: Subset<T, ABACPolicyAggregateArgs>): Prisma.PrismaPromise<GetABACPolicyAggregateType<T>>

    /**
     * Group by ABACPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABACPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ABACPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ABACPolicyGroupByArgs['orderBy'] }
        : { orderBy?: ABACPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ABACPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetABACPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ABACPolicy model
   */
  readonly fields: ABACPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ABACPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ABACPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends ABACPolicy$institutionArgs<ExtArgs> = {}>(args?: Subset<T, ABACPolicy$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ABACPolicy model
   */
  interface ABACPolicyFieldRefs {
    readonly id: FieldRef<"ABACPolicy", 'String'>
    readonly institutionId: FieldRef<"ABACPolicy", 'String'>
    readonly name: FieldRef<"ABACPolicy", 'String'>
    readonly description: FieldRef<"ABACPolicy", 'String'>
    readonly resource: FieldRef<"ABACPolicy", 'String'>
    readonly action: FieldRef<"ABACPolicy", 'String'>
    readonly condition: FieldRef<"ABACPolicy", 'Json'>
    readonly effect: FieldRef<"ABACPolicy", 'PolicyEffect'>
    readonly isActive: FieldRef<"ABACPolicy", 'Boolean'>
    readonly createdAt: FieldRef<"ABACPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ABACPolicy findUnique
   */
  export type ABACPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * Filter, which ABACPolicy to fetch.
     */
    where: ABACPolicyWhereUniqueInput
  }

  /**
   * ABACPolicy findUniqueOrThrow
   */
  export type ABACPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * Filter, which ABACPolicy to fetch.
     */
    where: ABACPolicyWhereUniqueInput
  }

  /**
   * ABACPolicy findFirst
   */
  export type ABACPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * Filter, which ABACPolicy to fetch.
     */
    where?: ABACPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABACPolicies to fetch.
     */
    orderBy?: ABACPolicyOrderByWithRelationInput | ABACPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABACPolicies.
     */
    cursor?: ABACPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABACPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABACPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABACPolicies.
     */
    distinct?: ABACPolicyScalarFieldEnum | ABACPolicyScalarFieldEnum[]
  }

  /**
   * ABACPolicy findFirstOrThrow
   */
  export type ABACPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * Filter, which ABACPolicy to fetch.
     */
    where?: ABACPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABACPolicies to fetch.
     */
    orderBy?: ABACPolicyOrderByWithRelationInput | ABACPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABACPolicies.
     */
    cursor?: ABACPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABACPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABACPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABACPolicies.
     */
    distinct?: ABACPolicyScalarFieldEnum | ABACPolicyScalarFieldEnum[]
  }

  /**
   * ABACPolicy findMany
   */
  export type ABACPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * Filter, which ABACPolicies to fetch.
     */
    where?: ABACPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABACPolicies to fetch.
     */
    orderBy?: ABACPolicyOrderByWithRelationInput | ABACPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ABACPolicies.
     */
    cursor?: ABACPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABACPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABACPolicies.
     */
    skip?: number
    distinct?: ABACPolicyScalarFieldEnum | ABACPolicyScalarFieldEnum[]
  }

  /**
   * ABACPolicy create
   */
  export type ABACPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a ABACPolicy.
     */
    data: XOR<ABACPolicyCreateInput, ABACPolicyUncheckedCreateInput>
  }

  /**
   * ABACPolicy createMany
   */
  export type ABACPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ABACPolicies.
     */
    data: ABACPolicyCreateManyInput | ABACPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ABACPolicy createManyAndReturn
   */
  export type ABACPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many ABACPolicies.
     */
    data: ABACPolicyCreateManyInput | ABACPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ABACPolicy update
   */
  export type ABACPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a ABACPolicy.
     */
    data: XOR<ABACPolicyUpdateInput, ABACPolicyUncheckedUpdateInput>
    /**
     * Choose, which ABACPolicy to update.
     */
    where: ABACPolicyWhereUniqueInput
  }

  /**
   * ABACPolicy updateMany
   */
  export type ABACPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ABACPolicies.
     */
    data: XOR<ABACPolicyUpdateManyMutationInput, ABACPolicyUncheckedUpdateManyInput>
    /**
     * Filter which ABACPolicies to update
     */
    where?: ABACPolicyWhereInput
    /**
     * Limit how many ABACPolicies to update.
     */
    limit?: number
  }

  /**
   * ABACPolicy updateManyAndReturn
   */
  export type ABACPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * The data used to update ABACPolicies.
     */
    data: XOR<ABACPolicyUpdateManyMutationInput, ABACPolicyUncheckedUpdateManyInput>
    /**
     * Filter which ABACPolicies to update
     */
    where?: ABACPolicyWhereInput
    /**
     * Limit how many ABACPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ABACPolicy upsert
   */
  export type ABACPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the ABACPolicy to update in case it exists.
     */
    where: ABACPolicyWhereUniqueInput
    /**
     * In case the ABACPolicy found by the `where` argument doesn't exist, create a new ABACPolicy with this data.
     */
    create: XOR<ABACPolicyCreateInput, ABACPolicyUncheckedCreateInput>
    /**
     * In case the ABACPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ABACPolicyUpdateInput, ABACPolicyUncheckedUpdateInput>
  }

  /**
   * ABACPolicy delete
   */
  export type ABACPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
    /**
     * Filter which ABACPolicy to delete.
     */
    where: ABACPolicyWhereUniqueInput
  }

  /**
   * ABACPolicy deleteMany
   */
  export type ABACPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABACPolicies to delete
     */
    where?: ABACPolicyWhereInput
    /**
     * Limit how many ABACPolicies to delete.
     */
    limit?: number
  }

  /**
   * ABACPolicy.institution
   */
  export type ABACPolicy$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * ABACPolicy without action
   */
  export type ABACPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABACPolicy
     */
    select?: ABACPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABACPolicy
     */
    omit?: ABACPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABACPolicyInclude<ExtArgs> | null
  }


  /**
   * Model Career
   */

  export type AggregateCareer = {
    _count: CareerCountAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  export type CareerMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    code: string | null
    level: $Enums.LevelType | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type CareerMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    code: string | null
    level: $Enums.LevelType | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type CareerCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    code: number
    level: number
    description: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type CareerMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    code?: true
    level?: true
    description?: true
    createdById?: true
    createdAt?: true
  }

  export type CareerMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    code?: true
    level?: true
    description?: true
    createdById?: true
    createdAt?: true
  }

  export type CareerCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    code?: true
    level?: true
    description?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type CareerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Career to aggregate.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Careers
    **/
    _count?: true | CareerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerMaxAggregateInputType
  }

  export type GetCareerAggregateType<T extends CareerAggregateArgs> = {
        [P in keyof T & keyof AggregateCareer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareer[P]>
      : GetScalarType<T[P], AggregateCareer[P]>
  }




  export type CareerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
    orderBy?: CareerOrderByWithAggregationInput | CareerOrderByWithAggregationInput[]
    by: CareerScalarFieldEnum[] | CareerScalarFieldEnum
    having?: CareerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerCountAggregateInputType | true
    _min?: CareerMinAggregateInputType
    _max?: CareerMaxAggregateInputType
  }

  export type CareerGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    code: string | null
    level: $Enums.LevelType
    description: string | null
    createdById: string | null
    createdAt: Date
    _count: CareerCountAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  type GetCareerGroupByPayload<T extends CareerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerGroupByOutputType[P]>
            : GetScalarType<T[P], CareerGroupByOutputType[P]>
        }
      >
    >


  export type CareerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Career$createdByArgs<ExtArgs>
    courses?: boolean | Career$coursesArgs<ExtArgs>
    periods?: boolean | Career$periodsArgs<ExtArgs>
    students?: boolean | Career$studentsArgs<ExtArgs>
    feeSchedule?: boolean | Career$feeScheduleArgs<ExtArgs>
    _count?: boolean | CareerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["career"]>

  export type CareerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Career$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["career"]>

  export type CareerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Career$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["career"]>

  export type CareerSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type CareerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "code" | "level" | "description" | "createdById" | "createdAt", ExtArgs["result"]["career"]>
  export type CareerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Career$createdByArgs<ExtArgs>
    courses?: boolean | Career$coursesArgs<ExtArgs>
    periods?: boolean | Career$periodsArgs<ExtArgs>
    students?: boolean | Career$studentsArgs<ExtArgs>
    feeSchedule?: boolean | Career$feeScheduleArgs<ExtArgs>
    _count?: boolean | CareerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CareerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Career$createdByArgs<ExtArgs>
  }
  export type CareerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Career$createdByArgs<ExtArgs>
  }

  export type $CareerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Career"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      courses: Prisma.$CoursePayload<ExtArgs>[]
      periods: Prisma.$AcademicPeriodPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      feeSchedule: Prisma.$FeeSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      code: string | null
      level: $Enums.LevelType
      description: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["career"]>
    composites: {}
  }

  type CareerGetPayload<S extends boolean | null | undefined | CareerDefaultArgs> = $Result.GetResult<Prisma.$CareerPayload, S>

  type CareerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CareerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerCountAggregateInputType | true
    }

  export interface CareerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Career'], meta: { name: 'Career' } }
    /**
     * Find zero or one Career that matches the filter.
     * @param {CareerFindUniqueArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerFindUniqueArgs>(args: SelectSubset<T, CareerFindUniqueArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Career that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CareerFindUniqueOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Career that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerFindFirstArgs>(args?: SelectSubset<T, CareerFindFirstArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Career that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Careers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Careers
     * const careers = await prisma.career.findMany()
     * 
     * // Get first 10 Careers
     * const careers = await prisma.career.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerWithIdOnly = await prisma.career.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerFindManyArgs>(args?: SelectSubset<T, CareerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Career.
     * @param {CareerCreateArgs} args - Arguments to create a Career.
     * @example
     * // Create one Career
     * const Career = await prisma.career.create({
     *   data: {
     *     // ... data to create a Career
     *   }
     * })
     * 
     */
    create<T extends CareerCreateArgs>(args: SelectSubset<T, CareerCreateArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Careers.
     * @param {CareerCreateManyArgs} args - Arguments to create many Careers.
     * @example
     * // Create many Careers
     * const career = await prisma.career.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerCreateManyArgs>(args?: SelectSubset<T, CareerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Careers and returns the data saved in the database.
     * @param {CareerCreateManyAndReturnArgs} args - Arguments to create many Careers.
     * @example
     * // Create many Careers
     * const career = await prisma.career.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Careers and only return the `id`
     * const careerWithIdOnly = await prisma.career.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareerCreateManyAndReturnArgs>(args?: SelectSubset<T, CareerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Career.
     * @param {CareerDeleteArgs} args - Arguments to delete one Career.
     * @example
     * // Delete one Career
     * const Career = await prisma.career.delete({
     *   where: {
     *     // ... filter to delete one Career
     *   }
     * })
     * 
     */
    delete<T extends CareerDeleteArgs>(args: SelectSubset<T, CareerDeleteArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Career.
     * @param {CareerUpdateArgs} args - Arguments to update one Career.
     * @example
     * // Update one Career
     * const career = await prisma.career.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerUpdateArgs>(args: SelectSubset<T, CareerUpdateArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Careers.
     * @param {CareerDeleteManyArgs} args - Arguments to filter Careers to delete.
     * @example
     * // Delete a few Careers
     * const { count } = await prisma.career.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerDeleteManyArgs>(args?: SelectSubset<T, CareerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Careers
     * const career = await prisma.career.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerUpdateManyArgs>(args: SelectSubset<T, CareerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers and returns the data updated in the database.
     * @param {CareerUpdateManyAndReturnArgs} args - Arguments to update many Careers.
     * @example
     * // Update many Careers
     * const career = await prisma.career.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Careers and only return the `id`
     * const careerWithIdOnly = await prisma.career.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CareerUpdateManyAndReturnArgs>(args: SelectSubset<T, CareerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Career.
     * @param {CareerUpsertArgs} args - Arguments to update or create a Career.
     * @example
     * // Update or create a Career
     * const career = await prisma.career.upsert({
     *   create: {
     *     // ... data to create a Career
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Career we want to update
     *   }
     * })
     */
    upsert<T extends CareerUpsertArgs>(args: SelectSubset<T, CareerUpsertArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerCountArgs} args - Arguments to filter Careers to count.
     * @example
     * // Count the number of Careers
     * const count = await prisma.career.count({
     *   where: {
     *     // ... the filter for the Careers we want to count
     *   }
     * })
    **/
    count<T extends CareerCountArgs>(
      args?: Subset<T, CareerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerAggregateArgs>(args: Subset<T, CareerAggregateArgs>): Prisma.PrismaPromise<GetCareerAggregateType<T>>

    /**
     * Group by Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerGroupByArgs['orderBy'] }
        : { orderBy?: CareerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Career model
   */
  readonly fields: CareerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Career.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Career$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Career$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    courses<T extends Career$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Career$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    periods<T extends Career$periodsArgs<ExtArgs> = {}>(args?: Subset<T, Career$periodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Career$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Career$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeSchedule<T extends Career$feeScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Career$feeScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Career model
   */
  interface CareerFieldRefs {
    readonly id: FieldRef<"Career", 'String'>
    readonly institutionId: FieldRef<"Career", 'String'>
    readonly name: FieldRef<"Career", 'String'>
    readonly code: FieldRef<"Career", 'String'>
    readonly level: FieldRef<"Career", 'LevelType'>
    readonly description: FieldRef<"Career", 'String'>
    readonly createdById: FieldRef<"Career", 'String'>
    readonly createdAt: FieldRef<"Career", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Career findUnique
   */
  export type CareerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career findUniqueOrThrow
   */
  export type CareerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career findFirst
   */
  export type CareerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Career findFirstOrThrow
   */
  export type CareerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Career findMany
   */
  export type CareerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Careers to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Career create
   */
  export type CareerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The data needed to create a Career.
     */
    data: XOR<CareerCreateInput, CareerUncheckedCreateInput>
  }

  /**
   * Career createMany
   */
  export type CareerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Careers.
     */
    data: CareerCreateManyInput | CareerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Career createManyAndReturn
   */
  export type CareerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * The data used to create many Careers.
     */
    data: CareerCreateManyInput | CareerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Career update
   */
  export type CareerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The data needed to update a Career.
     */
    data: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
    /**
     * Choose, which Career to update.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career updateMany
   */
  export type CareerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Careers.
     */
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     */
    where?: CareerWhereInput
    /**
     * Limit how many Careers to update.
     */
    limit?: number
  }

  /**
   * Career updateManyAndReturn
   */
  export type CareerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * The data used to update Careers.
     */
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     */
    where?: CareerWhereInput
    /**
     * Limit how many Careers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Career upsert
   */
  export type CareerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The filter to search for the Career to update in case it exists.
     */
    where: CareerWhereUniqueInput
    /**
     * In case the Career found by the `where` argument doesn't exist, create a new Career with this data.
     */
    create: XOR<CareerCreateInput, CareerUncheckedCreateInput>
    /**
     * In case the Career was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
  }

  /**
   * Career delete
   */
  export type CareerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter which Career to delete.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career deleteMany
   */
  export type CareerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Careers to delete
     */
    where?: CareerWhereInput
    /**
     * Limit how many Careers to delete.
     */
    limit?: number
  }

  /**
   * Career.createdBy
   */
  export type Career$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Career.courses
   */
  export type Career$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Career.periods
   */
  export type Career$periodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    cursor?: AcademicPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * Career.students
   */
  export type Career$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Career.feeSchedule
   */
  export type Career$feeScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    where?: FeeScheduleWhereInput
    orderBy?: FeeScheduleOrderByWithRelationInput | FeeScheduleOrderByWithRelationInput[]
    cursor?: FeeScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeScheduleScalarFieldEnum | FeeScheduleScalarFieldEnum[]
  }

  /**
   * Career without action
   */
  export type CareerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
  }


  /**
   * Model AcademicPeriod
   */

  export type AggregateAcademicPeriod = {
    _count: AcademicPeriodCountAggregateOutputType | null
    _min: AcademicPeriodMinAggregateOutputType | null
    _max: AcademicPeriodMaxAggregateOutputType | null
  }

  export type AcademicPeriodMinAggregateOutputType = {
    id: string | null
    careerId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AcademicPeriodMaxAggregateOutputType = {
    id: string | null
    careerId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AcademicPeriodCountAggregateOutputType = {
    id: number
    careerId: number
    name: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AcademicPeriodMinAggregateInputType = {
    id?: true
    careerId?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
  }

  export type AcademicPeriodMaxAggregateInputType = {
    id?: true
    careerId?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
  }

  export type AcademicPeriodCountAggregateInputType = {
    id?: true
    careerId?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AcademicPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPeriod to aggregate.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicPeriods
    **/
    _count?: true | AcademicPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicPeriodMaxAggregateInputType
  }

  export type GetAcademicPeriodAggregateType<T extends AcademicPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicPeriod[P]>
      : GetScalarType<T[P], AggregateAcademicPeriod[P]>
  }




  export type AcademicPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicPeriodWhereInput
    orderBy?: AcademicPeriodOrderByWithAggregationInput | AcademicPeriodOrderByWithAggregationInput[]
    by: AcademicPeriodScalarFieldEnum[] | AcademicPeriodScalarFieldEnum
    having?: AcademicPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicPeriodCountAggregateInputType | true
    _min?: AcademicPeriodMinAggregateInputType
    _max?: AcademicPeriodMaxAggregateInputType
  }

  export type AcademicPeriodGroupByOutputType = {
    id: string
    careerId: string
    name: string
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    _count: AcademicPeriodCountAggregateOutputType | null
    _min: AcademicPeriodMinAggregateOutputType | null
    _max: AcademicPeriodMaxAggregateOutputType | null
  }

  type GetAcademicPeriodGroupByPayload<T extends AcademicPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicPeriodGroupByOutputType[P]>
        }
      >
    >


  export type AcademicPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
    courses?: boolean | AcademicPeriod$coursesArgs<ExtArgs>
    enrollments?: boolean | AcademicPeriod$enrollmentsArgs<ExtArgs>
    _count?: boolean | AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectScalar = {
    id?: boolean
    careerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AcademicPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "careerId" | "name" | "startDate" | "endDate" | "isActive" | "createdAt", ExtArgs["result"]["academicPeriod"]>
  export type AcademicPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
    courses?: boolean | AcademicPeriod$coursesArgs<ExtArgs>
    enrollments?: boolean | AcademicPeriod$enrollmentsArgs<ExtArgs>
    _count?: boolean | AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }
  export type AcademicPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }

  export type $AcademicPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicPeriod"
    objects: {
      career: Prisma.$CareerPayload<ExtArgs>
      courses: Prisma.$CoursePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      careerId: string
      name: string
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["academicPeriod"]>
    composites: {}
  }

  type AcademicPeriodGetPayload<S extends boolean | null | undefined | AcademicPeriodDefaultArgs> = $Result.GetResult<Prisma.$AcademicPeriodPayload, S>

  type AcademicPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicPeriodCountAggregateInputType | true
    }

  export interface AcademicPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicPeriod'], meta: { name: 'AcademicPeriod' } }
    /**
     * Find zero or one AcademicPeriod that matches the filter.
     * @param {AcademicPeriodFindUniqueArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicPeriodFindUniqueArgs>(args: SelectSubset<T, AcademicPeriodFindUniqueArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicPeriodFindUniqueOrThrowArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindFirstArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicPeriodFindFirstArgs>(args?: SelectSubset<T, AcademicPeriodFindFirstArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindFirstOrThrowArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicPeriods
     * const academicPeriods = await prisma.academicPeriod.findMany()
     * 
     * // Get first 10 AcademicPeriods
     * const academicPeriods = await prisma.academicPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicPeriodFindManyArgs>(args?: SelectSubset<T, AcademicPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicPeriod.
     * @param {AcademicPeriodCreateArgs} args - Arguments to create a AcademicPeriod.
     * @example
     * // Create one AcademicPeriod
     * const AcademicPeriod = await prisma.academicPeriod.create({
     *   data: {
     *     // ... data to create a AcademicPeriod
     *   }
     * })
     * 
     */
    create<T extends AcademicPeriodCreateArgs>(args: SelectSubset<T, AcademicPeriodCreateArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicPeriods.
     * @param {AcademicPeriodCreateManyArgs} args - Arguments to create many AcademicPeriods.
     * @example
     * // Create many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicPeriodCreateManyArgs>(args?: SelectSubset<T, AcademicPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicPeriods and returns the data saved in the database.
     * @param {AcademicPeriodCreateManyAndReturnArgs} args - Arguments to create many AcademicPeriods.
     * @example
     * // Create many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicPeriods and only return the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicPeriod.
     * @param {AcademicPeriodDeleteArgs} args - Arguments to delete one AcademicPeriod.
     * @example
     * // Delete one AcademicPeriod
     * const AcademicPeriod = await prisma.academicPeriod.delete({
     *   where: {
     *     // ... filter to delete one AcademicPeriod
     *   }
     * })
     * 
     */
    delete<T extends AcademicPeriodDeleteArgs>(args: SelectSubset<T, AcademicPeriodDeleteArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicPeriod.
     * @param {AcademicPeriodUpdateArgs} args - Arguments to update one AcademicPeriod.
     * @example
     * // Update one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicPeriodUpdateArgs>(args: SelectSubset<T, AcademicPeriodUpdateArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicPeriods.
     * @param {AcademicPeriodDeleteManyArgs} args - Arguments to filter AcademicPeriods to delete.
     * @example
     * // Delete a few AcademicPeriods
     * const { count } = await prisma.academicPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicPeriodDeleteManyArgs>(args?: SelectSubset<T, AcademicPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicPeriodUpdateManyArgs>(args: SelectSubset<T, AcademicPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPeriods and returns the data updated in the database.
     * @param {AcademicPeriodUpdateManyAndReturnArgs} args - Arguments to update many AcademicPeriods.
     * @example
     * // Update many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicPeriods and only return the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicPeriod.
     * @param {AcademicPeriodUpsertArgs} args - Arguments to update or create a AcademicPeriod.
     * @example
     * // Update or create a AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.upsert({
     *   create: {
     *     // ... data to create a AcademicPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicPeriod we want to update
     *   }
     * })
     */
    upsert<T extends AcademicPeriodUpsertArgs>(args: SelectSubset<T, AcademicPeriodUpsertArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodCountArgs} args - Arguments to filter AcademicPeriods to count.
     * @example
     * // Count the number of AcademicPeriods
     * const count = await prisma.academicPeriod.count({
     *   where: {
     *     // ... the filter for the AcademicPeriods we want to count
     *   }
     * })
    **/
    count<T extends AcademicPeriodCountArgs>(
      args?: Subset<T, AcademicPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicPeriodAggregateArgs>(args: Subset<T, AcademicPeriodAggregateArgs>): Prisma.PrismaPromise<GetAcademicPeriodAggregateType<T>>

    /**
     * Group by AcademicPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicPeriodGroupByArgs['orderBy'] }
        : { orderBy?: AcademicPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicPeriod model
   */
  readonly fields: AcademicPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    career<T extends CareerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerDefaultArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courses<T extends AcademicPeriod$coursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends AcademicPeriod$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicPeriod model
   */
  interface AcademicPeriodFieldRefs {
    readonly id: FieldRef<"AcademicPeriod", 'String'>
    readonly careerId: FieldRef<"AcademicPeriod", 'String'>
    readonly name: FieldRef<"AcademicPeriod", 'String'>
    readonly startDate: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly endDate: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly isActive: FieldRef<"AcademicPeriod", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicPeriod findUnique
   */
  export type AcademicPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod findUniqueOrThrow
   */
  export type AcademicPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod findFirst
   */
  export type AcademicPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPeriods.
     */
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod findFirstOrThrow
   */
  export type AcademicPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPeriods.
     */
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod findMany
   */
  export type AcademicPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriods to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod create
   */
  export type AcademicPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicPeriod.
     */
    data: XOR<AcademicPeriodCreateInput, AcademicPeriodUncheckedCreateInput>
  }

  /**
   * AcademicPeriod createMany
   */
  export type AcademicPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicPeriods.
     */
    data: AcademicPeriodCreateManyInput | AcademicPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicPeriod createManyAndReturn
   */
  export type AcademicPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicPeriods.
     */
    data: AcademicPeriodCreateManyInput | AcademicPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicPeriod update
   */
  export type AcademicPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicPeriod.
     */
    data: XOR<AcademicPeriodUpdateInput, AcademicPeriodUncheckedUpdateInput>
    /**
     * Choose, which AcademicPeriod to update.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod updateMany
   */
  export type AcademicPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicPeriods.
     */
    data: XOR<AcademicPeriodUpdateManyMutationInput, AcademicPeriodUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPeriods to update
     */
    where?: AcademicPeriodWhereInput
    /**
     * Limit how many AcademicPeriods to update.
     */
    limit?: number
  }

  /**
   * AcademicPeriod updateManyAndReturn
   */
  export type AcademicPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * The data used to update AcademicPeriods.
     */
    data: XOR<AcademicPeriodUpdateManyMutationInput, AcademicPeriodUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPeriods to update
     */
    where?: AcademicPeriodWhereInput
    /**
     * Limit how many AcademicPeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicPeriod upsert
   */
  export type AcademicPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicPeriod to update in case it exists.
     */
    where: AcademicPeriodWhereUniqueInput
    /**
     * In case the AcademicPeriod found by the `where` argument doesn't exist, create a new AcademicPeriod with this data.
     */
    create: XOR<AcademicPeriodCreateInput, AcademicPeriodUncheckedCreateInput>
    /**
     * In case the AcademicPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicPeriodUpdateInput, AcademicPeriodUncheckedUpdateInput>
  }

  /**
   * AcademicPeriod delete
   */
  export type AcademicPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter which AcademicPeriod to delete.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod deleteMany
   */
  export type AcademicPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPeriods to delete
     */
    where?: AcademicPeriodWhereInput
    /**
     * Limit how many AcademicPeriods to delete.
     */
    limit?: number
  }

  /**
   * AcademicPeriod.courses
   */
  export type AcademicPeriod$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.enrollments
   */
  export type AcademicPeriod$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * AcademicPeriod without action
   */
  export type AcademicPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    credits: number | null
    durationSemesters: number | null
  }

  export type CourseSumAggregateOutputType = {
    credits: number | null
    durationSemesters: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    careerId: string | null
    academicPeriodId: string | null
    name: string | null
    code: string | null
    description: string | null
    credits: number | null
    durationSemesters: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    careerId: string | null
    academicPeriodId: string | null
    name: string | null
    code: string | null
    description: string | null
    credits: number | null
    durationSemesters: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    careerId: number
    academicPeriodId: number
    name: number
    code: number
    description: number
    credits: number
    durationSemesters: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    credits?: true
    durationSemesters?: true
  }

  export type CourseSumAggregateInputType = {
    credits?: true
    durationSemesters?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    careerId?: true
    academicPeriodId?: true
    name?: true
    code?: true
    description?: true
    credits?: true
    durationSemesters?: true
    createdById?: true
    createdAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    careerId?: true
    academicPeriodId?: true
    name?: true
    code?: true
    description?: true
    credits?: true
    durationSemesters?: true
    createdById?: true
    createdAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    careerId?: true
    academicPeriodId?: true
    name?: true
    code?: true
    description?: true
    credits?: true
    durationSemesters?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    careerId: string
    academicPeriodId: string | null
    name: string
    code: string | null
    description: string | null
    credits: number | null
    durationSemesters: number | null
    createdById: string | null
    createdAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerId?: boolean
    academicPeriodId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    credits?: boolean
    durationSemesters?: boolean
    createdById?: boolean
    createdAt?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Course$academicPeriodArgs<ExtArgs>
    createdBy?: boolean | Course$createdByArgs<ExtArgs>
    subjects?: boolean | Course$subjectsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    certificate?: boolean | Course$certificateArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerId?: boolean
    academicPeriodId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    credits?: boolean
    durationSemesters?: boolean
    createdById?: boolean
    createdAt?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Course$academicPeriodArgs<ExtArgs>
    createdBy?: boolean | Course$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    careerId?: boolean
    academicPeriodId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    credits?: boolean
    durationSemesters?: boolean
    createdById?: boolean
    createdAt?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Course$academicPeriodArgs<ExtArgs>
    createdBy?: boolean | Course$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    careerId?: boolean
    academicPeriodId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    credits?: boolean
    durationSemesters?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "careerId" | "academicPeriodId" | "name" | "code" | "description" | "credits" | "durationSemesters" | "createdById" | "createdAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Course$academicPeriodArgs<ExtArgs>
    createdBy?: boolean | Course$createdByArgs<ExtArgs>
    subjects?: boolean | Course$subjectsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    certificate?: boolean | Course$certificateArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Course$academicPeriodArgs<ExtArgs>
    createdBy?: boolean | Course$createdByArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Course$academicPeriodArgs<ExtArgs>
    createdBy?: boolean | Course$createdByArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      career: Prisma.$CareerPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      certificate: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      careerId: string
      academicPeriodId: string | null
      name: string
      code: string | null
      description: string | null
      credits: number | null
      durationSemesters: number | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    career<T extends CareerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerDefaultArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends Course$academicPeriodArgs<ExtArgs> = {}>(args?: Subset<T, Course$academicPeriodArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Course$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Course$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Course$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Course$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificate<T extends Course$certificateArgs<ExtArgs> = {}>(args?: Subset<T, Course$certificateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly careerId: FieldRef<"Course", 'String'>
    readonly academicPeriodId: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly credits: FieldRef<"Course", 'Int'>
    readonly durationSemesters: FieldRef<"Course", 'Int'>
    readonly createdById: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.academicPeriod
   */
  export type Course$academicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
  }

  /**
   * Course.createdBy
   */
  export type Course$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Course.subjects
   */
  export type Course$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.certificate
   */
  export type Course$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    semester: number | null
    credits: number | null
  }

  export type SubjectSumAggregateOutputType = {
    semester: number | null
    credits: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    name: string | null
    code: string | null
    description: string | null
    semester: number | null
    credits: number | null
    createdAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    name: string | null
    code: string | null
    description: string | null
    semester: number | null
    credits: number | null
    createdAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    courseId: number
    name: number
    code: number
    description: number
    semester: number
    credits: number
    createdAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    semester?: true
    credits?: true
  }

  export type SubjectSumAggregateInputType = {
    semester?: true
    credits?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    code?: true
    description?: true
    semester?: true
    credits?: true
    createdAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    code?: true
    description?: true
    semester?: true
    credits?: true
    createdAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    code?: true
    description?: true
    semester?: true
    credits?: true
    createdAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    courseId: string
    name: string
    code: string | null
    description: string | null
    semester: number | null
    credits: number | null
    createdAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semester?: boolean
    credits?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    classrooms?: boolean | Subject$classroomsArgs<ExtArgs>
    studentSubjects?: boolean | Subject$studentSubjectsArgs<ExtArgs>
    disciplinaryRecord?: boolean | Subject$disciplinaryRecordArgs<ExtArgs>
    certificate?: boolean | Subject$certificateArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semester?: boolean
    credits?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semester?: boolean
    credits?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    courseId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semester?: boolean
    credits?: boolean
    createdAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "name" | "code" | "description" | "semester" | "credits" | "createdAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    classrooms?: boolean | Subject$classroomsArgs<ExtArgs>
    studentSubjects?: boolean | Subject$studentSubjectsArgs<ExtArgs>
    disciplinaryRecord?: boolean | Subject$disciplinaryRecordArgs<ExtArgs>
    certificate?: boolean | Subject$certificateArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      classrooms: Prisma.$VirtualClassroomPayload<ExtArgs>[]
      studentSubjects: Prisma.$StudentSubjectPayload<ExtArgs>[]
      disciplinaryRecord: Prisma.$DisciplinaryRecordPayload<ExtArgs>[]
      certificate: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      name: string
      code: string | null
      description: string | null
      semester: number | null
      credits: number | null
      createdAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classrooms<T extends Subject$classroomsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSubjects<T extends Subject$studentSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$studentSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disciplinaryRecord<T extends Subject$disciplinaryRecordArgs<ExtArgs> = {}>(args?: Subset<T, Subject$disciplinaryRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificate<T extends Subject$certificateArgs<ExtArgs> = {}>(args?: Subset<T, Subject$certificateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly courseId: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly semester: FieldRef<"Subject", 'Int'>
    readonly credits: FieldRef<"Subject", 'Int'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.classrooms
   */
  export type Subject$classroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    where?: VirtualClassroomWhereInput
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    cursor?: VirtualClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassroomScalarFieldEnum | VirtualClassroomScalarFieldEnum[]
  }

  /**
   * Subject.studentSubjects
   */
  export type Subject$studentSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    cursor?: StudentSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * Subject.disciplinaryRecord
   */
  export type Subject$disciplinaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    where?: DisciplinaryRecordWhereInput
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    cursor?: DisciplinaryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisciplinaryRecordScalarFieldEnum | DisciplinaryRecordScalarFieldEnum[]
  }

  /**
   * Subject.certificate
   */
  export type Subject$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model VirtualClassroom
   */

  export type AggregateVirtualClassroom = {
    _count: VirtualClassroomCountAggregateOutputType | null
    _min: VirtualClassroomMinAggregateOutputType | null
    _max: VirtualClassroomMaxAggregateOutputType | null
  }

  export type VirtualClassroomMinAggregateOutputType = {
    id: string | null
    subjectId: string | null
    code: string | null
    title: string | null
    teacherId: string | null
    aiEnabled: boolean | null
    createdAt: Date | null
    aiagentId: string | null
  }

  export type VirtualClassroomMaxAggregateOutputType = {
    id: string | null
    subjectId: string | null
    code: string | null
    title: string | null
    teacherId: string | null
    aiEnabled: boolean | null
    createdAt: Date | null
    aiagentId: string | null
  }

  export type VirtualClassroomCountAggregateOutputType = {
    id: number
    subjectId: number
    code: number
    title: number
    teacherId: number
    aiEnabled: number
    aiConfig: number
    createdAt: number
    aiagentId: number
    _all: number
  }


  export type VirtualClassroomMinAggregateInputType = {
    id?: true
    subjectId?: true
    code?: true
    title?: true
    teacherId?: true
    aiEnabled?: true
    createdAt?: true
    aiagentId?: true
  }

  export type VirtualClassroomMaxAggregateInputType = {
    id?: true
    subjectId?: true
    code?: true
    title?: true
    teacherId?: true
    aiEnabled?: true
    createdAt?: true
    aiagentId?: true
  }

  export type VirtualClassroomCountAggregateInputType = {
    id?: true
    subjectId?: true
    code?: true
    title?: true
    teacherId?: true
    aiEnabled?: true
    aiConfig?: true
    createdAt?: true
    aiagentId?: true
    _all?: true
  }

  export type VirtualClassroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualClassroom to aggregate.
     */
    where?: VirtualClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassrooms to fetch.
     */
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VirtualClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VirtualClassrooms
    **/
    _count?: true | VirtualClassroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VirtualClassroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VirtualClassroomMaxAggregateInputType
  }

  export type GetVirtualClassroomAggregateType<T extends VirtualClassroomAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtualClassroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualClassroom[P]>
      : GetScalarType<T[P], AggregateVirtualClassroom[P]>
  }




  export type VirtualClassroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassroomWhereInput
    orderBy?: VirtualClassroomOrderByWithAggregationInput | VirtualClassroomOrderByWithAggregationInput[]
    by: VirtualClassroomScalarFieldEnum[] | VirtualClassroomScalarFieldEnum
    having?: VirtualClassroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VirtualClassroomCountAggregateInputType | true
    _min?: VirtualClassroomMinAggregateInputType
    _max?: VirtualClassroomMaxAggregateInputType
  }

  export type VirtualClassroomGroupByOutputType = {
    id: string
    subjectId: string
    code: string | null
    title: string | null
    teacherId: string | null
    aiEnabled: boolean
    aiConfig: JsonValue | null
    createdAt: Date
    aiagentId: string | null
    _count: VirtualClassroomCountAggregateOutputType | null
    _min: VirtualClassroomMinAggregateOutputType | null
    _max: VirtualClassroomMaxAggregateOutputType | null
  }

  type GetVirtualClassroomGroupByPayload<T extends VirtualClassroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VirtualClassroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VirtualClassroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualClassroomGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualClassroomGroupByOutputType[P]>
        }
      >
    >


  export type VirtualClassroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    code?: boolean
    title?: boolean
    teacherId?: boolean
    aiEnabled?: boolean
    aiConfig?: boolean
    createdAt?: boolean
    aiagentId?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | VirtualClassroom$teacherArgs<ExtArgs>
    aiagent?: boolean | VirtualClassroom$aiagentArgs<ExtArgs>
    lessonPlans?: boolean | VirtualClassroom$lessonPlansArgs<ExtArgs>
    attendances?: boolean | VirtualClassroom$attendancesArgs<ExtArgs>
    aiUsages?: boolean | VirtualClassroom$aiUsagesArgs<ExtArgs>
    studentSubject?: boolean | VirtualClassroom$studentSubjectArgs<ExtArgs>
    _count?: boolean | VirtualClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClassroom"]>

  export type VirtualClassroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    code?: boolean
    title?: boolean
    teacherId?: boolean
    aiEnabled?: boolean
    aiConfig?: boolean
    createdAt?: boolean
    aiagentId?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | VirtualClassroom$teacherArgs<ExtArgs>
    aiagent?: boolean | VirtualClassroom$aiagentArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClassroom"]>

  export type VirtualClassroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    code?: boolean
    title?: boolean
    teacherId?: boolean
    aiEnabled?: boolean
    aiConfig?: boolean
    createdAt?: boolean
    aiagentId?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | VirtualClassroom$teacherArgs<ExtArgs>
    aiagent?: boolean | VirtualClassroom$aiagentArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClassroom"]>

  export type VirtualClassroomSelectScalar = {
    id?: boolean
    subjectId?: boolean
    code?: boolean
    title?: boolean
    teacherId?: boolean
    aiEnabled?: boolean
    aiConfig?: boolean
    createdAt?: boolean
    aiagentId?: boolean
  }

  export type VirtualClassroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subjectId" | "code" | "title" | "teacherId" | "aiEnabled" | "aiConfig" | "createdAt" | "aiagentId", ExtArgs["result"]["virtualClassroom"]>
  export type VirtualClassroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | VirtualClassroom$teacherArgs<ExtArgs>
    aiagent?: boolean | VirtualClassroom$aiagentArgs<ExtArgs>
    lessonPlans?: boolean | VirtualClassroom$lessonPlansArgs<ExtArgs>
    attendances?: boolean | VirtualClassroom$attendancesArgs<ExtArgs>
    aiUsages?: boolean | VirtualClassroom$aiUsagesArgs<ExtArgs>
    studentSubject?: boolean | VirtualClassroom$studentSubjectArgs<ExtArgs>
    _count?: boolean | VirtualClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VirtualClassroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | VirtualClassroom$teacherArgs<ExtArgs>
    aiagent?: boolean | VirtualClassroom$aiagentArgs<ExtArgs>
  }
  export type VirtualClassroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | VirtualClassroom$teacherArgs<ExtArgs>
    aiagent?: boolean | VirtualClassroom$aiagentArgs<ExtArgs>
  }

  export type $VirtualClassroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VirtualClassroom"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
      teacher: Prisma.$UserPayload<ExtArgs> | null
      aiagent: Prisma.$AIAgentPayload<ExtArgs> | null
      lessonPlans: Prisma.$LessonPlanPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      aiUsages: Prisma.$AIUsageLogPayload<ExtArgs>[]
      studentSubject: Prisma.$StudentSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subjectId: string
      code: string | null
      title: string | null
      teacherId: string | null
      aiEnabled: boolean
      aiConfig: Prisma.JsonValue | null
      createdAt: Date
      aiagentId: string | null
    }, ExtArgs["result"]["virtualClassroom"]>
    composites: {}
  }

  type VirtualClassroomGetPayload<S extends boolean | null | undefined | VirtualClassroomDefaultArgs> = $Result.GetResult<Prisma.$VirtualClassroomPayload, S>

  type VirtualClassroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VirtualClassroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VirtualClassroomCountAggregateInputType | true
    }

  export interface VirtualClassroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VirtualClassroom'], meta: { name: 'VirtualClassroom' } }
    /**
     * Find zero or one VirtualClassroom that matches the filter.
     * @param {VirtualClassroomFindUniqueArgs} args - Arguments to find a VirtualClassroom
     * @example
     * // Get one VirtualClassroom
     * const virtualClassroom = await prisma.virtualClassroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualClassroomFindUniqueArgs>(args: SelectSubset<T, VirtualClassroomFindUniqueArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VirtualClassroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VirtualClassroomFindUniqueOrThrowArgs} args - Arguments to find a VirtualClassroom
     * @example
     * // Get one VirtualClassroom
     * const virtualClassroom = await prisma.virtualClassroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualClassroomFindUniqueOrThrowArgs>(args: SelectSubset<T, VirtualClassroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VirtualClassroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomFindFirstArgs} args - Arguments to find a VirtualClassroom
     * @example
     * // Get one VirtualClassroom
     * const virtualClassroom = await prisma.virtualClassroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualClassroomFindFirstArgs>(args?: SelectSubset<T, VirtualClassroomFindFirstArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VirtualClassroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomFindFirstOrThrowArgs} args - Arguments to find a VirtualClassroom
     * @example
     * // Get one VirtualClassroom
     * const virtualClassroom = await prisma.virtualClassroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualClassroomFindFirstOrThrowArgs>(args?: SelectSubset<T, VirtualClassroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VirtualClassrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualClassrooms
     * const virtualClassrooms = await prisma.virtualClassroom.findMany()
     * 
     * // Get first 10 VirtualClassrooms
     * const virtualClassrooms = await prisma.virtualClassroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtualClassroomWithIdOnly = await prisma.virtualClassroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VirtualClassroomFindManyArgs>(args?: SelectSubset<T, VirtualClassroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VirtualClassroom.
     * @param {VirtualClassroomCreateArgs} args - Arguments to create a VirtualClassroom.
     * @example
     * // Create one VirtualClassroom
     * const VirtualClassroom = await prisma.virtualClassroom.create({
     *   data: {
     *     // ... data to create a VirtualClassroom
     *   }
     * })
     * 
     */
    create<T extends VirtualClassroomCreateArgs>(args: SelectSubset<T, VirtualClassroomCreateArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VirtualClassrooms.
     * @param {VirtualClassroomCreateManyArgs} args - Arguments to create many VirtualClassrooms.
     * @example
     * // Create many VirtualClassrooms
     * const virtualClassroom = await prisma.virtualClassroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VirtualClassroomCreateManyArgs>(args?: SelectSubset<T, VirtualClassroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VirtualClassrooms and returns the data saved in the database.
     * @param {VirtualClassroomCreateManyAndReturnArgs} args - Arguments to create many VirtualClassrooms.
     * @example
     * // Create many VirtualClassrooms
     * const virtualClassroom = await prisma.virtualClassroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VirtualClassrooms and only return the `id`
     * const virtualClassroomWithIdOnly = await prisma.virtualClassroom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VirtualClassroomCreateManyAndReturnArgs>(args?: SelectSubset<T, VirtualClassroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VirtualClassroom.
     * @param {VirtualClassroomDeleteArgs} args - Arguments to delete one VirtualClassroom.
     * @example
     * // Delete one VirtualClassroom
     * const VirtualClassroom = await prisma.virtualClassroom.delete({
     *   where: {
     *     // ... filter to delete one VirtualClassroom
     *   }
     * })
     * 
     */
    delete<T extends VirtualClassroomDeleteArgs>(args: SelectSubset<T, VirtualClassroomDeleteArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VirtualClassroom.
     * @param {VirtualClassroomUpdateArgs} args - Arguments to update one VirtualClassroom.
     * @example
     * // Update one VirtualClassroom
     * const virtualClassroom = await prisma.virtualClassroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VirtualClassroomUpdateArgs>(args: SelectSubset<T, VirtualClassroomUpdateArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VirtualClassrooms.
     * @param {VirtualClassroomDeleteManyArgs} args - Arguments to filter VirtualClassrooms to delete.
     * @example
     * // Delete a few VirtualClassrooms
     * const { count } = await prisma.virtualClassroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VirtualClassroomDeleteManyArgs>(args?: SelectSubset<T, VirtualClassroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualClassrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualClassrooms
     * const virtualClassroom = await prisma.virtualClassroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VirtualClassroomUpdateManyArgs>(args: SelectSubset<T, VirtualClassroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualClassrooms and returns the data updated in the database.
     * @param {VirtualClassroomUpdateManyAndReturnArgs} args - Arguments to update many VirtualClassrooms.
     * @example
     * // Update many VirtualClassrooms
     * const virtualClassroom = await prisma.virtualClassroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VirtualClassrooms and only return the `id`
     * const virtualClassroomWithIdOnly = await prisma.virtualClassroom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VirtualClassroomUpdateManyAndReturnArgs>(args: SelectSubset<T, VirtualClassroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VirtualClassroom.
     * @param {VirtualClassroomUpsertArgs} args - Arguments to update or create a VirtualClassroom.
     * @example
     * // Update or create a VirtualClassroom
     * const virtualClassroom = await prisma.virtualClassroom.upsert({
     *   create: {
     *     // ... data to create a VirtualClassroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualClassroom we want to update
     *   }
     * })
     */
    upsert<T extends VirtualClassroomUpsertArgs>(args: SelectSubset<T, VirtualClassroomUpsertArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VirtualClassrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomCountArgs} args - Arguments to filter VirtualClassrooms to count.
     * @example
     * // Count the number of VirtualClassrooms
     * const count = await prisma.virtualClassroom.count({
     *   where: {
     *     // ... the filter for the VirtualClassrooms we want to count
     *   }
     * })
    **/
    count<T extends VirtualClassroomCountArgs>(
      args?: Subset<T, VirtualClassroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VirtualClassroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VirtualClassroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VirtualClassroomAggregateArgs>(args: Subset<T, VirtualClassroomAggregateArgs>): Prisma.PrismaPromise<GetVirtualClassroomAggregateType<T>>

    /**
     * Group by VirtualClassroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VirtualClassroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualClassroomGroupByArgs['orderBy'] }
        : { orderBy?: VirtualClassroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VirtualClassroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtualClassroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VirtualClassroom model
   */
  readonly fields: VirtualClassroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualClassroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualClassroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends VirtualClassroom$teacherArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroom$teacherArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aiagent<T extends VirtualClassroom$aiagentArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroom$aiagentArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lessonPlans<T extends VirtualClassroom$lessonPlansArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroom$lessonPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends VirtualClassroom$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroom$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiUsages<T extends VirtualClassroom$aiUsagesArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroom$aiUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSubject<T extends VirtualClassroom$studentSubjectArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroom$studentSubjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VirtualClassroom model
   */
  interface VirtualClassroomFieldRefs {
    readonly id: FieldRef<"VirtualClassroom", 'String'>
    readonly subjectId: FieldRef<"VirtualClassroom", 'String'>
    readonly code: FieldRef<"VirtualClassroom", 'String'>
    readonly title: FieldRef<"VirtualClassroom", 'String'>
    readonly teacherId: FieldRef<"VirtualClassroom", 'String'>
    readonly aiEnabled: FieldRef<"VirtualClassroom", 'Boolean'>
    readonly aiConfig: FieldRef<"VirtualClassroom", 'Json'>
    readonly createdAt: FieldRef<"VirtualClassroom", 'DateTime'>
    readonly aiagentId: FieldRef<"VirtualClassroom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VirtualClassroom findUnique
   */
  export type VirtualClassroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassroom to fetch.
     */
    where: VirtualClassroomWhereUniqueInput
  }

  /**
   * VirtualClassroom findUniqueOrThrow
   */
  export type VirtualClassroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassroom to fetch.
     */
    where: VirtualClassroomWhereUniqueInput
  }

  /**
   * VirtualClassroom findFirst
   */
  export type VirtualClassroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassroom to fetch.
     */
    where?: VirtualClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassrooms to fetch.
     */
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualClassrooms.
     */
    cursor?: VirtualClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualClassrooms.
     */
    distinct?: VirtualClassroomScalarFieldEnum | VirtualClassroomScalarFieldEnum[]
  }

  /**
   * VirtualClassroom findFirstOrThrow
   */
  export type VirtualClassroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassroom to fetch.
     */
    where?: VirtualClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassrooms to fetch.
     */
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualClassrooms.
     */
    cursor?: VirtualClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualClassrooms.
     */
    distinct?: VirtualClassroomScalarFieldEnum | VirtualClassroomScalarFieldEnum[]
  }

  /**
   * VirtualClassroom findMany
   */
  export type VirtualClassroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassrooms to fetch.
     */
    where?: VirtualClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassrooms to fetch.
     */
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VirtualClassrooms.
     */
    cursor?: VirtualClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassrooms.
     */
    skip?: number
    distinct?: VirtualClassroomScalarFieldEnum | VirtualClassroomScalarFieldEnum[]
  }

  /**
   * VirtualClassroom create
   */
  export type VirtualClassroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * The data needed to create a VirtualClassroom.
     */
    data: XOR<VirtualClassroomCreateInput, VirtualClassroomUncheckedCreateInput>
  }

  /**
   * VirtualClassroom createMany
   */
  export type VirtualClassroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VirtualClassrooms.
     */
    data: VirtualClassroomCreateManyInput | VirtualClassroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualClassroom createManyAndReturn
   */
  export type VirtualClassroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * The data used to create many VirtualClassrooms.
     */
    data: VirtualClassroomCreateManyInput | VirtualClassroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VirtualClassroom update
   */
  export type VirtualClassroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * The data needed to update a VirtualClassroom.
     */
    data: XOR<VirtualClassroomUpdateInput, VirtualClassroomUncheckedUpdateInput>
    /**
     * Choose, which VirtualClassroom to update.
     */
    where: VirtualClassroomWhereUniqueInput
  }

  /**
   * VirtualClassroom updateMany
   */
  export type VirtualClassroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VirtualClassrooms.
     */
    data: XOR<VirtualClassroomUpdateManyMutationInput, VirtualClassroomUncheckedUpdateManyInput>
    /**
     * Filter which VirtualClassrooms to update
     */
    where?: VirtualClassroomWhereInput
    /**
     * Limit how many VirtualClassrooms to update.
     */
    limit?: number
  }

  /**
   * VirtualClassroom updateManyAndReturn
   */
  export type VirtualClassroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * The data used to update VirtualClassrooms.
     */
    data: XOR<VirtualClassroomUpdateManyMutationInput, VirtualClassroomUncheckedUpdateManyInput>
    /**
     * Filter which VirtualClassrooms to update
     */
    where?: VirtualClassroomWhereInput
    /**
     * Limit how many VirtualClassrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VirtualClassroom upsert
   */
  export type VirtualClassroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * The filter to search for the VirtualClassroom to update in case it exists.
     */
    where: VirtualClassroomWhereUniqueInput
    /**
     * In case the VirtualClassroom found by the `where` argument doesn't exist, create a new VirtualClassroom with this data.
     */
    create: XOR<VirtualClassroomCreateInput, VirtualClassroomUncheckedCreateInput>
    /**
     * In case the VirtualClassroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VirtualClassroomUpdateInput, VirtualClassroomUncheckedUpdateInput>
  }

  /**
   * VirtualClassroom delete
   */
  export type VirtualClassroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    /**
     * Filter which VirtualClassroom to delete.
     */
    where: VirtualClassroomWhereUniqueInput
  }

  /**
   * VirtualClassroom deleteMany
   */
  export type VirtualClassroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualClassrooms to delete
     */
    where?: VirtualClassroomWhereInput
    /**
     * Limit how many VirtualClassrooms to delete.
     */
    limit?: number
  }

  /**
   * VirtualClassroom.teacher
   */
  export type VirtualClassroom$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * VirtualClassroom.aiagent
   */
  export type VirtualClassroom$aiagentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    where?: AIAgentWhereInput
  }

  /**
   * VirtualClassroom.lessonPlans
   */
  export type VirtualClassroom$lessonPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    where?: LessonPlanWhereInput
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    cursor?: LessonPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * VirtualClassroom.attendances
   */
  export type VirtualClassroom$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * VirtualClassroom.aiUsages
   */
  export type VirtualClassroom$aiUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    cursor?: AIUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * VirtualClassroom.studentSubject
   */
  export type VirtualClassroom$studentSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    cursor?: StudentSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * VirtualClassroom without action
   */
  export type VirtualClassroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
  }


  /**
   * Model LessonPlan
   */

  export type AggregateLessonPlan = {
    _count: LessonPlanCountAggregateOutputType | null
    _min: LessonPlanMinAggregateOutputType | null
    _max: LessonPlanMaxAggregateOutputType | null
  }

  export type LessonPlanMinAggregateOutputType = {
    id: string | null
    classroomId: string | null
    date: Date | null
    topic: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type LessonPlanMaxAggregateOutputType = {
    id: string | null
    classroomId: string | null
    date: Date | null
    topic: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type LessonPlanCountAggregateOutputType = {
    id: number
    classroomId: number
    date: number
    topic: number
    aiSuggestions: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type LessonPlanMinAggregateInputType = {
    id?: true
    classroomId?: true
    date?: true
    topic?: true
    createdById?: true
    createdAt?: true
  }

  export type LessonPlanMaxAggregateInputType = {
    id?: true
    classroomId?: true
    date?: true
    topic?: true
    createdById?: true
    createdAt?: true
  }

  export type LessonPlanCountAggregateInputType = {
    id?: true
    classroomId?: true
    date?: true
    topic?: true
    aiSuggestions?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type LessonPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonPlan to aggregate.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonPlans
    **/
    _count?: true | LessonPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonPlanMaxAggregateInputType
  }

  export type GetLessonPlanAggregateType<T extends LessonPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonPlan[P]>
      : GetScalarType<T[P], AggregateLessonPlan[P]>
  }




  export type LessonPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonPlanWhereInput
    orderBy?: LessonPlanOrderByWithAggregationInput | LessonPlanOrderByWithAggregationInput[]
    by: LessonPlanScalarFieldEnum[] | LessonPlanScalarFieldEnum
    having?: LessonPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonPlanCountAggregateInputType | true
    _min?: LessonPlanMinAggregateInputType
    _max?: LessonPlanMaxAggregateInputType
  }

  export type LessonPlanGroupByOutputType = {
    id: string
    classroomId: string
    date: Date
    topic: string
    aiSuggestions: JsonValue | null
    createdById: string | null
    createdAt: Date
    _count: LessonPlanCountAggregateOutputType | null
    _min: LessonPlanMinAggregateOutputType | null
    _max: LessonPlanMaxAggregateOutputType | null
  }

  type GetLessonPlanGroupByPayload<T extends LessonPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonPlanGroupByOutputType[P]>
            : GetScalarType<T[P], LessonPlanGroupByOutputType[P]>
        }
      >
    >


  export type LessonPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    date?: boolean
    topic?: boolean
    aiSuggestions?: boolean
    createdById?: boolean
    createdAt?: boolean
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    createdBy?: boolean | LessonPlan$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lessonPlan"]>

  export type LessonPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    date?: boolean
    topic?: boolean
    aiSuggestions?: boolean
    createdById?: boolean
    createdAt?: boolean
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    createdBy?: boolean | LessonPlan$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lessonPlan"]>

  export type LessonPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    date?: boolean
    topic?: boolean
    aiSuggestions?: boolean
    createdById?: boolean
    createdAt?: boolean
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    createdBy?: boolean | LessonPlan$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lessonPlan"]>

  export type LessonPlanSelectScalar = {
    id?: boolean
    classroomId?: boolean
    date?: boolean
    topic?: boolean
    aiSuggestions?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type LessonPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classroomId" | "date" | "topic" | "aiSuggestions" | "createdById" | "createdAt", ExtArgs["result"]["lessonPlan"]>
  export type LessonPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    createdBy?: boolean | LessonPlan$createdByArgs<ExtArgs>
  }
  export type LessonPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    createdBy?: boolean | LessonPlan$createdByArgs<ExtArgs>
  }
  export type LessonPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    createdBy?: boolean | LessonPlan$createdByArgs<ExtArgs>
  }

  export type $LessonPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonPlan"
    objects: {
      classroom: Prisma.$VirtualClassroomPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classroomId: string
      date: Date
      topic: string
      aiSuggestions: Prisma.JsonValue | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["lessonPlan"]>
    composites: {}
  }

  type LessonPlanGetPayload<S extends boolean | null | undefined | LessonPlanDefaultArgs> = $Result.GetResult<Prisma.$LessonPlanPayload, S>

  type LessonPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonPlanCountAggregateInputType | true
    }

  export interface LessonPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonPlan'], meta: { name: 'LessonPlan' } }
    /**
     * Find zero or one LessonPlan that matches the filter.
     * @param {LessonPlanFindUniqueArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonPlanFindUniqueArgs>(args: SelectSubset<T, LessonPlanFindUniqueArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonPlanFindUniqueOrThrowArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanFindFirstArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonPlanFindFirstArgs>(args?: SelectSubset<T, LessonPlanFindFirstArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanFindFirstOrThrowArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonPlans
     * const lessonPlans = await prisma.lessonPlan.findMany()
     * 
     * // Get first 10 LessonPlans
     * const lessonPlans = await prisma.lessonPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonPlanWithIdOnly = await prisma.lessonPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonPlanFindManyArgs>(args?: SelectSubset<T, LessonPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonPlan.
     * @param {LessonPlanCreateArgs} args - Arguments to create a LessonPlan.
     * @example
     * // Create one LessonPlan
     * const LessonPlan = await prisma.lessonPlan.create({
     *   data: {
     *     // ... data to create a LessonPlan
     *   }
     * })
     * 
     */
    create<T extends LessonPlanCreateArgs>(args: SelectSubset<T, LessonPlanCreateArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonPlans.
     * @param {LessonPlanCreateManyArgs} args - Arguments to create many LessonPlans.
     * @example
     * // Create many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonPlanCreateManyArgs>(args?: SelectSubset<T, LessonPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonPlans and returns the data saved in the database.
     * @param {LessonPlanCreateManyAndReturnArgs} args - Arguments to create many LessonPlans.
     * @example
     * // Create many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonPlans and only return the `id`
     * const lessonPlanWithIdOnly = await prisma.lessonPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonPlan.
     * @param {LessonPlanDeleteArgs} args - Arguments to delete one LessonPlan.
     * @example
     * // Delete one LessonPlan
     * const LessonPlan = await prisma.lessonPlan.delete({
     *   where: {
     *     // ... filter to delete one LessonPlan
     *   }
     * })
     * 
     */
    delete<T extends LessonPlanDeleteArgs>(args: SelectSubset<T, LessonPlanDeleteArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonPlan.
     * @param {LessonPlanUpdateArgs} args - Arguments to update one LessonPlan.
     * @example
     * // Update one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonPlanUpdateArgs>(args: SelectSubset<T, LessonPlanUpdateArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonPlans.
     * @param {LessonPlanDeleteManyArgs} args - Arguments to filter LessonPlans to delete.
     * @example
     * // Delete a few LessonPlans
     * const { count } = await prisma.lessonPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonPlanDeleteManyArgs>(args?: SelectSubset<T, LessonPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonPlanUpdateManyArgs>(args: SelectSubset<T, LessonPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonPlans and returns the data updated in the database.
     * @param {LessonPlanUpdateManyAndReturnArgs} args - Arguments to update many LessonPlans.
     * @example
     * // Update many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonPlans and only return the `id`
     * const lessonPlanWithIdOnly = await prisma.lessonPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonPlan.
     * @param {LessonPlanUpsertArgs} args - Arguments to update or create a LessonPlan.
     * @example
     * // Update or create a LessonPlan
     * const lessonPlan = await prisma.lessonPlan.upsert({
     *   create: {
     *     // ... data to create a LessonPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonPlan we want to update
     *   }
     * })
     */
    upsert<T extends LessonPlanUpsertArgs>(args: SelectSubset<T, LessonPlanUpsertArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanCountArgs} args - Arguments to filter LessonPlans to count.
     * @example
     * // Count the number of LessonPlans
     * const count = await prisma.lessonPlan.count({
     *   where: {
     *     // ... the filter for the LessonPlans we want to count
     *   }
     * })
    **/
    count<T extends LessonPlanCountArgs>(
      args?: Subset<T, LessonPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonPlanAggregateArgs>(args: Subset<T, LessonPlanAggregateArgs>): Prisma.PrismaPromise<GetLessonPlanAggregateType<T>>

    /**
     * Group by LessonPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonPlanGroupByArgs['orderBy'] }
        : { orderBy?: LessonPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonPlan model
   */
  readonly fields: LessonPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends VirtualClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroomDefaultArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends LessonPlan$createdByArgs<ExtArgs> = {}>(args?: Subset<T, LessonPlan$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonPlan model
   */
  interface LessonPlanFieldRefs {
    readonly id: FieldRef<"LessonPlan", 'String'>
    readonly classroomId: FieldRef<"LessonPlan", 'String'>
    readonly date: FieldRef<"LessonPlan", 'DateTime'>
    readonly topic: FieldRef<"LessonPlan", 'String'>
    readonly aiSuggestions: FieldRef<"LessonPlan", 'Json'>
    readonly createdById: FieldRef<"LessonPlan", 'String'>
    readonly createdAt: FieldRef<"LessonPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonPlan findUnique
   */
  export type LessonPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan findUniqueOrThrow
   */
  export type LessonPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan findFirst
   */
  export type LessonPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonPlans.
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonPlans.
     */
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * LessonPlan findFirstOrThrow
   */
  export type LessonPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonPlans.
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonPlans.
     */
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * LessonPlan findMany
   */
  export type LessonPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlans to fetch.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonPlans.
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * LessonPlan create
   */
  export type LessonPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonPlan.
     */
    data: XOR<LessonPlanCreateInput, LessonPlanUncheckedCreateInput>
  }

  /**
   * LessonPlan createMany
   */
  export type LessonPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonPlans.
     */
    data: LessonPlanCreateManyInput | LessonPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonPlan createManyAndReturn
   */
  export type LessonPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * The data used to create many LessonPlans.
     */
    data: LessonPlanCreateManyInput | LessonPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonPlan update
   */
  export type LessonPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonPlan.
     */
    data: XOR<LessonPlanUpdateInput, LessonPlanUncheckedUpdateInput>
    /**
     * Choose, which LessonPlan to update.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan updateMany
   */
  export type LessonPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonPlans.
     */
    data: XOR<LessonPlanUpdateManyMutationInput, LessonPlanUncheckedUpdateManyInput>
    /**
     * Filter which LessonPlans to update
     */
    where?: LessonPlanWhereInput
    /**
     * Limit how many LessonPlans to update.
     */
    limit?: number
  }

  /**
   * LessonPlan updateManyAndReturn
   */
  export type LessonPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * The data used to update LessonPlans.
     */
    data: XOR<LessonPlanUpdateManyMutationInput, LessonPlanUncheckedUpdateManyInput>
    /**
     * Filter which LessonPlans to update
     */
    where?: LessonPlanWhereInput
    /**
     * Limit how many LessonPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonPlan upsert
   */
  export type LessonPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonPlan to update in case it exists.
     */
    where: LessonPlanWhereUniqueInput
    /**
     * In case the LessonPlan found by the `where` argument doesn't exist, create a new LessonPlan with this data.
     */
    create: XOR<LessonPlanCreateInput, LessonPlanUncheckedCreateInput>
    /**
     * In case the LessonPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonPlanUpdateInput, LessonPlanUncheckedUpdateInput>
  }

  /**
   * LessonPlan delete
   */
  export type LessonPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter which LessonPlan to delete.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan deleteMany
   */
  export type LessonPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonPlans to delete
     */
    where?: LessonPlanWhereInput
    /**
     * Limit how many LessonPlans to delete.
     */
    limit?: number
  }

  /**
   * LessonPlan.createdBy
   */
  export type LessonPlan$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LessonPlan without action
   */
  export type LessonPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonPlan
     */
    omit?: LessonPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    studentNumber: string | null
    institutionId: string | null
    careerId: string | null
    enrollmentDate: Date | null
    status: $Enums.StudentStatus | null
    createdAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    studentNumber: string | null
    institutionId: string | null
    careerId: string | null
    enrollmentDate: Date | null
    status: $Enums.StudentStatus | null
    createdAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    studentNumber: number
    institutionId: number
    careerId: number
    enrollmentDate: number
    status: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    studentNumber?: true
    institutionId?: true
    careerId?: true
    enrollmentDate?: true
    status?: true
    createdAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    studentNumber?: true
    institutionId?: true
    careerId?: true
    enrollmentDate?: true
    status?: true
    createdAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    studentNumber?: true
    institutionId?: true
    careerId?: true
    enrollmentDate?: true
    status?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    studentNumber: string | null
    institutionId: string
    careerId: string | null
    enrollmentDate: Date
    status: $Enums.StudentStatus
    metadata: JsonValue | null
    createdAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentNumber?: boolean
    institutionId?: boolean
    careerId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | Student$careerArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    subjects?: boolean | Student$subjectsArgs<ExtArgs>
    attendances?: boolean | Student$attendancesArgs<ExtArgs>
    tutorAssignments?: boolean | Student$tutorAssignmentsArgs<ExtArgs>
    payments?: boolean | Student$paymentsArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    disciplinaryRecord?: boolean | Student$disciplinaryRecordArgs<ExtArgs>
    paymentPlan?: boolean | Student$paymentPlanArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentNumber?: boolean
    institutionId?: boolean
    careerId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | Student$careerArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentNumber?: boolean
    institutionId?: boolean
    careerId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | Student$careerArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    studentNumber?: boolean
    institutionId?: boolean
    careerId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentNumber" | "institutionId" | "careerId" | "enrollmentDate" | "status" | "metadata" | "createdAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | Student$careerArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    subjects?: boolean | Student$subjectsArgs<ExtArgs>
    attendances?: boolean | Student$attendancesArgs<ExtArgs>
    tutorAssignments?: boolean | Student$tutorAssignmentsArgs<ExtArgs>
    payments?: boolean | Student$paymentsArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    disciplinaryRecord?: boolean | Student$disciplinaryRecordArgs<ExtArgs>
    paymentPlan?: boolean | Student$paymentPlanArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | Student$careerArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | Student$careerArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
      career: Prisma.$CareerPayload<ExtArgs> | null
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      subjects: Prisma.$StudentSubjectPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      tutorAssignments: Prisma.$TutorStudentPayload<ExtArgs>[]
      payments: Prisma.$StudentPaymentPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      disciplinaryRecord: Prisma.$DisciplinaryRecordPayload<ExtArgs>[]
      paymentPlan: Prisma.$PaymentPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      studentNumber: string | null
      institutionId: string
      careerId: string | null
      enrollmentDate: Date
      status: $Enums.StudentStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    career<T extends Student$careerArgs<ExtArgs> = {}>(args?: Subset<T, Student$careerArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Student$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Student$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Student$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutorAssignments<T extends Student$tutorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$tutorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Student$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends Student$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Student$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disciplinaryRecord<T extends Student$disciplinaryRecordArgs<ExtArgs> = {}>(args?: Subset<T, Student$disciplinaryRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentPlan<T extends Student$paymentPlanArgs<ExtArgs> = {}>(args?: Subset<T, Student$paymentPlanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly studentNumber: FieldRef<"Student", 'String'>
    readonly institutionId: FieldRef<"Student", 'String'>
    readonly careerId: FieldRef<"Student", 'String'>
    readonly enrollmentDate: FieldRef<"Student", 'DateTime'>
    readonly status: FieldRef<"Student", 'StudentStatus'>
    readonly metadata: FieldRef<"Student", 'Json'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.career
   */
  export type Student$careerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    where?: CareerWhereInput
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Student.subjects
   */
  export type Student$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    cursor?: StudentSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * Student.attendances
   */
  export type Student$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Student.tutorAssignments
   */
  export type Student$tutorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    where?: TutorStudentWhereInput
    orderBy?: TutorStudentOrderByWithRelationInput | TutorStudentOrderByWithRelationInput[]
    cursor?: TutorStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorStudentScalarFieldEnum | TutorStudentScalarFieldEnum[]
  }

  /**
   * Student.payments
   */
  export type Student$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    cursor?: StudentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * Student.certificates
   */
  export type Student$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Student.disciplinaryRecord
   */
  export type Student$disciplinaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    where?: DisciplinaryRecordWhereInput
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    cursor?: DisciplinaryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisciplinaryRecordScalarFieldEnum | DisciplinaryRecordScalarFieldEnum[]
  }

  /**
   * Student.paymentPlan
   */
  export type Student$paymentPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    where?: PaymentPlanWhereInput
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    cursor?: PaymentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseId: string | null
    academicPeriodId: string | null
    enrolledAt: Date | null
    status: string | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseId: string | null
    academicPeriodId: string | null
    enrolledAt: Date | null
    status: string | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    academicPeriodId: number
    enrolledAt: number
    status: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    academicPeriodId?: true
    enrolledAt?: true
    status?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    academicPeriodId?: true
    enrolledAt?: true
    status?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    academicPeriodId?: true
    enrolledAt?: true
    status?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    studentId: string
    courseId: string
    academicPeriodId: string | null
    enrolledAt: Date
    status: string | null
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    enrolledAt?: boolean
    status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Enrollment$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    enrolledAt?: boolean
    status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Enrollment$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    enrolledAt?: boolean
    status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Enrollment$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    enrolledAt?: boolean
    status?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "academicPeriodId" | "enrolledAt" | "status", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Enrollment$academicPeriodArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Enrollment$academicPeriodArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | Enrollment$academicPeriodArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      courseId: string
      academicPeriodId: string | null
      enrolledAt: Date
      status: string | null
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends Enrollment$academicPeriodArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$academicPeriodArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly studentId: FieldRef<"Enrollment", 'String'>
    readonly courseId: FieldRef<"Enrollment", 'String'>
    readonly academicPeriodId: FieldRef<"Enrollment", 'String'>
    readonly enrolledAt: FieldRef<"Enrollment", 'DateTime'>
    readonly status: FieldRef<"Enrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment.academicPeriod
   */
  export type Enrollment$academicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model StudentSubject
   */

  export type AggregateStudentSubject = {
    _count: StudentSubjectCountAggregateOutputType | null
    _avg: StudentSubjectAvgAggregateOutputType | null
    _sum: StudentSubjectSumAggregateOutputType | null
    _min: StudentSubjectMinAggregateOutputType | null
    _max: StudentSubjectMaxAggregateOutputType | null
  }

  export type StudentSubjectAvgAggregateOutputType = {
    semester: number | null
    year: number | null
    finalGrade: Decimal | null
  }

  export type StudentSubjectSumAggregateOutputType = {
    semester: number | null
    year: number | null
    finalGrade: Decimal | null
  }

  export type StudentSubjectMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    classroomId: string | null
    semester: number | null
    year: number | null
    finalGrade: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type StudentSubjectMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    classroomId: string | null
    semester: number | null
    year: number | null
    finalGrade: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type StudentSubjectCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    classroomId: number
    semester: number
    year: number
    finalGrade: number
    status: number
    createdAt: number
    _all: number
  }


  export type StudentSubjectAvgAggregateInputType = {
    semester?: true
    year?: true
    finalGrade?: true
  }

  export type StudentSubjectSumAggregateInputType = {
    semester?: true
    year?: true
    finalGrade?: true
  }

  export type StudentSubjectMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    classroomId?: true
    semester?: true
    year?: true
    finalGrade?: true
    status?: true
    createdAt?: true
  }

  export type StudentSubjectMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    classroomId?: true
    semester?: true
    year?: true
    finalGrade?: true
    status?: true
    createdAt?: true
  }

  export type StudentSubjectCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    classroomId?: true
    semester?: true
    year?: true
    finalGrade?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type StudentSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSubject to aggregate.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSubjects
    **/
    _count?: true | StudentSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSubjectMaxAggregateInputType
  }

  export type GetStudentSubjectAggregateType<T extends StudentSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSubject[P]>
      : GetScalarType<T[P], AggregateStudentSubject[P]>
  }




  export type StudentSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithAggregationInput | StudentSubjectOrderByWithAggregationInput[]
    by: StudentSubjectScalarFieldEnum[] | StudentSubjectScalarFieldEnum
    having?: StudentSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSubjectCountAggregateInputType | true
    _avg?: StudentSubjectAvgAggregateInputType
    _sum?: StudentSubjectSumAggregateInputType
    _min?: StudentSubjectMinAggregateInputType
    _max?: StudentSubjectMaxAggregateInputType
  }

  export type StudentSubjectGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    classroomId: string | null
    semester: number | null
    year: number | null
    finalGrade: Decimal | null
    status: string | null
    createdAt: Date
    _count: StudentSubjectCountAggregateOutputType | null
    _avg: StudentSubjectAvgAggregateOutputType | null
    _sum: StudentSubjectSumAggregateOutputType | null
    _min: StudentSubjectMinAggregateOutputType | null
    _max: StudentSubjectMaxAggregateOutputType | null
  }

  type GetStudentSubjectGroupByPayload<T extends StudentSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSubjectGroupByOutputType[P]>
        }
      >
    >


  export type StudentSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    classroomId?: boolean
    semester?: boolean
    year?: boolean
    finalGrade?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classroom?: boolean | StudentSubject$classroomArgs<ExtArgs>
    grades?: boolean | StudentSubject$gradesArgs<ExtArgs>
    _count?: boolean | StudentSubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    classroomId?: boolean
    semester?: boolean
    year?: boolean
    finalGrade?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classroom?: boolean | StudentSubject$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    classroomId?: boolean
    semester?: boolean
    year?: boolean
    finalGrade?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classroom?: boolean | StudentSubject$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    classroomId?: boolean
    semester?: boolean
    year?: boolean
    finalGrade?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type StudentSubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "classroomId" | "semester" | "year" | "finalGrade" | "status" | "createdAt", ExtArgs["result"]["studentSubject"]>
  export type StudentSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classroom?: boolean | StudentSubject$classroomArgs<ExtArgs>
    grades?: boolean | StudentSubject$gradesArgs<ExtArgs>
    _count?: boolean | StudentSubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classroom?: boolean | StudentSubject$classroomArgs<ExtArgs>
  }
  export type StudentSubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classroom?: boolean | StudentSubject$classroomArgs<ExtArgs>
  }

  export type $StudentSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSubject"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      classroom: Prisma.$VirtualClassroomPayload<ExtArgs> | null
      grades: Prisma.$GradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      classroomId: string | null
      semester: number | null
      year: number | null
      finalGrade: Prisma.Decimal | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["studentSubject"]>
    composites: {}
  }

  type StudentSubjectGetPayload<S extends boolean | null | undefined | StudentSubjectDefaultArgs> = $Result.GetResult<Prisma.$StudentSubjectPayload, S>

  type StudentSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSubjectCountAggregateInputType | true
    }

  export interface StudentSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSubject'], meta: { name: 'StudentSubject' } }
    /**
     * Find zero or one StudentSubject that matches the filter.
     * @param {StudentSubjectFindUniqueArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSubjectFindUniqueArgs>(args: SelectSubset<T, StudentSubjectFindUniqueArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSubjectFindUniqueOrThrowArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindFirstArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSubjectFindFirstArgs>(args?: SelectSubset<T, StudentSubjectFindFirstArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindFirstOrThrowArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSubjects
     * const studentSubjects = await prisma.studentSubject.findMany()
     * 
     * // Get first 10 StudentSubjects
     * const studentSubjects = await prisma.studentSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSubjectFindManyArgs>(args?: SelectSubset<T, StudentSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSubject.
     * @param {StudentSubjectCreateArgs} args - Arguments to create a StudentSubject.
     * @example
     * // Create one StudentSubject
     * const StudentSubject = await prisma.studentSubject.create({
     *   data: {
     *     // ... data to create a StudentSubject
     *   }
     * })
     * 
     */
    create<T extends StudentSubjectCreateArgs>(args: SelectSubset<T, StudentSubjectCreateArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSubjects.
     * @param {StudentSubjectCreateManyArgs} args - Arguments to create many StudentSubjects.
     * @example
     * // Create many StudentSubjects
     * const studentSubject = await prisma.studentSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSubjectCreateManyArgs>(args?: SelectSubset<T, StudentSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSubjects and returns the data saved in the database.
     * @param {StudentSubjectCreateManyAndReturnArgs} args - Arguments to create many StudentSubjects.
     * @example
     * // Create many StudentSubjects
     * const studentSubject = await prisma.studentSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSubjects and only return the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentSubject.
     * @param {StudentSubjectDeleteArgs} args - Arguments to delete one StudentSubject.
     * @example
     * // Delete one StudentSubject
     * const StudentSubject = await prisma.studentSubject.delete({
     *   where: {
     *     // ... filter to delete one StudentSubject
     *   }
     * })
     * 
     */
    delete<T extends StudentSubjectDeleteArgs>(args: SelectSubset<T, StudentSubjectDeleteArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSubject.
     * @param {StudentSubjectUpdateArgs} args - Arguments to update one StudentSubject.
     * @example
     * // Update one StudentSubject
     * const studentSubject = await prisma.studentSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSubjectUpdateArgs>(args: SelectSubset<T, StudentSubjectUpdateArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSubjects.
     * @param {StudentSubjectDeleteManyArgs} args - Arguments to filter StudentSubjects to delete.
     * @example
     * // Delete a few StudentSubjects
     * const { count } = await prisma.studentSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSubjectDeleteManyArgs>(args?: SelectSubset<T, StudentSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSubjects
     * const studentSubject = await prisma.studentSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSubjectUpdateManyArgs>(args: SelectSubset<T, StudentSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSubjects and returns the data updated in the database.
     * @param {StudentSubjectUpdateManyAndReturnArgs} args - Arguments to update many StudentSubjects.
     * @example
     * // Update many StudentSubjects
     * const studentSubject = await prisma.studentSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentSubjects and only return the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentSubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentSubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentSubject.
     * @param {StudentSubjectUpsertArgs} args - Arguments to update or create a StudentSubject.
     * @example
     * // Update or create a StudentSubject
     * const studentSubject = await prisma.studentSubject.upsert({
     *   create: {
     *     // ... data to create a StudentSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSubject we want to update
     *   }
     * })
     */
    upsert<T extends StudentSubjectUpsertArgs>(args: SelectSubset<T, StudentSubjectUpsertArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectCountArgs} args - Arguments to filter StudentSubjects to count.
     * @example
     * // Count the number of StudentSubjects
     * const count = await prisma.studentSubject.count({
     *   where: {
     *     // ... the filter for the StudentSubjects we want to count
     *   }
     * })
    **/
    count<T extends StudentSubjectCountArgs>(
      args?: Subset<T, StudentSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSubjectAggregateArgs>(args: Subset<T, StudentSubjectAggregateArgs>): Prisma.PrismaPromise<GetStudentSubjectAggregateType<T>>

    /**
     * Group by StudentSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSubjectGroupByArgs['orderBy'] }
        : { orderBy?: StudentSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSubject model
   */
  readonly fields: StudentSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classroom<T extends StudentSubject$classroomArgs<ExtArgs> = {}>(args?: Subset<T, StudentSubject$classroomArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    grades<T extends StudentSubject$gradesArgs<ExtArgs> = {}>(args?: Subset<T, StudentSubject$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSubject model
   */
  interface StudentSubjectFieldRefs {
    readonly id: FieldRef<"StudentSubject", 'String'>
    readonly studentId: FieldRef<"StudentSubject", 'String'>
    readonly subjectId: FieldRef<"StudentSubject", 'String'>
    readonly classroomId: FieldRef<"StudentSubject", 'String'>
    readonly semester: FieldRef<"StudentSubject", 'Int'>
    readonly year: FieldRef<"StudentSubject", 'Int'>
    readonly finalGrade: FieldRef<"StudentSubject", 'Decimal'>
    readonly status: FieldRef<"StudentSubject", 'String'>
    readonly createdAt: FieldRef<"StudentSubject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSubject findUnique
   */
  export type StudentSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject findUniqueOrThrow
   */
  export type StudentSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject findFirst
   */
  export type StudentSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSubjects.
     */
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject findFirstOrThrow
   */
  export type StudentSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSubjects.
     */
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject findMany
   */
  export type StudentSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubjects to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject create
   */
  export type StudentSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSubject.
     */
    data: XOR<StudentSubjectCreateInput, StudentSubjectUncheckedCreateInput>
  }

  /**
   * StudentSubject createMany
   */
  export type StudentSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSubjects.
     */
    data: StudentSubjectCreateManyInput | StudentSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSubject createManyAndReturn
   */
  export type StudentSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * The data used to create many StudentSubjects.
     */
    data: StudentSubjectCreateManyInput | StudentSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSubject update
   */
  export type StudentSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSubject.
     */
    data: XOR<StudentSubjectUpdateInput, StudentSubjectUncheckedUpdateInput>
    /**
     * Choose, which StudentSubject to update.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject updateMany
   */
  export type StudentSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSubjects.
     */
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyInput>
    /**
     * Filter which StudentSubjects to update
     */
    where?: StudentSubjectWhereInput
    /**
     * Limit how many StudentSubjects to update.
     */
    limit?: number
  }

  /**
   * StudentSubject updateManyAndReturn
   */
  export type StudentSubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * The data used to update StudentSubjects.
     */
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyInput>
    /**
     * Filter which StudentSubjects to update
     */
    where?: StudentSubjectWhereInput
    /**
     * Limit how many StudentSubjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSubject upsert
   */
  export type StudentSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSubject to update in case it exists.
     */
    where: StudentSubjectWhereUniqueInput
    /**
     * In case the StudentSubject found by the `where` argument doesn't exist, create a new StudentSubject with this data.
     */
    create: XOR<StudentSubjectCreateInput, StudentSubjectUncheckedCreateInput>
    /**
     * In case the StudentSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSubjectUpdateInput, StudentSubjectUncheckedUpdateInput>
  }

  /**
   * StudentSubject delete
   */
  export type StudentSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter which StudentSubject to delete.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject deleteMany
   */
  export type StudentSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSubjects to delete
     */
    where?: StudentSubjectWhereInput
    /**
     * Limit how many StudentSubjects to delete.
     */
    limit?: number
  }

  /**
   * StudentSubject.classroom
   */
  export type StudentSubject$classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    where?: VirtualClassroomWhereInput
  }

  /**
   * StudentSubject.grades
   */
  export type StudentSubject$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * StudentSubject without action
   */
  export type StudentSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSubject
     */
    omit?: StudentSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    weight: Decimal | null
    value: Decimal | null
  }

  export type GradeSumAggregateOutputType = {
    weight: Decimal | null
    value: Decimal | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    studentSubjectId: string | null
    type: $Enums.GradeType | null
    weight: Decimal | null
    value: Decimal | null
    comments: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    studentSubjectId: string | null
    type: $Enums.GradeType | null
    weight: Decimal | null
    value: Decimal | null
    comments: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    studentSubjectId: number
    type: number
    weight: number
    value: number
    comments: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    weight?: true
    value?: true
  }

  export type GradeSumAggregateInputType = {
    weight?: true
    value?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    studentSubjectId?: true
    type?: true
    weight?: true
    value?: true
    comments?: true
    createdById?: true
    createdAt?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    studentSubjectId?: true
    type?: true
    weight?: true
    value?: true
    comments?: true
    createdById?: true
    createdAt?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    studentSubjectId?: true
    type?: true
    weight?: true
    value?: true
    comments?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    studentSubjectId: string
    type: $Enums.GradeType
    weight: Decimal | null
    value: Decimal
    comments: string | null
    createdById: string | null
    createdAt: Date
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentSubjectId?: boolean
    type?: boolean
    weight?: boolean
    value?: boolean
    comments?: boolean
    createdById?: boolean
    createdAt?: boolean
    studentSubject?: boolean | StudentSubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | Grade$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentSubjectId?: boolean
    type?: boolean
    weight?: boolean
    value?: boolean
    comments?: boolean
    createdById?: boolean
    createdAt?: boolean
    studentSubject?: boolean | StudentSubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | Grade$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentSubjectId?: boolean
    type?: boolean
    weight?: boolean
    value?: boolean
    comments?: boolean
    createdById?: boolean
    createdAt?: boolean
    studentSubject?: boolean | StudentSubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | Grade$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    studentSubjectId?: boolean
    type?: boolean
    weight?: boolean
    value?: boolean
    comments?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentSubjectId" | "type" | "weight" | "value" | "comments" | "createdById" | "createdAt", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSubject?: boolean | StudentSubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | Grade$createdByArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSubject?: boolean | StudentSubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | Grade$createdByArgs<ExtArgs>
  }
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSubject?: boolean | StudentSubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | Grade$createdByArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      studentSubject: Prisma.$StudentSubjectPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentSubjectId: string
      type: $Enums.GradeType
      weight: Prisma.Decimal | null
      value: Prisma.Decimal
      comments: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentSubject<T extends StudentSubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentSubjectDefaultArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Grade$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Grade$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly studentSubjectId: FieldRef<"Grade", 'String'>
    readonly type: FieldRef<"Grade", 'GradeType'>
    readonly weight: FieldRef<"Grade", 'Decimal'>
    readonly value: FieldRef<"Grade", 'Decimal'>
    readonly comments: FieldRef<"Grade", 'String'>
    readonly createdById: FieldRef<"Grade", 'String'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.createdBy
   */
  export type Grade$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classroomId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    notedById: string | null
    note: string | null
    createdAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classroomId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    notedById: string | null
    note: string | null
    createdAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    studentId: number
    classroomId: number
    date: number
    status: number
    notedById: number
    note: number
    createdAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    studentId?: true
    classroomId?: true
    date?: true
    status?: true
    notedById?: true
    note?: true
    createdAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    classroomId?: true
    date?: true
    status?: true
    notedById?: true
    note?: true
    createdAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    studentId?: true
    classroomId?: true
    date?: true
    status?: true
    notedById?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    studentId: string
    classroomId: string
    date: Date
    status: $Enums.AttendanceStatus
    notedById: string | null
    note: string | null
    createdAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classroomId?: boolean
    date?: boolean
    status?: boolean
    notedById?: boolean
    note?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    notedBy?: boolean | Attendance$notedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classroomId?: boolean
    date?: boolean
    status?: boolean
    notedById?: boolean
    note?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    notedBy?: boolean | Attendance$notedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classroomId?: boolean
    date?: boolean
    status?: boolean
    notedById?: boolean
    note?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    notedBy?: boolean | Attendance$notedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    classroomId?: boolean
    date?: boolean
    status?: boolean
    notedById?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classroomId" | "date" | "status" | "notedById" | "note" | "createdAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    notedBy?: boolean | Attendance$notedByArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    notedBy?: boolean | Attendance$notedByArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    classroom?: boolean | VirtualClassroomDefaultArgs<ExtArgs>
    notedBy?: boolean | Attendance$notedByArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      classroom: Prisma.$VirtualClassroomPayload<ExtArgs>
      notedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classroomId: string
      date: Date
      status: $Enums.AttendanceStatus
      notedById: string | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classroom<T extends VirtualClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassroomDefaultArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notedBy<T extends Attendance$notedByArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$notedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly studentId: FieldRef<"Attendance", 'String'>
    readonly classroomId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly notedById: FieldRef<"Attendance", 'String'>
    readonly note: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.notedBy
   */
  export type Attendance$notedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model DisciplinaryRecord
   */

  export type AggregateDisciplinaryRecord = {
    _count: DisciplinaryRecordCountAggregateOutputType | null
    _min: DisciplinaryRecordMinAggregateOutputType | null
    _max: DisciplinaryRecordMaxAggregateOutputType | null
  }

  export type DisciplinaryRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    recordedById: string | null
    type: string | null
    description: string | null
    actionTaken: string | null
    date: Date | null
    seenByTutor: boolean | null
  }

  export type DisciplinaryRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    recordedById: string | null
    type: string | null
    description: string | null
    actionTaken: string | null
    date: Date | null
    seenByTutor: boolean | null
  }

  export type DisciplinaryRecordCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    recordedById: number
    type: number
    description: number
    actionTaken: number
    date: number
    seenByTutor: number
    _all: number
  }


  export type DisciplinaryRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    recordedById?: true
    type?: true
    description?: true
    actionTaken?: true
    date?: true
    seenByTutor?: true
  }

  export type DisciplinaryRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    recordedById?: true
    type?: true
    description?: true
    actionTaken?: true
    date?: true
    seenByTutor?: true
  }

  export type DisciplinaryRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    recordedById?: true
    type?: true
    description?: true
    actionTaken?: true
    date?: true
    seenByTutor?: true
    _all?: true
  }

  export type DisciplinaryRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisciplinaryRecord to aggregate.
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplinaryRecords to fetch.
     */
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisciplinaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplinaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplinaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisciplinaryRecords
    **/
    _count?: true | DisciplinaryRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisciplinaryRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisciplinaryRecordMaxAggregateInputType
  }

  export type GetDisciplinaryRecordAggregateType<T extends DisciplinaryRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDisciplinaryRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisciplinaryRecord[P]>
      : GetScalarType<T[P], AggregateDisciplinaryRecord[P]>
  }




  export type DisciplinaryRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisciplinaryRecordWhereInput
    orderBy?: DisciplinaryRecordOrderByWithAggregationInput | DisciplinaryRecordOrderByWithAggregationInput[]
    by: DisciplinaryRecordScalarFieldEnum[] | DisciplinaryRecordScalarFieldEnum
    having?: DisciplinaryRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisciplinaryRecordCountAggregateInputType | true
    _min?: DisciplinaryRecordMinAggregateInputType
    _max?: DisciplinaryRecordMaxAggregateInputType
  }

  export type DisciplinaryRecordGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string | null
    recordedById: string | null
    type: string | null
    description: string
    actionTaken: string | null
    date: Date
    seenByTutor: boolean
    _count: DisciplinaryRecordCountAggregateOutputType | null
    _min: DisciplinaryRecordMinAggregateOutputType | null
    _max: DisciplinaryRecordMaxAggregateOutputType | null
  }

  type GetDisciplinaryRecordGroupByPayload<T extends DisciplinaryRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisciplinaryRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisciplinaryRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisciplinaryRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DisciplinaryRecordGroupByOutputType[P]>
        }
      >
    >


  export type DisciplinaryRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    recordedById?: boolean
    type?: boolean
    description?: boolean
    actionTaken?: boolean
    date?: boolean
    seenByTutor?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | DisciplinaryRecord$subjectArgs<ExtArgs>
    recordedBy?: boolean | DisciplinaryRecord$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["disciplinaryRecord"]>

  export type DisciplinaryRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    recordedById?: boolean
    type?: boolean
    description?: boolean
    actionTaken?: boolean
    date?: boolean
    seenByTutor?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | DisciplinaryRecord$subjectArgs<ExtArgs>
    recordedBy?: boolean | DisciplinaryRecord$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["disciplinaryRecord"]>

  export type DisciplinaryRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    recordedById?: boolean
    type?: boolean
    description?: boolean
    actionTaken?: boolean
    date?: boolean
    seenByTutor?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | DisciplinaryRecord$subjectArgs<ExtArgs>
    recordedBy?: boolean | DisciplinaryRecord$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["disciplinaryRecord"]>

  export type DisciplinaryRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    recordedById?: boolean
    type?: boolean
    description?: boolean
    actionTaken?: boolean
    date?: boolean
    seenByTutor?: boolean
  }

  export type DisciplinaryRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "recordedById" | "type" | "description" | "actionTaken" | "date" | "seenByTutor", ExtArgs["result"]["disciplinaryRecord"]>
  export type DisciplinaryRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | DisciplinaryRecord$subjectArgs<ExtArgs>
    recordedBy?: boolean | DisciplinaryRecord$recordedByArgs<ExtArgs>
  }
  export type DisciplinaryRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | DisciplinaryRecord$subjectArgs<ExtArgs>
    recordedBy?: boolean | DisciplinaryRecord$recordedByArgs<ExtArgs>
  }
  export type DisciplinaryRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | DisciplinaryRecord$subjectArgs<ExtArgs>
    recordedBy?: boolean | DisciplinaryRecord$recordedByArgs<ExtArgs>
  }

  export type $DisciplinaryRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisciplinaryRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      recordedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string | null
      recordedById: string | null
      type: string | null
      description: string
      actionTaken: string | null
      date: Date
      seenByTutor: boolean
    }, ExtArgs["result"]["disciplinaryRecord"]>
    composites: {}
  }

  type DisciplinaryRecordGetPayload<S extends boolean | null | undefined | DisciplinaryRecordDefaultArgs> = $Result.GetResult<Prisma.$DisciplinaryRecordPayload, S>

  type DisciplinaryRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisciplinaryRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisciplinaryRecordCountAggregateInputType | true
    }

  export interface DisciplinaryRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisciplinaryRecord'], meta: { name: 'DisciplinaryRecord' } }
    /**
     * Find zero or one DisciplinaryRecord that matches the filter.
     * @param {DisciplinaryRecordFindUniqueArgs} args - Arguments to find a DisciplinaryRecord
     * @example
     * // Get one DisciplinaryRecord
     * const disciplinaryRecord = await prisma.disciplinaryRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisciplinaryRecordFindUniqueArgs>(args: SelectSubset<T, DisciplinaryRecordFindUniqueArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisciplinaryRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisciplinaryRecordFindUniqueOrThrowArgs} args - Arguments to find a DisciplinaryRecord
     * @example
     * // Get one DisciplinaryRecord
     * const disciplinaryRecord = await prisma.disciplinaryRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisciplinaryRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, DisciplinaryRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplinaryRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordFindFirstArgs} args - Arguments to find a DisciplinaryRecord
     * @example
     * // Get one DisciplinaryRecord
     * const disciplinaryRecord = await prisma.disciplinaryRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisciplinaryRecordFindFirstArgs>(args?: SelectSubset<T, DisciplinaryRecordFindFirstArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplinaryRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordFindFirstOrThrowArgs} args - Arguments to find a DisciplinaryRecord
     * @example
     * // Get one DisciplinaryRecord
     * const disciplinaryRecord = await prisma.disciplinaryRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisciplinaryRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, DisciplinaryRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisciplinaryRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisciplinaryRecords
     * const disciplinaryRecords = await prisma.disciplinaryRecord.findMany()
     * 
     * // Get first 10 DisciplinaryRecords
     * const disciplinaryRecords = await prisma.disciplinaryRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disciplinaryRecordWithIdOnly = await prisma.disciplinaryRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisciplinaryRecordFindManyArgs>(args?: SelectSubset<T, DisciplinaryRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisciplinaryRecord.
     * @param {DisciplinaryRecordCreateArgs} args - Arguments to create a DisciplinaryRecord.
     * @example
     * // Create one DisciplinaryRecord
     * const DisciplinaryRecord = await prisma.disciplinaryRecord.create({
     *   data: {
     *     // ... data to create a DisciplinaryRecord
     *   }
     * })
     * 
     */
    create<T extends DisciplinaryRecordCreateArgs>(args: SelectSubset<T, DisciplinaryRecordCreateArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisciplinaryRecords.
     * @param {DisciplinaryRecordCreateManyArgs} args - Arguments to create many DisciplinaryRecords.
     * @example
     * // Create many DisciplinaryRecords
     * const disciplinaryRecord = await prisma.disciplinaryRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisciplinaryRecordCreateManyArgs>(args?: SelectSubset<T, DisciplinaryRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisciplinaryRecords and returns the data saved in the database.
     * @param {DisciplinaryRecordCreateManyAndReturnArgs} args - Arguments to create many DisciplinaryRecords.
     * @example
     * // Create many DisciplinaryRecords
     * const disciplinaryRecord = await prisma.disciplinaryRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisciplinaryRecords and only return the `id`
     * const disciplinaryRecordWithIdOnly = await prisma.disciplinaryRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisciplinaryRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, DisciplinaryRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisciplinaryRecord.
     * @param {DisciplinaryRecordDeleteArgs} args - Arguments to delete one DisciplinaryRecord.
     * @example
     * // Delete one DisciplinaryRecord
     * const DisciplinaryRecord = await prisma.disciplinaryRecord.delete({
     *   where: {
     *     // ... filter to delete one DisciplinaryRecord
     *   }
     * })
     * 
     */
    delete<T extends DisciplinaryRecordDeleteArgs>(args: SelectSubset<T, DisciplinaryRecordDeleteArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisciplinaryRecord.
     * @param {DisciplinaryRecordUpdateArgs} args - Arguments to update one DisciplinaryRecord.
     * @example
     * // Update one DisciplinaryRecord
     * const disciplinaryRecord = await prisma.disciplinaryRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisciplinaryRecordUpdateArgs>(args: SelectSubset<T, DisciplinaryRecordUpdateArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisciplinaryRecords.
     * @param {DisciplinaryRecordDeleteManyArgs} args - Arguments to filter DisciplinaryRecords to delete.
     * @example
     * // Delete a few DisciplinaryRecords
     * const { count } = await prisma.disciplinaryRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisciplinaryRecordDeleteManyArgs>(args?: SelectSubset<T, DisciplinaryRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisciplinaryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisciplinaryRecords
     * const disciplinaryRecord = await prisma.disciplinaryRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisciplinaryRecordUpdateManyArgs>(args: SelectSubset<T, DisciplinaryRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisciplinaryRecords and returns the data updated in the database.
     * @param {DisciplinaryRecordUpdateManyAndReturnArgs} args - Arguments to update many DisciplinaryRecords.
     * @example
     * // Update many DisciplinaryRecords
     * const disciplinaryRecord = await prisma.disciplinaryRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisciplinaryRecords and only return the `id`
     * const disciplinaryRecordWithIdOnly = await prisma.disciplinaryRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisciplinaryRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, DisciplinaryRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisciplinaryRecord.
     * @param {DisciplinaryRecordUpsertArgs} args - Arguments to update or create a DisciplinaryRecord.
     * @example
     * // Update or create a DisciplinaryRecord
     * const disciplinaryRecord = await prisma.disciplinaryRecord.upsert({
     *   create: {
     *     // ... data to create a DisciplinaryRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisciplinaryRecord we want to update
     *   }
     * })
     */
    upsert<T extends DisciplinaryRecordUpsertArgs>(args: SelectSubset<T, DisciplinaryRecordUpsertArgs<ExtArgs>>): Prisma__DisciplinaryRecordClient<$Result.GetResult<Prisma.$DisciplinaryRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisciplinaryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordCountArgs} args - Arguments to filter DisciplinaryRecords to count.
     * @example
     * // Count the number of DisciplinaryRecords
     * const count = await prisma.disciplinaryRecord.count({
     *   where: {
     *     // ... the filter for the DisciplinaryRecords we want to count
     *   }
     * })
    **/
    count<T extends DisciplinaryRecordCountArgs>(
      args?: Subset<T, DisciplinaryRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisciplinaryRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisciplinaryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisciplinaryRecordAggregateArgs>(args: Subset<T, DisciplinaryRecordAggregateArgs>): Prisma.PrismaPromise<GetDisciplinaryRecordAggregateType<T>>

    /**
     * Group by DisciplinaryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinaryRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisciplinaryRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisciplinaryRecordGroupByArgs['orderBy'] }
        : { orderBy?: DisciplinaryRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisciplinaryRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisciplinaryRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisciplinaryRecord model
   */
  readonly fields: DisciplinaryRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisciplinaryRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisciplinaryRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends DisciplinaryRecord$subjectArgs<ExtArgs> = {}>(args?: Subset<T, DisciplinaryRecord$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recordedBy<T extends DisciplinaryRecord$recordedByArgs<ExtArgs> = {}>(args?: Subset<T, DisciplinaryRecord$recordedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisciplinaryRecord model
   */
  interface DisciplinaryRecordFieldRefs {
    readonly id: FieldRef<"DisciplinaryRecord", 'String'>
    readonly studentId: FieldRef<"DisciplinaryRecord", 'String'>
    readonly subjectId: FieldRef<"DisciplinaryRecord", 'String'>
    readonly recordedById: FieldRef<"DisciplinaryRecord", 'String'>
    readonly type: FieldRef<"DisciplinaryRecord", 'String'>
    readonly description: FieldRef<"DisciplinaryRecord", 'String'>
    readonly actionTaken: FieldRef<"DisciplinaryRecord", 'String'>
    readonly date: FieldRef<"DisciplinaryRecord", 'DateTime'>
    readonly seenByTutor: FieldRef<"DisciplinaryRecord", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DisciplinaryRecord findUnique
   */
  export type DisciplinaryRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which DisciplinaryRecord to fetch.
     */
    where: DisciplinaryRecordWhereUniqueInput
  }

  /**
   * DisciplinaryRecord findUniqueOrThrow
   */
  export type DisciplinaryRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which DisciplinaryRecord to fetch.
     */
    where: DisciplinaryRecordWhereUniqueInput
  }

  /**
   * DisciplinaryRecord findFirst
   */
  export type DisciplinaryRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which DisciplinaryRecord to fetch.
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplinaryRecords to fetch.
     */
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisciplinaryRecords.
     */
    cursor?: DisciplinaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplinaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplinaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisciplinaryRecords.
     */
    distinct?: DisciplinaryRecordScalarFieldEnum | DisciplinaryRecordScalarFieldEnum[]
  }

  /**
   * DisciplinaryRecord findFirstOrThrow
   */
  export type DisciplinaryRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which DisciplinaryRecord to fetch.
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplinaryRecords to fetch.
     */
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisciplinaryRecords.
     */
    cursor?: DisciplinaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplinaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplinaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisciplinaryRecords.
     */
    distinct?: DisciplinaryRecordScalarFieldEnum | DisciplinaryRecordScalarFieldEnum[]
  }

  /**
   * DisciplinaryRecord findMany
   */
  export type DisciplinaryRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which DisciplinaryRecords to fetch.
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplinaryRecords to fetch.
     */
    orderBy?: DisciplinaryRecordOrderByWithRelationInput | DisciplinaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisciplinaryRecords.
     */
    cursor?: DisciplinaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplinaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplinaryRecords.
     */
    skip?: number
    distinct?: DisciplinaryRecordScalarFieldEnum | DisciplinaryRecordScalarFieldEnum[]
  }

  /**
   * DisciplinaryRecord create
   */
  export type DisciplinaryRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DisciplinaryRecord.
     */
    data: XOR<DisciplinaryRecordCreateInput, DisciplinaryRecordUncheckedCreateInput>
  }

  /**
   * DisciplinaryRecord createMany
   */
  export type DisciplinaryRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisciplinaryRecords.
     */
    data: DisciplinaryRecordCreateManyInput | DisciplinaryRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisciplinaryRecord createManyAndReturn
   */
  export type DisciplinaryRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * The data used to create many DisciplinaryRecords.
     */
    data: DisciplinaryRecordCreateManyInput | DisciplinaryRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisciplinaryRecord update
   */
  export type DisciplinaryRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DisciplinaryRecord.
     */
    data: XOR<DisciplinaryRecordUpdateInput, DisciplinaryRecordUncheckedUpdateInput>
    /**
     * Choose, which DisciplinaryRecord to update.
     */
    where: DisciplinaryRecordWhereUniqueInput
  }

  /**
   * DisciplinaryRecord updateMany
   */
  export type DisciplinaryRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisciplinaryRecords.
     */
    data: XOR<DisciplinaryRecordUpdateManyMutationInput, DisciplinaryRecordUncheckedUpdateManyInput>
    /**
     * Filter which DisciplinaryRecords to update
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * Limit how many DisciplinaryRecords to update.
     */
    limit?: number
  }

  /**
   * DisciplinaryRecord updateManyAndReturn
   */
  export type DisciplinaryRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * The data used to update DisciplinaryRecords.
     */
    data: XOR<DisciplinaryRecordUpdateManyMutationInput, DisciplinaryRecordUncheckedUpdateManyInput>
    /**
     * Filter which DisciplinaryRecords to update
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * Limit how many DisciplinaryRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisciplinaryRecord upsert
   */
  export type DisciplinaryRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DisciplinaryRecord to update in case it exists.
     */
    where: DisciplinaryRecordWhereUniqueInput
    /**
     * In case the DisciplinaryRecord found by the `where` argument doesn't exist, create a new DisciplinaryRecord with this data.
     */
    create: XOR<DisciplinaryRecordCreateInput, DisciplinaryRecordUncheckedCreateInput>
    /**
     * In case the DisciplinaryRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisciplinaryRecordUpdateInput, DisciplinaryRecordUncheckedUpdateInput>
  }

  /**
   * DisciplinaryRecord delete
   */
  export type DisciplinaryRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
    /**
     * Filter which DisciplinaryRecord to delete.
     */
    where: DisciplinaryRecordWhereUniqueInput
  }

  /**
   * DisciplinaryRecord deleteMany
   */
  export type DisciplinaryRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisciplinaryRecords to delete
     */
    where?: DisciplinaryRecordWhereInput
    /**
     * Limit how many DisciplinaryRecords to delete.
     */
    limit?: number
  }

  /**
   * DisciplinaryRecord.subject
   */
  export type DisciplinaryRecord$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * DisciplinaryRecord.recordedBy
   */
  export type DisciplinaryRecord$recordedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DisciplinaryRecord without action
   */
  export type DisciplinaryRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinaryRecord
     */
    select?: DisciplinaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplinaryRecord
     */
    omit?: DisciplinaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplinaryRecordInclude<ExtArgs> | null
  }


  /**
   * Model TutorProfile
   */

  export type AggregateTutorProfile = {
    _count: TutorProfileCountAggregateOutputType | null
    _min: TutorProfileMinAggregateOutputType | null
    _max: TutorProfileMaxAggregateOutputType | null
  }

  export type TutorProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
    relationship: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
  }

  export type TutorProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
    relationship: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
  }

  export type TutorProfileCountAggregateOutputType = {
    id: number
    userId: number
    institutionId: number
    relationship: number
    phone: number
    address: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type TutorProfileMinAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    relationship?: true
    phone?: true
    address?: true
    createdAt?: true
  }

  export type TutorProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    relationship?: true
    phone?: true
    address?: true
    createdAt?: true
  }

  export type TutorProfileCountAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    relationship?: true
    phone?: true
    address?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type TutorProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutorProfile to aggregate.
     */
    where?: TutorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorProfiles to fetch.
     */
    orderBy?: TutorProfileOrderByWithRelationInput | TutorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutorProfiles
    **/
    _count?: true | TutorProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorProfileMaxAggregateInputType
  }

  export type GetTutorProfileAggregateType<T extends TutorProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateTutorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutorProfile[P]>
      : GetScalarType<T[P], AggregateTutorProfile[P]>
  }




  export type TutorProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorProfileWhereInput
    orderBy?: TutorProfileOrderByWithAggregationInput | TutorProfileOrderByWithAggregationInput[]
    by: TutorProfileScalarFieldEnum[] | TutorProfileScalarFieldEnum
    having?: TutorProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorProfileCountAggregateInputType | true
    _min?: TutorProfileMinAggregateInputType
    _max?: TutorProfileMaxAggregateInputType
  }

  export type TutorProfileGroupByOutputType = {
    id: string
    userId: string
    institutionId: string
    relationship: string | null
    phone: string | null
    address: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: TutorProfileCountAggregateOutputType | null
    _min: TutorProfileMinAggregateOutputType | null
    _max: TutorProfileMaxAggregateOutputType | null
  }

  type GetTutorProfileGroupByPayload<T extends TutorProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], TutorProfileGroupByOutputType[P]>
        }
      >
    >


  export type TutorProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    relationship?: boolean
    phone?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    tutorAssignments?: boolean | TutorProfile$tutorAssignmentsArgs<ExtArgs>
    _count?: boolean | TutorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorProfile"]>

  export type TutorProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    relationship?: boolean
    phone?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorProfile"]>

  export type TutorProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    relationship?: boolean
    phone?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorProfile"]>

  export type TutorProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    relationship?: boolean
    phone?: boolean
    address?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type TutorProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "institutionId" | "relationship" | "phone" | "address" | "metadata" | "createdAt", ExtArgs["result"]["tutorProfile"]>
  export type TutorProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    tutorAssignments?: boolean | TutorProfile$tutorAssignmentsArgs<ExtArgs>
    _count?: boolean | TutorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TutorProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type TutorProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $TutorProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutorProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
      tutorAssignments: Prisma.$TutorStudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      institutionId: string
      relationship: string | null
      phone: string | null
      address: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["tutorProfile"]>
    composites: {}
  }

  type TutorProfileGetPayload<S extends boolean | null | undefined | TutorProfileDefaultArgs> = $Result.GetResult<Prisma.$TutorProfilePayload, S>

  type TutorProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TutorProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TutorProfileCountAggregateInputType | true
    }

  export interface TutorProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutorProfile'], meta: { name: 'TutorProfile' } }
    /**
     * Find zero or one TutorProfile that matches the filter.
     * @param {TutorProfileFindUniqueArgs} args - Arguments to find a TutorProfile
     * @example
     * // Get one TutorProfile
     * const tutorProfile = await prisma.tutorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutorProfileFindUniqueArgs>(args: SelectSubset<T, TutorProfileFindUniqueArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TutorProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TutorProfileFindUniqueOrThrowArgs} args - Arguments to find a TutorProfile
     * @example
     * // Get one TutorProfile
     * const tutorProfile = await prisma.tutorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutorProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, TutorProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TutorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileFindFirstArgs} args - Arguments to find a TutorProfile
     * @example
     * // Get one TutorProfile
     * const tutorProfile = await prisma.tutorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutorProfileFindFirstArgs>(args?: SelectSubset<T, TutorProfileFindFirstArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TutorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileFindFirstOrThrowArgs} args - Arguments to find a TutorProfile
     * @example
     * // Get one TutorProfile
     * const tutorProfile = await prisma.tutorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutorProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, TutorProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TutorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutorProfiles
     * const tutorProfiles = await prisma.tutorProfile.findMany()
     * 
     * // Get first 10 TutorProfiles
     * const tutorProfiles = await prisma.tutorProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutorProfileWithIdOnly = await prisma.tutorProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutorProfileFindManyArgs>(args?: SelectSubset<T, TutorProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TutorProfile.
     * @param {TutorProfileCreateArgs} args - Arguments to create a TutorProfile.
     * @example
     * // Create one TutorProfile
     * const TutorProfile = await prisma.tutorProfile.create({
     *   data: {
     *     // ... data to create a TutorProfile
     *   }
     * })
     * 
     */
    create<T extends TutorProfileCreateArgs>(args: SelectSubset<T, TutorProfileCreateArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TutorProfiles.
     * @param {TutorProfileCreateManyArgs} args - Arguments to create many TutorProfiles.
     * @example
     * // Create many TutorProfiles
     * const tutorProfile = await prisma.tutorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutorProfileCreateManyArgs>(args?: SelectSubset<T, TutorProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutorProfiles and returns the data saved in the database.
     * @param {TutorProfileCreateManyAndReturnArgs} args - Arguments to create many TutorProfiles.
     * @example
     * // Create many TutorProfiles
     * const tutorProfile = await prisma.tutorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutorProfiles and only return the `id`
     * const tutorProfileWithIdOnly = await prisma.tutorProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutorProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, TutorProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TutorProfile.
     * @param {TutorProfileDeleteArgs} args - Arguments to delete one TutorProfile.
     * @example
     * // Delete one TutorProfile
     * const TutorProfile = await prisma.tutorProfile.delete({
     *   where: {
     *     // ... filter to delete one TutorProfile
     *   }
     * })
     * 
     */
    delete<T extends TutorProfileDeleteArgs>(args: SelectSubset<T, TutorProfileDeleteArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TutorProfile.
     * @param {TutorProfileUpdateArgs} args - Arguments to update one TutorProfile.
     * @example
     * // Update one TutorProfile
     * const tutorProfile = await prisma.tutorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutorProfileUpdateArgs>(args: SelectSubset<T, TutorProfileUpdateArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TutorProfiles.
     * @param {TutorProfileDeleteManyArgs} args - Arguments to filter TutorProfiles to delete.
     * @example
     * // Delete a few TutorProfiles
     * const { count } = await prisma.tutorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutorProfileDeleteManyArgs>(args?: SelectSubset<T, TutorProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutorProfiles
     * const tutorProfile = await prisma.tutorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutorProfileUpdateManyArgs>(args: SelectSubset<T, TutorProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutorProfiles and returns the data updated in the database.
     * @param {TutorProfileUpdateManyAndReturnArgs} args - Arguments to update many TutorProfiles.
     * @example
     * // Update many TutorProfiles
     * const tutorProfile = await prisma.tutorProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TutorProfiles and only return the `id`
     * const tutorProfileWithIdOnly = await prisma.tutorProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TutorProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, TutorProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TutorProfile.
     * @param {TutorProfileUpsertArgs} args - Arguments to update or create a TutorProfile.
     * @example
     * // Update or create a TutorProfile
     * const tutorProfile = await prisma.tutorProfile.upsert({
     *   create: {
     *     // ... data to create a TutorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutorProfile we want to update
     *   }
     * })
     */
    upsert<T extends TutorProfileUpsertArgs>(args: SelectSubset<T, TutorProfileUpsertArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TutorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileCountArgs} args - Arguments to filter TutorProfiles to count.
     * @example
     * // Count the number of TutorProfiles
     * const count = await prisma.tutorProfile.count({
     *   where: {
     *     // ... the filter for the TutorProfiles we want to count
     *   }
     * })
    **/
    count<T extends TutorProfileCountArgs>(
      args?: Subset<T, TutorProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorProfileAggregateArgs>(args: Subset<T, TutorProfileAggregateArgs>): Prisma.PrismaPromise<GetTutorProfileAggregateType<T>>

    /**
     * Group by TutorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutorProfileGroupByArgs['orderBy'] }
        : { orderBy?: TutorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutorProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutorProfile model
   */
  readonly fields: TutorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutorProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tutorAssignments<T extends TutorProfile$tutorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, TutorProfile$tutorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutorProfile model
   */
  interface TutorProfileFieldRefs {
    readonly id: FieldRef<"TutorProfile", 'String'>
    readonly userId: FieldRef<"TutorProfile", 'String'>
    readonly institutionId: FieldRef<"TutorProfile", 'String'>
    readonly relationship: FieldRef<"TutorProfile", 'String'>
    readonly phone: FieldRef<"TutorProfile", 'String'>
    readonly address: FieldRef<"TutorProfile", 'String'>
    readonly metadata: FieldRef<"TutorProfile", 'Json'>
    readonly createdAt: FieldRef<"TutorProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutorProfile findUnique
   */
  export type TutorProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * Filter, which TutorProfile to fetch.
     */
    where: TutorProfileWhereUniqueInput
  }

  /**
   * TutorProfile findUniqueOrThrow
   */
  export type TutorProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * Filter, which TutorProfile to fetch.
     */
    where: TutorProfileWhereUniqueInput
  }

  /**
   * TutorProfile findFirst
   */
  export type TutorProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * Filter, which TutorProfile to fetch.
     */
    where?: TutorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorProfiles to fetch.
     */
    orderBy?: TutorProfileOrderByWithRelationInput | TutorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutorProfiles.
     */
    cursor?: TutorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutorProfiles.
     */
    distinct?: TutorProfileScalarFieldEnum | TutorProfileScalarFieldEnum[]
  }

  /**
   * TutorProfile findFirstOrThrow
   */
  export type TutorProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * Filter, which TutorProfile to fetch.
     */
    where?: TutorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorProfiles to fetch.
     */
    orderBy?: TutorProfileOrderByWithRelationInput | TutorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutorProfiles.
     */
    cursor?: TutorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutorProfiles.
     */
    distinct?: TutorProfileScalarFieldEnum | TutorProfileScalarFieldEnum[]
  }

  /**
   * TutorProfile findMany
   */
  export type TutorProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * Filter, which TutorProfiles to fetch.
     */
    where?: TutorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorProfiles to fetch.
     */
    orderBy?: TutorProfileOrderByWithRelationInput | TutorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutorProfiles.
     */
    cursor?: TutorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorProfiles.
     */
    skip?: number
    distinct?: TutorProfileScalarFieldEnum | TutorProfileScalarFieldEnum[]
  }

  /**
   * TutorProfile create
   */
  export type TutorProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a TutorProfile.
     */
    data: XOR<TutorProfileCreateInput, TutorProfileUncheckedCreateInput>
  }

  /**
   * TutorProfile createMany
   */
  export type TutorProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutorProfiles.
     */
    data: TutorProfileCreateManyInput | TutorProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutorProfile createManyAndReturn
   */
  export type TutorProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * The data used to create many TutorProfiles.
     */
    data: TutorProfileCreateManyInput | TutorProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutorProfile update
   */
  export type TutorProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a TutorProfile.
     */
    data: XOR<TutorProfileUpdateInput, TutorProfileUncheckedUpdateInput>
    /**
     * Choose, which TutorProfile to update.
     */
    where: TutorProfileWhereUniqueInput
  }

  /**
   * TutorProfile updateMany
   */
  export type TutorProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutorProfiles.
     */
    data: XOR<TutorProfileUpdateManyMutationInput, TutorProfileUncheckedUpdateManyInput>
    /**
     * Filter which TutorProfiles to update
     */
    where?: TutorProfileWhereInput
    /**
     * Limit how many TutorProfiles to update.
     */
    limit?: number
  }

  /**
   * TutorProfile updateManyAndReturn
   */
  export type TutorProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * The data used to update TutorProfiles.
     */
    data: XOR<TutorProfileUpdateManyMutationInput, TutorProfileUncheckedUpdateManyInput>
    /**
     * Filter which TutorProfiles to update
     */
    where?: TutorProfileWhereInput
    /**
     * Limit how many TutorProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutorProfile upsert
   */
  export type TutorProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the TutorProfile to update in case it exists.
     */
    where: TutorProfileWhereUniqueInput
    /**
     * In case the TutorProfile found by the `where` argument doesn't exist, create a new TutorProfile with this data.
     */
    create: XOR<TutorProfileCreateInput, TutorProfileUncheckedCreateInput>
    /**
     * In case the TutorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutorProfileUpdateInput, TutorProfileUncheckedUpdateInput>
  }

  /**
   * TutorProfile delete
   */
  export type TutorProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
    /**
     * Filter which TutorProfile to delete.
     */
    where: TutorProfileWhereUniqueInput
  }

  /**
   * TutorProfile deleteMany
   */
  export type TutorProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutorProfiles to delete
     */
    where?: TutorProfileWhereInput
    /**
     * Limit how many TutorProfiles to delete.
     */
    limit?: number
  }

  /**
   * TutorProfile.tutorAssignments
   */
  export type TutorProfile$tutorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    where?: TutorStudentWhereInput
    orderBy?: TutorStudentOrderByWithRelationInput | TutorStudentOrderByWithRelationInput[]
    cursor?: TutorStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorStudentScalarFieldEnum | TutorStudentScalarFieldEnum[]
  }

  /**
   * TutorProfile without action
   */
  export type TutorProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorProfile
     */
    select?: TutorProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorProfile
     */
    omit?: TutorProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorProfileInclude<ExtArgs> | null
  }


  /**
   * Model TutorStudent
   */

  export type AggregateTutorStudent = {
    _count: TutorStudentCountAggregateOutputType | null
    _min: TutorStudentMinAggregateOutputType | null
    _max: TutorStudentMaxAggregateOutputType | null
  }

  export type TutorStudentMinAggregateOutputType = {
    id: string | null
    tutorId: string | null
    studentId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
  }

  export type TutorStudentMaxAggregateOutputType = {
    id: string | null
    tutorId: string | null
    studentId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
  }

  export type TutorStudentCountAggregateOutputType = {
    id: number
    tutorId: number
    studentId: number
    isPrimary: number
    assignedAt: number
    _all: number
  }


  export type TutorStudentMinAggregateInputType = {
    id?: true
    tutorId?: true
    studentId?: true
    isPrimary?: true
    assignedAt?: true
  }

  export type TutorStudentMaxAggregateInputType = {
    id?: true
    tutorId?: true
    studentId?: true
    isPrimary?: true
    assignedAt?: true
  }

  export type TutorStudentCountAggregateInputType = {
    id?: true
    tutorId?: true
    studentId?: true
    isPrimary?: true
    assignedAt?: true
    _all?: true
  }

  export type TutorStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutorStudent to aggregate.
     */
    where?: TutorStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorStudents to fetch.
     */
    orderBy?: TutorStudentOrderByWithRelationInput | TutorStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutorStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutorStudents
    **/
    _count?: true | TutorStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorStudentMaxAggregateInputType
  }

  export type GetTutorStudentAggregateType<T extends TutorStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateTutorStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutorStudent[P]>
      : GetScalarType<T[P], AggregateTutorStudent[P]>
  }




  export type TutorStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorStudentWhereInput
    orderBy?: TutorStudentOrderByWithAggregationInput | TutorStudentOrderByWithAggregationInput[]
    by: TutorStudentScalarFieldEnum[] | TutorStudentScalarFieldEnum
    having?: TutorStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorStudentCountAggregateInputType | true
    _min?: TutorStudentMinAggregateInputType
    _max?: TutorStudentMaxAggregateInputType
  }

  export type TutorStudentGroupByOutputType = {
    id: string
    tutorId: string
    studentId: string
    isPrimary: boolean
    assignedAt: Date
    _count: TutorStudentCountAggregateOutputType | null
    _min: TutorStudentMinAggregateOutputType | null
    _max: TutorStudentMaxAggregateOutputType | null
  }

  type GetTutorStudentGroupByPayload<T extends TutorStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorStudentGroupByOutputType[P]>
            : GetScalarType<T[P], TutorStudentGroupByOutputType[P]>
        }
      >
    >


  export type TutorStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tutorId?: boolean
    studentId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    tutor?: boolean | TutorProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorStudent"]>

  export type TutorStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tutorId?: boolean
    studentId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    tutor?: boolean | TutorProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorStudent"]>

  export type TutorStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tutorId?: boolean
    studentId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    tutor?: boolean | TutorProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorStudent"]>

  export type TutorStudentSelectScalar = {
    id?: boolean
    tutorId?: boolean
    studentId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
  }

  export type TutorStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tutorId" | "studentId" | "isPrimary" | "assignedAt", ExtArgs["result"]["tutorStudent"]>
  export type TutorStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | TutorProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type TutorStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | TutorProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type TutorStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | TutorProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $TutorStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutorStudent"
    objects: {
      tutor: Prisma.$TutorProfilePayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tutorId: string
      studentId: string
      isPrimary: boolean
      assignedAt: Date
    }, ExtArgs["result"]["tutorStudent"]>
    composites: {}
  }

  type TutorStudentGetPayload<S extends boolean | null | undefined | TutorStudentDefaultArgs> = $Result.GetResult<Prisma.$TutorStudentPayload, S>

  type TutorStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TutorStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TutorStudentCountAggregateInputType | true
    }

  export interface TutorStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutorStudent'], meta: { name: 'TutorStudent' } }
    /**
     * Find zero or one TutorStudent that matches the filter.
     * @param {TutorStudentFindUniqueArgs} args - Arguments to find a TutorStudent
     * @example
     * // Get one TutorStudent
     * const tutorStudent = await prisma.tutorStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutorStudentFindUniqueArgs>(args: SelectSubset<T, TutorStudentFindUniqueArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TutorStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TutorStudentFindUniqueOrThrowArgs} args - Arguments to find a TutorStudent
     * @example
     * // Get one TutorStudent
     * const tutorStudent = await prisma.tutorStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutorStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, TutorStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TutorStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentFindFirstArgs} args - Arguments to find a TutorStudent
     * @example
     * // Get one TutorStudent
     * const tutorStudent = await prisma.tutorStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutorStudentFindFirstArgs>(args?: SelectSubset<T, TutorStudentFindFirstArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TutorStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentFindFirstOrThrowArgs} args - Arguments to find a TutorStudent
     * @example
     * // Get one TutorStudent
     * const tutorStudent = await prisma.tutorStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutorStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, TutorStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TutorStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutorStudents
     * const tutorStudents = await prisma.tutorStudent.findMany()
     * 
     * // Get first 10 TutorStudents
     * const tutorStudents = await prisma.tutorStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutorStudentWithIdOnly = await prisma.tutorStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutorStudentFindManyArgs>(args?: SelectSubset<T, TutorStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TutorStudent.
     * @param {TutorStudentCreateArgs} args - Arguments to create a TutorStudent.
     * @example
     * // Create one TutorStudent
     * const TutorStudent = await prisma.tutorStudent.create({
     *   data: {
     *     // ... data to create a TutorStudent
     *   }
     * })
     * 
     */
    create<T extends TutorStudentCreateArgs>(args: SelectSubset<T, TutorStudentCreateArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TutorStudents.
     * @param {TutorStudentCreateManyArgs} args - Arguments to create many TutorStudents.
     * @example
     * // Create many TutorStudents
     * const tutorStudent = await prisma.tutorStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutorStudentCreateManyArgs>(args?: SelectSubset<T, TutorStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TutorStudents and returns the data saved in the database.
     * @param {TutorStudentCreateManyAndReturnArgs} args - Arguments to create many TutorStudents.
     * @example
     * // Create many TutorStudents
     * const tutorStudent = await prisma.tutorStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TutorStudents and only return the `id`
     * const tutorStudentWithIdOnly = await prisma.tutorStudent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutorStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, TutorStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TutorStudent.
     * @param {TutorStudentDeleteArgs} args - Arguments to delete one TutorStudent.
     * @example
     * // Delete one TutorStudent
     * const TutorStudent = await prisma.tutorStudent.delete({
     *   where: {
     *     // ... filter to delete one TutorStudent
     *   }
     * })
     * 
     */
    delete<T extends TutorStudentDeleteArgs>(args: SelectSubset<T, TutorStudentDeleteArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TutorStudent.
     * @param {TutorStudentUpdateArgs} args - Arguments to update one TutorStudent.
     * @example
     * // Update one TutorStudent
     * const tutorStudent = await prisma.tutorStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutorStudentUpdateArgs>(args: SelectSubset<T, TutorStudentUpdateArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TutorStudents.
     * @param {TutorStudentDeleteManyArgs} args - Arguments to filter TutorStudents to delete.
     * @example
     * // Delete a few TutorStudents
     * const { count } = await prisma.tutorStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutorStudentDeleteManyArgs>(args?: SelectSubset<T, TutorStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutorStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutorStudents
     * const tutorStudent = await prisma.tutorStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutorStudentUpdateManyArgs>(args: SelectSubset<T, TutorStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutorStudents and returns the data updated in the database.
     * @param {TutorStudentUpdateManyAndReturnArgs} args - Arguments to update many TutorStudents.
     * @example
     * // Update many TutorStudents
     * const tutorStudent = await prisma.tutorStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TutorStudents and only return the `id`
     * const tutorStudentWithIdOnly = await prisma.tutorStudent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TutorStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, TutorStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TutorStudent.
     * @param {TutorStudentUpsertArgs} args - Arguments to update or create a TutorStudent.
     * @example
     * // Update or create a TutorStudent
     * const tutorStudent = await prisma.tutorStudent.upsert({
     *   create: {
     *     // ... data to create a TutorStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutorStudent we want to update
     *   }
     * })
     */
    upsert<T extends TutorStudentUpsertArgs>(args: SelectSubset<T, TutorStudentUpsertArgs<ExtArgs>>): Prisma__TutorStudentClient<$Result.GetResult<Prisma.$TutorStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TutorStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentCountArgs} args - Arguments to filter TutorStudents to count.
     * @example
     * // Count the number of TutorStudents
     * const count = await prisma.tutorStudent.count({
     *   where: {
     *     // ... the filter for the TutorStudents we want to count
     *   }
     * })
    **/
    count<T extends TutorStudentCountArgs>(
      args?: Subset<T, TutorStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutorStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorStudentAggregateArgs>(args: Subset<T, TutorStudentAggregateArgs>): Prisma.PrismaPromise<GetTutorStudentAggregateType<T>>

    /**
     * Group by TutorStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutorStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutorStudentGroupByArgs['orderBy'] }
        : { orderBy?: TutorStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutorStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutorStudent model
   */
  readonly fields: TutorStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutorStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutorStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutor<T extends TutorProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutorProfileDefaultArgs<ExtArgs>>): Prisma__TutorProfileClient<$Result.GetResult<Prisma.$TutorProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutorStudent model
   */
  interface TutorStudentFieldRefs {
    readonly id: FieldRef<"TutorStudent", 'String'>
    readonly tutorId: FieldRef<"TutorStudent", 'String'>
    readonly studentId: FieldRef<"TutorStudent", 'String'>
    readonly isPrimary: FieldRef<"TutorStudent", 'Boolean'>
    readonly assignedAt: FieldRef<"TutorStudent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutorStudent findUnique
   */
  export type TutorStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * Filter, which TutorStudent to fetch.
     */
    where: TutorStudentWhereUniqueInput
  }

  /**
   * TutorStudent findUniqueOrThrow
   */
  export type TutorStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * Filter, which TutorStudent to fetch.
     */
    where: TutorStudentWhereUniqueInput
  }

  /**
   * TutorStudent findFirst
   */
  export type TutorStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * Filter, which TutorStudent to fetch.
     */
    where?: TutorStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorStudents to fetch.
     */
    orderBy?: TutorStudentOrderByWithRelationInput | TutorStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutorStudents.
     */
    cursor?: TutorStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutorStudents.
     */
    distinct?: TutorStudentScalarFieldEnum | TutorStudentScalarFieldEnum[]
  }

  /**
   * TutorStudent findFirstOrThrow
   */
  export type TutorStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * Filter, which TutorStudent to fetch.
     */
    where?: TutorStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorStudents to fetch.
     */
    orderBy?: TutorStudentOrderByWithRelationInput | TutorStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutorStudents.
     */
    cursor?: TutorStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutorStudents.
     */
    distinct?: TutorStudentScalarFieldEnum | TutorStudentScalarFieldEnum[]
  }

  /**
   * TutorStudent findMany
   */
  export type TutorStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * Filter, which TutorStudents to fetch.
     */
    where?: TutorStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorStudents to fetch.
     */
    orderBy?: TutorStudentOrderByWithRelationInput | TutorStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutorStudents.
     */
    cursor?: TutorStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorStudents.
     */
    skip?: number
    distinct?: TutorStudentScalarFieldEnum | TutorStudentScalarFieldEnum[]
  }

  /**
   * TutorStudent create
   */
  export type TutorStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a TutorStudent.
     */
    data: XOR<TutorStudentCreateInput, TutorStudentUncheckedCreateInput>
  }

  /**
   * TutorStudent createMany
   */
  export type TutorStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutorStudents.
     */
    data: TutorStudentCreateManyInput | TutorStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TutorStudent createManyAndReturn
   */
  export type TutorStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * The data used to create many TutorStudents.
     */
    data: TutorStudentCreateManyInput | TutorStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutorStudent update
   */
  export type TutorStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a TutorStudent.
     */
    data: XOR<TutorStudentUpdateInput, TutorStudentUncheckedUpdateInput>
    /**
     * Choose, which TutorStudent to update.
     */
    where: TutorStudentWhereUniqueInput
  }

  /**
   * TutorStudent updateMany
   */
  export type TutorStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutorStudents.
     */
    data: XOR<TutorStudentUpdateManyMutationInput, TutorStudentUncheckedUpdateManyInput>
    /**
     * Filter which TutorStudents to update
     */
    where?: TutorStudentWhereInput
    /**
     * Limit how many TutorStudents to update.
     */
    limit?: number
  }

  /**
   * TutorStudent updateManyAndReturn
   */
  export type TutorStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * The data used to update TutorStudents.
     */
    data: XOR<TutorStudentUpdateManyMutationInput, TutorStudentUncheckedUpdateManyInput>
    /**
     * Filter which TutorStudents to update
     */
    where?: TutorStudentWhereInput
    /**
     * Limit how many TutorStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TutorStudent upsert
   */
  export type TutorStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the TutorStudent to update in case it exists.
     */
    where: TutorStudentWhereUniqueInput
    /**
     * In case the TutorStudent found by the `where` argument doesn't exist, create a new TutorStudent with this data.
     */
    create: XOR<TutorStudentCreateInput, TutorStudentUncheckedCreateInput>
    /**
     * In case the TutorStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutorStudentUpdateInput, TutorStudentUncheckedUpdateInput>
  }

  /**
   * TutorStudent delete
   */
  export type TutorStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
    /**
     * Filter which TutorStudent to delete.
     */
    where: TutorStudentWhereUniqueInput
  }

  /**
   * TutorStudent deleteMany
   */
  export type TutorStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutorStudents to delete
     */
    where?: TutorStudentWhereInput
    /**
     * Limit how many TutorStudents to delete.
     */
    limit?: number
  }

  /**
   * TutorStudent without action
   */
  export type TutorStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorStudent
     */
    select?: TutorStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TutorStudent
     */
    omit?: TutorStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorStudentInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseId: string | null
    subjectId: string | null
    type: $Enums.CertificateType | null
    issuedAt: Date | null
    fileUrl: string | null
    issuedById: string | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseId: string | null
    subjectId: string | null
    type: $Enums.CertificateType | null
    issuedAt: Date | null
    fileUrl: string | null
    issuedById: string | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    subjectId: number
    type: number
    issuedAt: number
    fileUrl: number
    issuedById: number
    metadata: number
    _all: number
  }


  export type CertificateMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    subjectId?: true
    type?: true
    issuedAt?: true
    fileUrl?: true
    issuedById?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    subjectId?: true
    type?: true
    issuedAt?: true
    fileUrl?: true
    issuedById?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    subjectId?: true
    type?: true
    issuedAt?: true
    fileUrl?: true
    issuedById?: true
    metadata?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    studentId: string
    courseId: string | null
    subjectId: string | null
    type: $Enums.CertificateType
    issuedAt: Date
    fileUrl: string | null
    issuedById: string | null
    metadata: JsonValue | null
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    subjectId?: boolean
    type?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    issuedById?: boolean
    metadata?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    subject?: boolean | Certificate$subjectArgs<ExtArgs>
    issuedBy?: boolean | Certificate$issuedByArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    subjectId?: boolean
    type?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    issuedById?: boolean
    metadata?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    subject?: boolean | Certificate$subjectArgs<ExtArgs>
    issuedBy?: boolean | Certificate$issuedByArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    subjectId?: boolean
    type?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    issuedById?: boolean
    metadata?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    subject?: boolean | Certificate$subjectArgs<ExtArgs>
    issuedBy?: boolean | Certificate$issuedByArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    subjectId?: boolean
    type?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    issuedById?: boolean
    metadata?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "subjectId" | "type" | "issuedAt" | "fileUrl" | "issuedById" | "metadata", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    subject?: boolean | Certificate$subjectArgs<ExtArgs>
    issuedBy?: boolean | Certificate$issuedByArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    subject?: boolean | Certificate$subjectArgs<ExtArgs>
    issuedBy?: boolean | Certificate$issuedByArgs<ExtArgs>
  }
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | Certificate$courseArgs<ExtArgs>
    subject?: boolean | Certificate$subjectArgs<ExtArgs>
    issuedBy?: boolean | Certificate$issuedByArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      issuedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      courseId: string | null
      subjectId: string | null
      type: $Enums.CertificateType
      issuedAt: Date
      fileUrl: string | null
      issuedById: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends Certificate$courseArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subject<T extends Certificate$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issuedBy<T extends Certificate$issuedByArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$issuedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly studentId: FieldRef<"Certificate", 'String'>
    readonly courseId: FieldRef<"Certificate", 'String'>
    readonly subjectId: FieldRef<"Certificate", 'String'>
    readonly type: FieldRef<"Certificate", 'CertificateType'>
    readonly issuedAt: FieldRef<"Certificate", 'DateTime'>
    readonly fileUrl: FieldRef<"Certificate", 'String'>
    readonly issuedById: FieldRef<"Certificate", 'String'>
    readonly metadata: FieldRef<"Certificate", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number
  }

  /**
   * Certificate.course
   */
  export type Certificate$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Certificate.subject
   */
  export type Certificate$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Certificate.issuedBy
   */
  export type Certificate$issuedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model FeeSchedule
   */

  export type AggregateFeeSchedule = {
    _count: FeeScheduleCountAggregateOutputType | null
    _avg: FeeScheduleAvgAggregateOutputType | null
    _sum: FeeScheduleSumAggregateOutputType | null
    _min: FeeScheduleMinAggregateOutputType | null
    _max: FeeScheduleMaxAggregateOutputType | null
  }

  export type FeeScheduleAvgAggregateOutputType = {
    totalAmount: Decimal | null
    installments: number | null
  }

  export type FeeScheduleSumAggregateOutputType = {
    totalAmount: Decimal | null
    installments: number | null
  }

  export type FeeScheduleMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    careerId: string | null
    name: string | null
    totalAmount: Decimal | null
    currency: string | null
    installments: number | null
    frequency: string | null
    createdAt: Date | null
  }

  export type FeeScheduleMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    careerId: string | null
    name: string | null
    totalAmount: Decimal | null
    currency: string | null
    installments: number | null
    frequency: string | null
    createdAt: Date | null
  }

  export type FeeScheduleCountAggregateOutputType = {
    id: number
    institutionId: number
    careerId: number
    name: number
    totalAmount: number
    currency: number
    installments: number
    frequency: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type FeeScheduleAvgAggregateInputType = {
    totalAmount?: true
    installments?: true
  }

  export type FeeScheduleSumAggregateInputType = {
    totalAmount?: true
    installments?: true
  }

  export type FeeScheduleMinAggregateInputType = {
    id?: true
    institutionId?: true
    careerId?: true
    name?: true
    totalAmount?: true
    currency?: true
    installments?: true
    frequency?: true
    createdAt?: true
  }

  export type FeeScheduleMaxAggregateInputType = {
    id?: true
    institutionId?: true
    careerId?: true
    name?: true
    totalAmount?: true
    currency?: true
    installments?: true
    frequency?: true
    createdAt?: true
  }

  export type FeeScheduleCountAggregateInputType = {
    id?: true
    institutionId?: true
    careerId?: true
    name?: true
    totalAmount?: true
    currency?: true
    installments?: true
    frequency?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type FeeScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeSchedule to aggregate.
     */
    where?: FeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeSchedules to fetch.
     */
    orderBy?: FeeScheduleOrderByWithRelationInput | FeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeSchedules
    **/
    _count?: true | FeeScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeScheduleMaxAggregateInputType
  }

  export type GetFeeScheduleAggregateType<T extends FeeScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeSchedule[P]>
      : GetScalarType<T[P], AggregateFeeSchedule[P]>
  }




  export type FeeScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeScheduleWhereInput
    orderBy?: FeeScheduleOrderByWithAggregationInput | FeeScheduleOrderByWithAggregationInput[]
    by: FeeScheduleScalarFieldEnum[] | FeeScheduleScalarFieldEnum
    having?: FeeScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeScheduleCountAggregateInputType | true
    _avg?: FeeScheduleAvgAggregateInputType
    _sum?: FeeScheduleSumAggregateInputType
    _min?: FeeScheduleMinAggregateInputType
    _max?: FeeScheduleMaxAggregateInputType
  }

  export type FeeScheduleGroupByOutputType = {
    id: string
    institutionId: string
    careerId: string | null
    name: string
    totalAmount: Decimal
    currency: string
    installments: number
    frequency: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: FeeScheduleCountAggregateOutputType | null
    _avg: FeeScheduleAvgAggregateOutputType | null
    _sum: FeeScheduleSumAggregateOutputType | null
    _min: FeeScheduleMinAggregateOutputType | null
    _max: FeeScheduleMaxAggregateOutputType | null
  }

  type GetFeeScheduleGroupByPayload<T extends FeeScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], FeeScheduleGroupByOutputType[P]>
        }
      >
    >


  export type FeeScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    careerId?: boolean
    name?: boolean
    totalAmount?: boolean
    currency?: boolean
    installments?: boolean
    frequency?: boolean
    metadata?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | FeeSchedule$careerArgs<ExtArgs>
    installmentsList?: boolean | FeeSchedule$installmentsListArgs<ExtArgs>
    paymentPlan?: boolean | FeeSchedule$paymentPlanArgs<ExtArgs>
    _count?: boolean | FeeScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeSchedule"]>

  export type FeeScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    careerId?: boolean
    name?: boolean
    totalAmount?: boolean
    currency?: boolean
    installments?: boolean
    frequency?: boolean
    metadata?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | FeeSchedule$careerArgs<ExtArgs>
  }, ExtArgs["result"]["feeSchedule"]>

  export type FeeScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    careerId?: boolean
    name?: boolean
    totalAmount?: boolean
    currency?: boolean
    installments?: boolean
    frequency?: boolean
    metadata?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | FeeSchedule$careerArgs<ExtArgs>
  }, ExtArgs["result"]["feeSchedule"]>

  export type FeeScheduleSelectScalar = {
    id?: boolean
    institutionId?: boolean
    careerId?: boolean
    name?: boolean
    totalAmount?: boolean
    currency?: boolean
    installments?: boolean
    frequency?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type FeeScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "careerId" | "name" | "totalAmount" | "currency" | "installments" | "frequency" | "metadata" | "createdAt", ExtArgs["result"]["feeSchedule"]>
  export type FeeScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | FeeSchedule$careerArgs<ExtArgs>
    installmentsList?: boolean | FeeSchedule$installmentsListArgs<ExtArgs>
    paymentPlan?: boolean | FeeSchedule$paymentPlanArgs<ExtArgs>
    _count?: boolean | FeeScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | FeeSchedule$careerArgs<ExtArgs>
  }
  export type FeeScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    career?: boolean | FeeSchedule$careerArgs<ExtArgs>
  }

  export type $FeeSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeSchedule"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      career: Prisma.$CareerPayload<ExtArgs> | null
      installmentsList: Prisma.$FeeInstallmentPayload<ExtArgs>[]
      paymentPlan: Prisma.$PaymentPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      careerId: string | null
      name: string
      totalAmount: Prisma.Decimal
      currency: string
      installments: number
      frequency: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["feeSchedule"]>
    composites: {}
  }

  type FeeScheduleGetPayload<S extends boolean | null | undefined | FeeScheduleDefaultArgs> = $Result.GetResult<Prisma.$FeeSchedulePayload, S>

  type FeeScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeScheduleCountAggregateInputType | true
    }

  export interface FeeScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeSchedule'], meta: { name: 'FeeSchedule' } }
    /**
     * Find zero or one FeeSchedule that matches the filter.
     * @param {FeeScheduleFindUniqueArgs} args - Arguments to find a FeeSchedule
     * @example
     * // Get one FeeSchedule
     * const feeSchedule = await prisma.feeSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeScheduleFindUniqueArgs>(args: SelectSubset<T, FeeScheduleFindUniqueArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeScheduleFindUniqueOrThrowArgs} args - Arguments to find a FeeSchedule
     * @example
     * // Get one FeeSchedule
     * const feeSchedule = await prisma.feeSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleFindFirstArgs} args - Arguments to find a FeeSchedule
     * @example
     * // Get one FeeSchedule
     * const feeSchedule = await prisma.feeSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeScheduleFindFirstArgs>(args?: SelectSubset<T, FeeScheduleFindFirstArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleFindFirstOrThrowArgs} args - Arguments to find a FeeSchedule
     * @example
     * // Get one FeeSchedule
     * const feeSchedule = await prisma.feeSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeSchedules
     * const feeSchedules = await prisma.feeSchedule.findMany()
     * 
     * // Get first 10 FeeSchedules
     * const feeSchedules = await prisma.feeSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeScheduleWithIdOnly = await prisma.feeSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeScheduleFindManyArgs>(args?: SelectSubset<T, FeeScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeSchedule.
     * @param {FeeScheduleCreateArgs} args - Arguments to create a FeeSchedule.
     * @example
     * // Create one FeeSchedule
     * const FeeSchedule = await prisma.feeSchedule.create({
     *   data: {
     *     // ... data to create a FeeSchedule
     *   }
     * })
     * 
     */
    create<T extends FeeScheduleCreateArgs>(args: SelectSubset<T, FeeScheduleCreateArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeSchedules.
     * @param {FeeScheduleCreateManyArgs} args - Arguments to create many FeeSchedules.
     * @example
     * // Create many FeeSchedules
     * const feeSchedule = await prisma.feeSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeScheduleCreateManyArgs>(args?: SelectSubset<T, FeeScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeSchedules and returns the data saved in the database.
     * @param {FeeScheduleCreateManyAndReturnArgs} args - Arguments to create many FeeSchedules.
     * @example
     * // Create many FeeSchedules
     * const feeSchedule = await prisma.feeSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeSchedules and only return the `id`
     * const feeScheduleWithIdOnly = await prisma.feeSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeSchedule.
     * @param {FeeScheduleDeleteArgs} args - Arguments to delete one FeeSchedule.
     * @example
     * // Delete one FeeSchedule
     * const FeeSchedule = await prisma.feeSchedule.delete({
     *   where: {
     *     // ... filter to delete one FeeSchedule
     *   }
     * })
     * 
     */
    delete<T extends FeeScheduleDeleteArgs>(args: SelectSubset<T, FeeScheduleDeleteArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeSchedule.
     * @param {FeeScheduleUpdateArgs} args - Arguments to update one FeeSchedule.
     * @example
     * // Update one FeeSchedule
     * const feeSchedule = await prisma.feeSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeScheduleUpdateArgs>(args: SelectSubset<T, FeeScheduleUpdateArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeSchedules.
     * @param {FeeScheduleDeleteManyArgs} args - Arguments to filter FeeSchedules to delete.
     * @example
     * // Delete a few FeeSchedules
     * const { count } = await prisma.feeSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeScheduleDeleteManyArgs>(args?: SelectSubset<T, FeeScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeSchedules
     * const feeSchedule = await prisma.feeSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeScheduleUpdateManyArgs>(args: SelectSubset<T, FeeScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeSchedules and returns the data updated in the database.
     * @param {FeeScheduleUpdateManyAndReturnArgs} args - Arguments to update many FeeSchedules.
     * @example
     * // Update many FeeSchedules
     * const feeSchedule = await prisma.feeSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeSchedules and only return the `id`
     * const feeScheduleWithIdOnly = await prisma.feeSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeSchedule.
     * @param {FeeScheduleUpsertArgs} args - Arguments to update or create a FeeSchedule.
     * @example
     * // Update or create a FeeSchedule
     * const feeSchedule = await prisma.feeSchedule.upsert({
     *   create: {
     *     // ... data to create a FeeSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeSchedule we want to update
     *   }
     * })
     */
    upsert<T extends FeeScheduleUpsertArgs>(args: SelectSubset<T, FeeScheduleUpsertArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleCountArgs} args - Arguments to filter FeeSchedules to count.
     * @example
     * // Count the number of FeeSchedules
     * const count = await prisma.feeSchedule.count({
     *   where: {
     *     // ... the filter for the FeeSchedules we want to count
     *   }
     * })
    **/
    count<T extends FeeScheduleCountArgs>(
      args?: Subset<T, FeeScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeScheduleAggregateArgs>(args: Subset<T, FeeScheduleAggregateArgs>): Prisma.PrismaPromise<GetFeeScheduleAggregateType<T>>

    /**
     * Group by FeeSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeScheduleGroupByArgs['orderBy'] }
        : { orderBy?: FeeScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeSchedule model
   */
  readonly fields: FeeScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    career<T extends FeeSchedule$careerArgs<ExtArgs> = {}>(args?: Subset<T, FeeSchedule$careerArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    installmentsList<T extends FeeSchedule$installmentsListArgs<ExtArgs> = {}>(args?: Subset<T, FeeSchedule$installmentsListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentPlan<T extends FeeSchedule$paymentPlanArgs<ExtArgs> = {}>(args?: Subset<T, FeeSchedule$paymentPlanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeSchedule model
   */
  interface FeeScheduleFieldRefs {
    readonly id: FieldRef<"FeeSchedule", 'String'>
    readonly institutionId: FieldRef<"FeeSchedule", 'String'>
    readonly careerId: FieldRef<"FeeSchedule", 'String'>
    readonly name: FieldRef<"FeeSchedule", 'String'>
    readonly totalAmount: FieldRef<"FeeSchedule", 'Decimal'>
    readonly currency: FieldRef<"FeeSchedule", 'String'>
    readonly installments: FieldRef<"FeeSchedule", 'Int'>
    readonly frequency: FieldRef<"FeeSchedule", 'String'>
    readonly metadata: FieldRef<"FeeSchedule", 'Json'>
    readonly createdAt: FieldRef<"FeeSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeSchedule findUnique
   */
  export type FeeScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FeeSchedule to fetch.
     */
    where: FeeScheduleWhereUniqueInput
  }

  /**
   * FeeSchedule findUniqueOrThrow
   */
  export type FeeScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FeeSchedule to fetch.
     */
    where: FeeScheduleWhereUniqueInput
  }

  /**
   * FeeSchedule findFirst
   */
  export type FeeScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FeeSchedule to fetch.
     */
    where?: FeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeSchedules to fetch.
     */
    orderBy?: FeeScheduleOrderByWithRelationInput | FeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeSchedules.
     */
    cursor?: FeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeSchedules.
     */
    distinct?: FeeScheduleScalarFieldEnum | FeeScheduleScalarFieldEnum[]
  }

  /**
   * FeeSchedule findFirstOrThrow
   */
  export type FeeScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FeeSchedule to fetch.
     */
    where?: FeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeSchedules to fetch.
     */
    orderBy?: FeeScheduleOrderByWithRelationInput | FeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeSchedules.
     */
    cursor?: FeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeSchedules.
     */
    distinct?: FeeScheduleScalarFieldEnum | FeeScheduleScalarFieldEnum[]
  }

  /**
   * FeeSchedule findMany
   */
  export type FeeScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which FeeSchedules to fetch.
     */
    where?: FeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeSchedules to fetch.
     */
    orderBy?: FeeScheduleOrderByWithRelationInput | FeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeSchedules.
     */
    cursor?: FeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeSchedules.
     */
    skip?: number
    distinct?: FeeScheduleScalarFieldEnum | FeeScheduleScalarFieldEnum[]
  }

  /**
   * FeeSchedule create
   */
  export type FeeScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeSchedule.
     */
    data: XOR<FeeScheduleCreateInput, FeeScheduleUncheckedCreateInput>
  }

  /**
   * FeeSchedule createMany
   */
  export type FeeScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeSchedules.
     */
    data: FeeScheduleCreateManyInput | FeeScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeSchedule createManyAndReturn
   */
  export type FeeScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many FeeSchedules.
     */
    data: FeeScheduleCreateManyInput | FeeScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeSchedule update
   */
  export type FeeScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeSchedule.
     */
    data: XOR<FeeScheduleUpdateInput, FeeScheduleUncheckedUpdateInput>
    /**
     * Choose, which FeeSchedule to update.
     */
    where: FeeScheduleWhereUniqueInput
  }

  /**
   * FeeSchedule updateMany
   */
  export type FeeScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeSchedules.
     */
    data: XOR<FeeScheduleUpdateManyMutationInput, FeeScheduleUncheckedUpdateManyInput>
    /**
     * Filter which FeeSchedules to update
     */
    where?: FeeScheduleWhereInput
    /**
     * Limit how many FeeSchedules to update.
     */
    limit?: number
  }

  /**
   * FeeSchedule updateManyAndReturn
   */
  export type FeeScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * The data used to update FeeSchedules.
     */
    data: XOR<FeeScheduleUpdateManyMutationInput, FeeScheduleUncheckedUpdateManyInput>
    /**
     * Filter which FeeSchedules to update
     */
    where?: FeeScheduleWhereInput
    /**
     * Limit how many FeeSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeSchedule upsert
   */
  export type FeeScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeSchedule to update in case it exists.
     */
    where: FeeScheduleWhereUniqueInput
    /**
     * In case the FeeSchedule found by the `where` argument doesn't exist, create a new FeeSchedule with this data.
     */
    create: XOR<FeeScheduleCreateInput, FeeScheduleUncheckedCreateInput>
    /**
     * In case the FeeSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeScheduleUpdateInput, FeeScheduleUncheckedUpdateInput>
  }

  /**
   * FeeSchedule delete
   */
  export type FeeScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
    /**
     * Filter which FeeSchedule to delete.
     */
    where: FeeScheduleWhereUniqueInput
  }

  /**
   * FeeSchedule deleteMany
   */
  export type FeeScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeSchedules to delete
     */
    where?: FeeScheduleWhereInput
    /**
     * Limit how many FeeSchedules to delete.
     */
    limit?: number
  }

  /**
   * FeeSchedule.career
   */
  export type FeeSchedule$careerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    where?: CareerWhereInput
  }

  /**
   * FeeSchedule.installmentsList
   */
  export type FeeSchedule$installmentsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    where?: FeeInstallmentWhereInput
    orderBy?: FeeInstallmentOrderByWithRelationInput | FeeInstallmentOrderByWithRelationInput[]
    cursor?: FeeInstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeInstallmentScalarFieldEnum | FeeInstallmentScalarFieldEnum[]
  }

  /**
   * FeeSchedule.paymentPlan
   */
  export type FeeSchedule$paymentPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    where?: PaymentPlanWhereInput
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    cursor?: PaymentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * FeeSchedule without action
   */
  export type FeeScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeSchedule
     */
    select?: FeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeSchedule
     */
    omit?: FeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeScheduleInclude<ExtArgs> | null
  }


  /**
   * Model FeeInstallment
   */

  export type AggregateFeeInstallment = {
    _count: FeeInstallmentCountAggregateOutputType | null
    _avg: FeeInstallmentAvgAggregateOutputType | null
    _sum: FeeInstallmentSumAggregateOutputType | null
    _min: FeeInstallmentMinAggregateOutputType | null
    _max: FeeInstallmentMaxAggregateOutputType | null
  }

  export type FeeInstallmentAvgAggregateOutputType = {
    sequence: number | null
    amount: Decimal | null
  }

  export type FeeInstallmentSumAggregateOutputType = {
    sequence: number | null
    amount: Decimal | null
  }

  export type FeeInstallmentMinAggregateOutputType = {
    id: string | null
    feeScheduleId: string | null
    sequence: number | null
    dueDate: Date | null
    amount: Decimal | null
    createdAt: Date | null
  }

  export type FeeInstallmentMaxAggregateOutputType = {
    id: string | null
    feeScheduleId: string | null
    sequence: number | null
    dueDate: Date | null
    amount: Decimal | null
    createdAt: Date | null
  }

  export type FeeInstallmentCountAggregateOutputType = {
    id: number
    feeScheduleId: number
    sequence: number
    dueDate: number
    amount: number
    createdAt: number
    _all: number
  }


  export type FeeInstallmentAvgAggregateInputType = {
    sequence?: true
    amount?: true
  }

  export type FeeInstallmentSumAggregateInputType = {
    sequence?: true
    amount?: true
  }

  export type FeeInstallmentMinAggregateInputType = {
    id?: true
    feeScheduleId?: true
    sequence?: true
    dueDate?: true
    amount?: true
    createdAt?: true
  }

  export type FeeInstallmentMaxAggregateInputType = {
    id?: true
    feeScheduleId?: true
    sequence?: true
    dueDate?: true
    amount?: true
    createdAt?: true
  }

  export type FeeInstallmentCountAggregateInputType = {
    id?: true
    feeScheduleId?: true
    sequence?: true
    dueDate?: true
    amount?: true
    createdAt?: true
    _all?: true
  }

  export type FeeInstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeInstallment to aggregate.
     */
    where?: FeeInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeInstallments to fetch.
     */
    orderBy?: FeeInstallmentOrderByWithRelationInput | FeeInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeInstallments
    **/
    _count?: true | FeeInstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeInstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeInstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeInstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeInstallmentMaxAggregateInputType
  }

  export type GetFeeInstallmentAggregateType<T extends FeeInstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeInstallment[P]>
      : GetScalarType<T[P], AggregateFeeInstallment[P]>
  }




  export type FeeInstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeInstallmentWhereInput
    orderBy?: FeeInstallmentOrderByWithAggregationInput | FeeInstallmentOrderByWithAggregationInput[]
    by: FeeInstallmentScalarFieldEnum[] | FeeInstallmentScalarFieldEnum
    having?: FeeInstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeInstallmentCountAggregateInputType | true
    _avg?: FeeInstallmentAvgAggregateInputType
    _sum?: FeeInstallmentSumAggregateInputType
    _min?: FeeInstallmentMinAggregateInputType
    _max?: FeeInstallmentMaxAggregateInputType
  }

  export type FeeInstallmentGroupByOutputType = {
    id: string
    feeScheduleId: string
    sequence: number
    dueDate: Date
    amount: Decimal
    createdAt: Date
    _count: FeeInstallmentCountAggregateOutputType | null
    _avg: FeeInstallmentAvgAggregateOutputType | null
    _sum: FeeInstallmentSumAggregateOutputType | null
    _min: FeeInstallmentMinAggregateOutputType | null
    _max: FeeInstallmentMaxAggregateOutputType | null
  }

  type GetFeeInstallmentGroupByPayload<T extends FeeInstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeInstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeInstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeInstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], FeeInstallmentGroupByOutputType[P]>
        }
      >
    >


  export type FeeInstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeScheduleId?: boolean
    sequence?: boolean
    dueDate?: boolean
    amount?: boolean
    createdAt?: boolean
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
    studentPayments?: boolean | FeeInstallment$studentPaymentsArgs<ExtArgs>
    _count?: boolean | FeeInstallmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeInstallment"]>

  export type FeeInstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeScheduleId?: boolean
    sequence?: boolean
    dueDate?: boolean
    amount?: boolean
    createdAt?: boolean
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeInstallment"]>

  export type FeeInstallmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeScheduleId?: boolean
    sequence?: boolean
    dueDate?: boolean
    amount?: boolean
    createdAt?: boolean
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeInstallment"]>

  export type FeeInstallmentSelectScalar = {
    id?: boolean
    feeScheduleId?: boolean
    sequence?: boolean
    dueDate?: boolean
    amount?: boolean
    createdAt?: boolean
  }

  export type FeeInstallmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feeScheduleId" | "sequence" | "dueDate" | "amount" | "createdAt", ExtArgs["result"]["feeInstallment"]>
  export type FeeInstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
    studentPayments?: boolean | FeeInstallment$studentPaymentsArgs<ExtArgs>
    _count?: boolean | FeeInstallmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeInstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }
  export type FeeInstallmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }

  export type $FeeInstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeInstallment"
    objects: {
      feeSchedule: Prisma.$FeeSchedulePayload<ExtArgs>
      studentPayments: Prisma.$StudentPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feeScheduleId: string
      sequence: number
      dueDate: Date
      amount: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["feeInstallment"]>
    composites: {}
  }

  type FeeInstallmentGetPayload<S extends boolean | null | undefined | FeeInstallmentDefaultArgs> = $Result.GetResult<Prisma.$FeeInstallmentPayload, S>

  type FeeInstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeInstallmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeInstallmentCountAggregateInputType | true
    }

  export interface FeeInstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeInstallment'], meta: { name: 'FeeInstallment' } }
    /**
     * Find zero or one FeeInstallment that matches the filter.
     * @param {FeeInstallmentFindUniqueArgs} args - Arguments to find a FeeInstallment
     * @example
     * // Get one FeeInstallment
     * const feeInstallment = await prisma.feeInstallment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeInstallmentFindUniqueArgs>(args: SelectSubset<T, FeeInstallmentFindUniqueArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeInstallment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeInstallmentFindUniqueOrThrowArgs} args - Arguments to find a FeeInstallment
     * @example
     * // Get one FeeInstallment
     * const feeInstallment = await prisma.feeInstallment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeInstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeInstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeInstallment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentFindFirstArgs} args - Arguments to find a FeeInstallment
     * @example
     * // Get one FeeInstallment
     * const feeInstallment = await prisma.feeInstallment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeInstallmentFindFirstArgs>(args?: SelectSubset<T, FeeInstallmentFindFirstArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeInstallment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentFindFirstOrThrowArgs} args - Arguments to find a FeeInstallment
     * @example
     * // Get one FeeInstallment
     * const feeInstallment = await prisma.feeInstallment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeInstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeInstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeInstallments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeInstallments
     * const feeInstallments = await prisma.feeInstallment.findMany()
     * 
     * // Get first 10 FeeInstallments
     * const feeInstallments = await prisma.feeInstallment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeInstallmentWithIdOnly = await prisma.feeInstallment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeInstallmentFindManyArgs>(args?: SelectSubset<T, FeeInstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeInstallment.
     * @param {FeeInstallmentCreateArgs} args - Arguments to create a FeeInstallment.
     * @example
     * // Create one FeeInstallment
     * const FeeInstallment = await prisma.feeInstallment.create({
     *   data: {
     *     // ... data to create a FeeInstallment
     *   }
     * })
     * 
     */
    create<T extends FeeInstallmentCreateArgs>(args: SelectSubset<T, FeeInstallmentCreateArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeInstallments.
     * @param {FeeInstallmentCreateManyArgs} args - Arguments to create many FeeInstallments.
     * @example
     * // Create many FeeInstallments
     * const feeInstallment = await prisma.feeInstallment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeInstallmentCreateManyArgs>(args?: SelectSubset<T, FeeInstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeInstallments and returns the data saved in the database.
     * @param {FeeInstallmentCreateManyAndReturnArgs} args - Arguments to create many FeeInstallments.
     * @example
     * // Create many FeeInstallments
     * const feeInstallment = await prisma.feeInstallment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeInstallments and only return the `id`
     * const feeInstallmentWithIdOnly = await prisma.feeInstallment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeInstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeInstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeInstallment.
     * @param {FeeInstallmentDeleteArgs} args - Arguments to delete one FeeInstallment.
     * @example
     * // Delete one FeeInstallment
     * const FeeInstallment = await prisma.feeInstallment.delete({
     *   where: {
     *     // ... filter to delete one FeeInstallment
     *   }
     * })
     * 
     */
    delete<T extends FeeInstallmentDeleteArgs>(args: SelectSubset<T, FeeInstallmentDeleteArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeInstallment.
     * @param {FeeInstallmentUpdateArgs} args - Arguments to update one FeeInstallment.
     * @example
     * // Update one FeeInstallment
     * const feeInstallment = await prisma.feeInstallment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeInstallmentUpdateArgs>(args: SelectSubset<T, FeeInstallmentUpdateArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeInstallments.
     * @param {FeeInstallmentDeleteManyArgs} args - Arguments to filter FeeInstallments to delete.
     * @example
     * // Delete a few FeeInstallments
     * const { count } = await prisma.feeInstallment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeInstallmentDeleteManyArgs>(args?: SelectSubset<T, FeeInstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeInstallments
     * const feeInstallment = await prisma.feeInstallment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeInstallmentUpdateManyArgs>(args: SelectSubset<T, FeeInstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeInstallments and returns the data updated in the database.
     * @param {FeeInstallmentUpdateManyAndReturnArgs} args - Arguments to update many FeeInstallments.
     * @example
     * // Update many FeeInstallments
     * const feeInstallment = await prisma.feeInstallment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeInstallments and only return the `id`
     * const feeInstallmentWithIdOnly = await prisma.feeInstallment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeInstallmentUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeInstallmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeInstallment.
     * @param {FeeInstallmentUpsertArgs} args - Arguments to update or create a FeeInstallment.
     * @example
     * // Update or create a FeeInstallment
     * const feeInstallment = await prisma.feeInstallment.upsert({
     *   create: {
     *     // ... data to create a FeeInstallment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeInstallment we want to update
     *   }
     * })
     */
    upsert<T extends FeeInstallmentUpsertArgs>(args: SelectSubset<T, FeeInstallmentUpsertArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentCountArgs} args - Arguments to filter FeeInstallments to count.
     * @example
     * // Count the number of FeeInstallments
     * const count = await prisma.feeInstallment.count({
     *   where: {
     *     // ... the filter for the FeeInstallments we want to count
     *   }
     * })
    **/
    count<T extends FeeInstallmentCountArgs>(
      args?: Subset<T, FeeInstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeInstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeInstallmentAggregateArgs>(args: Subset<T, FeeInstallmentAggregateArgs>): Prisma.PrismaPromise<GetFeeInstallmentAggregateType<T>>

    /**
     * Group by FeeInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeInstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeInstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeInstallmentGroupByArgs['orderBy'] }
        : { orderBy?: FeeInstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeInstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeInstallment model
   */
  readonly fields: FeeInstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeInstallment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeInstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeSchedule<T extends FeeScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeScheduleDefaultArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentPayments<T extends FeeInstallment$studentPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, FeeInstallment$studentPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeInstallment model
   */
  interface FeeInstallmentFieldRefs {
    readonly id: FieldRef<"FeeInstallment", 'String'>
    readonly feeScheduleId: FieldRef<"FeeInstallment", 'String'>
    readonly sequence: FieldRef<"FeeInstallment", 'Int'>
    readonly dueDate: FieldRef<"FeeInstallment", 'DateTime'>
    readonly amount: FieldRef<"FeeInstallment", 'Decimal'>
    readonly createdAt: FieldRef<"FeeInstallment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeInstallment findUnique
   */
  export type FeeInstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which FeeInstallment to fetch.
     */
    where: FeeInstallmentWhereUniqueInput
  }

  /**
   * FeeInstallment findUniqueOrThrow
   */
  export type FeeInstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which FeeInstallment to fetch.
     */
    where: FeeInstallmentWhereUniqueInput
  }

  /**
   * FeeInstallment findFirst
   */
  export type FeeInstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which FeeInstallment to fetch.
     */
    where?: FeeInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeInstallments to fetch.
     */
    orderBy?: FeeInstallmentOrderByWithRelationInput | FeeInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeInstallments.
     */
    cursor?: FeeInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeInstallments.
     */
    distinct?: FeeInstallmentScalarFieldEnum | FeeInstallmentScalarFieldEnum[]
  }

  /**
   * FeeInstallment findFirstOrThrow
   */
  export type FeeInstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which FeeInstallment to fetch.
     */
    where?: FeeInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeInstallments to fetch.
     */
    orderBy?: FeeInstallmentOrderByWithRelationInput | FeeInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeInstallments.
     */
    cursor?: FeeInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeInstallments.
     */
    distinct?: FeeInstallmentScalarFieldEnum | FeeInstallmentScalarFieldEnum[]
  }

  /**
   * FeeInstallment findMany
   */
  export type FeeInstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which FeeInstallments to fetch.
     */
    where?: FeeInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeInstallments to fetch.
     */
    orderBy?: FeeInstallmentOrderByWithRelationInput | FeeInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeInstallments.
     */
    cursor?: FeeInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeInstallments.
     */
    skip?: number
    distinct?: FeeInstallmentScalarFieldEnum | FeeInstallmentScalarFieldEnum[]
  }

  /**
   * FeeInstallment create
   */
  export type FeeInstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeInstallment.
     */
    data: XOR<FeeInstallmentCreateInput, FeeInstallmentUncheckedCreateInput>
  }

  /**
   * FeeInstallment createMany
   */
  export type FeeInstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeInstallments.
     */
    data: FeeInstallmentCreateManyInput | FeeInstallmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeInstallment createManyAndReturn
   */
  export type FeeInstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * The data used to create many FeeInstallments.
     */
    data: FeeInstallmentCreateManyInput | FeeInstallmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeInstallment update
   */
  export type FeeInstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeInstallment.
     */
    data: XOR<FeeInstallmentUpdateInput, FeeInstallmentUncheckedUpdateInput>
    /**
     * Choose, which FeeInstallment to update.
     */
    where: FeeInstallmentWhereUniqueInput
  }

  /**
   * FeeInstallment updateMany
   */
  export type FeeInstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeInstallments.
     */
    data: XOR<FeeInstallmentUpdateManyMutationInput, FeeInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which FeeInstallments to update
     */
    where?: FeeInstallmentWhereInput
    /**
     * Limit how many FeeInstallments to update.
     */
    limit?: number
  }

  /**
   * FeeInstallment updateManyAndReturn
   */
  export type FeeInstallmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * The data used to update FeeInstallments.
     */
    data: XOR<FeeInstallmentUpdateManyMutationInput, FeeInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which FeeInstallments to update
     */
    where?: FeeInstallmentWhereInput
    /**
     * Limit how many FeeInstallments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeInstallment upsert
   */
  export type FeeInstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeInstallment to update in case it exists.
     */
    where: FeeInstallmentWhereUniqueInput
    /**
     * In case the FeeInstallment found by the `where` argument doesn't exist, create a new FeeInstallment with this data.
     */
    create: XOR<FeeInstallmentCreateInput, FeeInstallmentUncheckedCreateInput>
    /**
     * In case the FeeInstallment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeInstallmentUpdateInput, FeeInstallmentUncheckedUpdateInput>
  }

  /**
   * FeeInstallment delete
   */
  export type FeeInstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    /**
     * Filter which FeeInstallment to delete.
     */
    where: FeeInstallmentWhereUniqueInput
  }

  /**
   * FeeInstallment deleteMany
   */
  export type FeeInstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeInstallments to delete
     */
    where?: FeeInstallmentWhereInput
    /**
     * Limit how many FeeInstallments to delete.
     */
    limit?: number
  }

  /**
   * FeeInstallment.studentPayments
   */
  export type FeeInstallment$studentPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    cursor?: StudentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * FeeInstallment without action
   */
  export type FeeInstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
  }


  /**
   * Model StudentPayment
   */

  export type AggregateStudentPayment = {
    _count: StudentPaymentCountAggregateOutputType | null
    _avg: StudentPaymentAvgAggregateOutputType | null
    _sum: StudentPaymentSumAggregateOutputType | null
    _min: StudentPaymentMinAggregateOutputType | null
    _max: StudentPaymentMaxAggregateOutputType | null
  }

  export type StudentPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type StudentPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type StudentPaymentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    institutionId: string | null
    feeInstallmentId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    reference: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type StudentPaymentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    institutionId: string | null
    feeInstallmentId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    reference: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type StudentPaymentCountAggregateOutputType = {
    id: number
    studentId: number
    institutionId: number
    feeInstallmentId: number
    amount: number
    currency: number
    method: number
    status: number
    reference: number
    gatewayData: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type StudentPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type StudentPaymentSumAggregateInputType = {
    amount?: true
  }

  export type StudentPaymentMinAggregateInputType = {
    id?: true
    studentId?: true
    institutionId?: true
    feeInstallmentId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    paidAt?: true
    createdAt?: true
  }

  export type StudentPaymentMaxAggregateInputType = {
    id?: true
    studentId?: true
    institutionId?: true
    feeInstallmentId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    paidAt?: true
    createdAt?: true
  }

  export type StudentPaymentCountAggregateInputType = {
    id?: true
    studentId?: true
    institutionId?: true
    feeInstallmentId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    gatewayData?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type StudentPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentPayment to aggregate.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentPayments
    **/
    _count?: true | StudentPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentPaymentMaxAggregateInputType
  }

  export type GetStudentPaymentAggregateType<T extends StudentPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentPayment[P]>
      : GetScalarType<T[P], AggregateStudentPayment[P]>
  }




  export type StudentPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentPaymentWhereInput
    orderBy?: StudentPaymentOrderByWithAggregationInput | StudentPaymentOrderByWithAggregationInput[]
    by: StudentPaymentScalarFieldEnum[] | StudentPaymentScalarFieldEnum
    having?: StudentPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentPaymentCountAggregateInputType | true
    _avg?: StudentPaymentAvgAggregateInputType
    _sum?: StudentPaymentSumAggregateInputType
    _min?: StudentPaymentMinAggregateInputType
    _max?: StudentPaymentMaxAggregateInputType
  }

  export type StudentPaymentGroupByOutputType = {
    id: string
    studentId: string
    institutionId: string
    feeInstallmentId: string | null
    amount: Decimal
    currency: string
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    reference: string | null
    gatewayData: JsonValue | null
    paidAt: Date | null
    createdAt: Date
    _count: StudentPaymentCountAggregateOutputType | null
    _avg: StudentPaymentAvgAggregateOutputType | null
    _sum: StudentPaymentSumAggregateOutputType | null
    _min: StudentPaymentMinAggregateOutputType | null
    _max: StudentPaymentMaxAggregateOutputType | null
  }

  type GetStudentPaymentGroupByPayload<T extends StudentPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentPaymentGroupByOutputType[P]>
        }
      >
    >


  export type StudentPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    institutionId?: boolean
    feeInstallmentId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    gatewayData?: boolean
    paidAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    feeInstallment?: boolean | StudentPayment$feeInstallmentArgs<ExtArgs>
  }, ExtArgs["result"]["studentPayment"]>

  export type StudentPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    institutionId?: boolean
    feeInstallmentId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    gatewayData?: boolean
    paidAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    feeInstallment?: boolean | StudentPayment$feeInstallmentArgs<ExtArgs>
  }, ExtArgs["result"]["studentPayment"]>

  export type StudentPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    institutionId?: boolean
    feeInstallmentId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    gatewayData?: boolean
    paidAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    feeInstallment?: boolean | StudentPayment$feeInstallmentArgs<ExtArgs>
  }, ExtArgs["result"]["studentPayment"]>

  export type StudentPaymentSelectScalar = {
    id?: boolean
    studentId?: boolean
    institutionId?: boolean
    feeInstallmentId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    gatewayData?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }

  export type StudentPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "institutionId" | "feeInstallmentId" | "amount" | "currency" | "method" | "status" | "reference" | "gatewayData" | "paidAt" | "createdAt", ExtArgs["result"]["studentPayment"]>
  export type StudentPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    feeInstallment?: boolean | StudentPayment$feeInstallmentArgs<ExtArgs>
  }
  export type StudentPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    feeInstallment?: boolean | StudentPayment$feeInstallmentArgs<ExtArgs>
  }
  export type StudentPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    feeInstallment?: boolean | StudentPayment$feeInstallmentArgs<ExtArgs>
  }

  export type $StudentPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentPayment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
      feeInstallment: Prisma.$FeeInstallmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      institutionId: string
      feeInstallmentId: string | null
      amount: Prisma.Decimal
      currency: string
      method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      reference: string | null
      gatewayData: Prisma.JsonValue | null
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["studentPayment"]>
    composites: {}
  }

  type StudentPaymentGetPayload<S extends boolean | null | undefined | StudentPaymentDefaultArgs> = $Result.GetResult<Prisma.$StudentPaymentPayload, S>

  type StudentPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentPaymentCountAggregateInputType | true
    }

  export interface StudentPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentPayment'], meta: { name: 'StudentPayment' } }
    /**
     * Find zero or one StudentPayment that matches the filter.
     * @param {StudentPaymentFindUniqueArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentPaymentFindUniqueArgs>(args: SelectSubset<T, StudentPaymentFindUniqueArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentPaymentFindUniqueOrThrowArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentFindFirstArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentPaymentFindFirstArgs>(args?: SelectSubset<T, StudentPaymentFindFirstArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentFindFirstOrThrowArgs} args - Arguments to find a StudentPayment
     * @example
     * // Get one StudentPayment
     * const studentPayment = await prisma.studentPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentPayments
     * const studentPayments = await prisma.studentPayment.findMany()
     * 
     * // Get first 10 StudentPayments
     * const studentPayments = await prisma.studentPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentPaymentWithIdOnly = await prisma.studentPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentPaymentFindManyArgs>(args?: SelectSubset<T, StudentPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentPayment.
     * @param {StudentPaymentCreateArgs} args - Arguments to create a StudentPayment.
     * @example
     * // Create one StudentPayment
     * const StudentPayment = await prisma.studentPayment.create({
     *   data: {
     *     // ... data to create a StudentPayment
     *   }
     * })
     * 
     */
    create<T extends StudentPaymentCreateArgs>(args: SelectSubset<T, StudentPaymentCreateArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentPayments.
     * @param {StudentPaymentCreateManyArgs} args - Arguments to create many StudentPayments.
     * @example
     * // Create many StudentPayments
     * const studentPayment = await prisma.studentPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentPaymentCreateManyArgs>(args?: SelectSubset<T, StudentPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentPayments and returns the data saved in the database.
     * @param {StudentPaymentCreateManyAndReturnArgs} args - Arguments to create many StudentPayments.
     * @example
     * // Create many StudentPayments
     * const studentPayment = await prisma.studentPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentPayments and only return the `id`
     * const studentPaymentWithIdOnly = await prisma.studentPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentPayment.
     * @param {StudentPaymentDeleteArgs} args - Arguments to delete one StudentPayment.
     * @example
     * // Delete one StudentPayment
     * const StudentPayment = await prisma.studentPayment.delete({
     *   where: {
     *     // ... filter to delete one StudentPayment
     *   }
     * })
     * 
     */
    delete<T extends StudentPaymentDeleteArgs>(args: SelectSubset<T, StudentPaymentDeleteArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentPayment.
     * @param {StudentPaymentUpdateArgs} args - Arguments to update one StudentPayment.
     * @example
     * // Update one StudentPayment
     * const studentPayment = await prisma.studentPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentPaymentUpdateArgs>(args: SelectSubset<T, StudentPaymentUpdateArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentPayments.
     * @param {StudentPaymentDeleteManyArgs} args - Arguments to filter StudentPayments to delete.
     * @example
     * // Delete a few StudentPayments
     * const { count } = await prisma.studentPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentPaymentDeleteManyArgs>(args?: SelectSubset<T, StudentPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentPayments
     * const studentPayment = await prisma.studentPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentPaymentUpdateManyArgs>(args: SelectSubset<T, StudentPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentPayments and returns the data updated in the database.
     * @param {StudentPaymentUpdateManyAndReturnArgs} args - Arguments to update many StudentPayments.
     * @example
     * // Update many StudentPayments
     * const studentPayment = await prisma.studentPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentPayments and only return the `id`
     * const studentPaymentWithIdOnly = await prisma.studentPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentPayment.
     * @param {StudentPaymentUpsertArgs} args - Arguments to update or create a StudentPayment.
     * @example
     * // Update or create a StudentPayment
     * const studentPayment = await prisma.studentPayment.upsert({
     *   create: {
     *     // ... data to create a StudentPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentPayment we want to update
     *   }
     * })
     */
    upsert<T extends StudentPaymentUpsertArgs>(args: SelectSubset<T, StudentPaymentUpsertArgs<ExtArgs>>): Prisma__StudentPaymentClient<$Result.GetResult<Prisma.$StudentPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentCountArgs} args - Arguments to filter StudentPayments to count.
     * @example
     * // Count the number of StudentPayments
     * const count = await prisma.studentPayment.count({
     *   where: {
     *     // ... the filter for the StudentPayments we want to count
     *   }
     * })
    **/
    count<T extends StudentPaymentCountArgs>(
      args?: Subset<T, StudentPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentPaymentAggregateArgs>(args: Subset<T, StudentPaymentAggregateArgs>): Prisma.PrismaPromise<GetStudentPaymentAggregateType<T>>

    /**
     * Group by StudentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentPaymentGroupByArgs['orderBy'] }
        : { orderBy?: StudentPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentPayment model
   */
  readonly fields: StudentPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feeInstallment<T extends StudentPayment$feeInstallmentArgs<ExtArgs> = {}>(args?: Subset<T, StudentPayment$feeInstallmentArgs<ExtArgs>>): Prisma__FeeInstallmentClient<$Result.GetResult<Prisma.$FeeInstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentPayment model
   */
  interface StudentPaymentFieldRefs {
    readonly id: FieldRef<"StudentPayment", 'String'>
    readonly studentId: FieldRef<"StudentPayment", 'String'>
    readonly institutionId: FieldRef<"StudentPayment", 'String'>
    readonly feeInstallmentId: FieldRef<"StudentPayment", 'String'>
    readonly amount: FieldRef<"StudentPayment", 'Decimal'>
    readonly currency: FieldRef<"StudentPayment", 'String'>
    readonly method: FieldRef<"StudentPayment", 'PaymentMethod'>
    readonly status: FieldRef<"StudentPayment", 'PaymentStatus'>
    readonly reference: FieldRef<"StudentPayment", 'String'>
    readonly gatewayData: FieldRef<"StudentPayment", 'Json'>
    readonly paidAt: FieldRef<"StudentPayment", 'DateTime'>
    readonly createdAt: FieldRef<"StudentPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentPayment findUnique
   */
  export type StudentPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment findUniqueOrThrow
   */
  export type StudentPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment findFirst
   */
  export type StudentPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentPayments.
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentPayments.
     */
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * StudentPayment findFirstOrThrow
   */
  export type StudentPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayment to fetch.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentPayments.
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentPayments.
     */
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * StudentPayment findMany
   */
  export type StudentPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentPayments to fetch.
     */
    where?: StudentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentPayments to fetch.
     */
    orderBy?: StudentPaymentOrderByWithRelationInput | StudentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentPayments.
     */
    cursor?: StudentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentPayments.
     */
    skip?: number
    distinct?: StudentPaymentScalarFieldEnum | StudentPaymentScalarFieldEnum[]
  }

  /**
   * StudentPayment create
   */
  export type StudentPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentPayment.
     */
    data: XOR<StudentPaymentCreateInput, StudentPaymentUncheckedCreateInput>
  }

  /**
   * StudentPayment createMany
   */
  export type StudentPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentPayments.
     */
    data: StudentPaymentCreateManyInput | StudentPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentPayment createManyAndReturn
   */
  export type StudentPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentPayments.
     */
    data: StudentPaymentCreateManyInput | StudentPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentPayment update
   */
  export type StudentPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentPayment.
     */
    data: XOR<StudentPaymentUpdateInput, StudentPaymentUncheckedUpdateInput>
    /**
     * Choose, which StudentPayment to update.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment updateMany
   */
  export type StudentPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentPayments.
     */
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentPayments to update
     */
    where?: StudentPaymentWhereInput
    /**
     * Limit how many StudentPayments to update.
     */
    limit?: number
  }

  /**
   * StudentPayment updateManyAndReturn
   */
  export type StudentPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * The data used to update StudentPayments.
     */
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentPayments to update
     */
    where?: StudentPaymentWhereInput
    /**
     * Limit how many StudentPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentPayment upsert
   */
  export type StudentPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentPayment to update in case it exists.
     */
    where: StudentPaymentWhereUniqueInput
    /**
     * In case the StudentPayment found by the `where` argument doesn't exist, create a new StudentPayment with this data.
     */
    create: XOR<StudentPaymentCreateInput, StudentPaymentUncheckedCreateInput>
    /**
     * In case the StudentPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentPaymentUpdateInput, StudentPaymentUncheckedUpdateInput>
  }

  /**
   * StudentPayment delete
   */
  export type StudentPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
    /**
     * Filter which StudentPayment to delete.
     */
    where: StudentPaymentWhereUniqueInput
  }

  /**
   * StudentPayment deleteMany
   */
  export type StudentPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentPayments to delete
     */
    where?: StudentPaymentWhereInput
    /**
     * Limit how many StudentPayments to delete.
     */
    limit?: number
  }

  /**
   * StudentPayment.feeInstallment
   */
  export type StudentPayment$feeInstallmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeInstallment
     */
    select?: FeeInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeInstallment
     */
    omit?: FeeInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeInstallmentInclude<ExtArgs> | null
    where?: FeeInstallmentWhereInput
  }

  /**
   * StudentPayment without action
   */
  export type StudentPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentPayment
     */
    select?: StudentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentPayment
     */
    omit?: StudentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentPlan
   */

  export type AggregatePaymentPlan = {
    _count: PaymentPlanCountAggregateOutputType | null
    _avg: PaymentPlanAvgAggregateOutputType | null
    _sum: PaymentPlanSumAggregateOutputType | null
    _min: PaymentPlanMinAggregateOutputType | null
    _max: PaymentPlanMaxAggregateOutputType | null
  }

  export type PaymentPlanAvgAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    remainingAmount: Decimal | null
  }

  export type PaymentPlanSumAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    remainingAmount: Decimal | null
  }

  export type PaymentPlanMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    feeScheduleId: string | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    remainingAmount: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type PaymentPlanMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    feeScheduleId: string | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    remainingAmount: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type PaymentPlanCountAggregateOutputType = {
    id: number
    studentId: number
    feeScheduleId: number
    totalAmount: number
    paidAmount: number
    remainingAmount: number
    status: number
    createdAt: number
    _all: number
  }


  export type PaymentPlanAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
    remainingAmount?: true
  }

  export type PaymentPlanSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
    remainingAmount?: true
  }

  export type PaymentPlanMinAggregateInputType = {
    id?: true
    studentId?: true
    feeScheduleId?: true
    totalAmount?: true
    paidAmount?: true
    remainingAmount?: true
    status?: true
    createdAt?: true
  }

  export type PaymentPlanMaxAggregateInputType = {
    id?: true
    studentId?: true
    feeScheduleId?: true
    totalAmount?: true
    paidAmount?: true
    remainingAmount?: true
    status?: true
    createdAt?: true
  }

  export type PaymentPlanCountAggregateInputType = {
    id?: true
    studentId?: true
    feeScheduleId?: true
    totalAmount?: true
    paidAmount?: true
    remainingAmount?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentPlan to aggregate.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentPlans
    **/
    _count?: true | PaymentPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentPlanMaxAggregateInputType
  }

  export type GetPaymentPlanAggregateType<T extends PaymentPlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentPlan[P]>
      : GetScalarType<T[P], AggregatePaymentPlan[P]>
  }




  export type PaymentPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentPlanWhereInput
    orderBy?: PaymentPlanOrderByWithAggregationInput | PaymentPlanOrderByWithAggregationInput[]
    by: PaymentPlanScalarFieldEnum[] | PaymentPlanScalarFieldEnum
    having?: PaymentPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentPlanCountAggregateInputType | true
    _avg?: PaymentPlanAvgAggregateInputType
    _sum?: PaymentPlanSumAggregateInputType
    _min?: PaymentPlanMinAggregateInputType
    _max?: PaymentPlanMaxAggregateInputType
  }

  export type PaymentPlanGroupByOutputType = {
    id: string
    studentId: string
    feeScheduleId: string
    totalAmount: Decimal
    paidAmount: Decimal
    remainingAmount: Decimal
    status: string
    createdAt: Date
    _count: PaymentPlanCountAggregateOutputType | null
    _avg: PaymentPlanAvgAggregateOutputType | null
    _sum: PaymentPlanSumAggregateOutputType | null
    _min: PaymentPlanMinAggregateOutputType | null
    _max: PaymentPlanMaxAggregateOutputType | null
  }

  type GetPaymentPlanGroupByPayload<T extends PaymentPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentPlanGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentPlanGroupByOutputType[P]>
        }
      >
    >


  export type PaymentPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    feeScheduleId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentPlan"]>

  export type PaymentPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    feeScheduleId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentPlan"]>

  export type PaymentPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    feeScheduleId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentPlan"]>

  export type PaymentPlanSelectScalar = {
    id?: boolean
    studentId?: boolean
    feeScheduleId?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type PaymentPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "feeScheduleId" | "totalAmount" | "paidAmount" | "remainingAmount" | "status" | "createdAt", ExtArgs["result"]["paymentPlan"]>
  export type PaymentPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }
  export type PaymentPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }
  export type PaymentPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    feeSchedule?: boolean | FeeScheduleDefaultArgs<ExtArgs>
  }

  export type $PaymentPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentPlan"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      feeSchedule: Prisma.$FeeSchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      feeScheduleId: string
      totalAmount: Prisma.Decimal
      paidAmount: Prisma.Decimal
      remainingAmount: Prisma.Decimal
      status: string
      createdAt: Date
    }, ExtArgs["result"]["paymentPlan"]>
    composites: {}
  }

  type PaymentPlanGetPayload<S extends boolean | null | undefined | PaymentPlanDefaultArgs> = $Result.GetResult<Prisma.$PaymentPlanPayload, S>

  type PaymentPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentPlanCountAggregateInputType | true
    }

  export interface PaymentPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentPlan'], meta: { name: 'PaymentPlan' } }
    /**
     * Find zero or one PaymentPlan that matches the filter.
     * @param {PaymentPlanFindUniqueArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentPlanFindUniqueArgs>(args: SelectSubset<T, PaymentPlanFindUniqueArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentPlanFindUniqueOrThrowArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanFindFirstArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentPlanFindFirstArgs>(args?: SelectSubset<T, PaymentPlanFindFirstArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanFindFirstOrThrowArgs} args - Arguments to find a PaymentPlan
     * @example
     * // Get one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentPlans
     * const paymentPlans = await prisma.paymentPlan.findMany()
     * 
     * // Get first 10 PaymentPlans
     * const paymentPlans = await prisma.paymentPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentPlanWithIdOnly = await prisma.paymentPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentPlanFindManyArgs>(args?: SelectSubset<T, PaymentPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentPlan.
     * @param {PaymentPlanCreateArgs} args - Arguments to create a PaymentPlan.
     * @example
     * // Create one PaymentPlan
     * const PaymentPlan = await prisma.paymentPlan.create({
     *   data: {
     *     // ... data to create a PaymentPlan
     *   }
     * })
     * 
     */
    create<T extends PaymentPlanCreateArgs>(args: SelectSubset<T, PaymentPlanCreateArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentPlans.
     * @param {PaymentPlanCreateManyArgs} args - Arguments to create many PaymentPlans.
     * @example
     * // Create many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentPlanCreateManyArgs>(args?: SelectSubset<T, PaymentPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentPlans and returns the data saved in the database.
     * @param {PaymentPlanCreateManyAndReturnArgs} args - Arguments to create many PaymentPlans.
     * @example
     * // Create many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentPlans and only return the `id`
     * const paymentPlanWithIdOnly = await prisma.paymentPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentPlan.
     * @param {PaymentPlanDeleteArgs} args - Arguments to delete one PaymentPlan.
     * @example
     * // Delete one PaymentPlan
     * const PaymentPlan = await prisma.paymentPlan.delete({
     *   where: {
     *     // ... filter to delete one PaymentPlan
     *   }
     * })
     * 
     */
    delete<T extends PaymentPlanDeleteArgs>(args: SelectSubset<T, PaymentPlanDeleteArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentPlan.
     * @param {PaymentPlanUpdateArgs} args - Arguments to update one PaymentPlan.
     * @example
     * // Update one PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentPlanUpdateArgs>(args: SelectSubset<T, PaymentPlanUpdateArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentPlans.
     * @param {PaymentPlanDeleteManyArgs} args - Arguments to filter PaymentPlans to delete.
     * @example
     * // Delete a few PaymentPlans
     * const { count } = await prisma.paymentPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentPlanDeleteManyArgs>(args?: SelectSubset<T, PaymentPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentPlanUpdateManyArgs>(args: SelectSubset<T, PaymentPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentPlans and returns the data updated in the database.
     * @param {PaymentPlanUpdateManyAndReturnArgs} args - Arguments to update many PaymentPlans.
     * @example
     * // Update many PaymentPlans
     * const paymentPlan = await prisma.paymentPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentPlans and only return the `id`
     * const paymentPlanWithIdOnly = await prisma.paymentPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentPlan.
     * @param {PaymentPlanUpsertArgs} args - Arguments to update or create a PaymentPlan.
     * @example
     * // Update or create a PaymentPlan
     * const paymentPlan = await prisma.paymentPlan.upsert({
     *   create: {
     *     // ... data to create a PaymentPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentPlan we want to update
     *   }
     * })
     */
    upsert<T extends PaymentPlanUpsertArgs>(args: SelectSubset<T, PaymentPlanUpsertArgs<ExtArgs>>): Prisma__PaymentPlanClient<$Result.GetResult<Prisma.$PaymentPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanCountArgs} args - Arguments to filter PaymentPlans to count.
     * @example
     * // Count the number of PaymentPlans
     * const count = await prisma.paymentPlan.count({
     *   where: {
     *     // ... the filter for the PaymentPlans we want to count
     *   }
     * })
    **/
    count<T extends PaymentPlanCountArgs>(
      args?: Subset<T, PaymentPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentPlanAggregateArgs>(args: Subset<T, PaymentPlanAggregateArgs>): Prisma.PrismaPromise<GetPaymentPlanAggregateType<T>>

    /**
     * Group by PaymentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentPlanGroupByArgs['orderBy'] }
        : { orderBy?: PaymentPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentPlan model
   */
  readonly fields: PaymentPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feeSchedule<T extends FeeScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeScheduleDefaultArgs<ExtArgs>>): Prisma__FeeScheduleClient<$Result.GetResult<Prisma.$FeeSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentPlan model
   */
  interface PaymentPlanFieldRefs {
    readonly id: FieldRef<"PaymentPlan", 'String'>
    readonly studentId: FieldRef<"PaymentPlan", 'String'>
    readonly feeScheduleId: FieldRef<"PaymentPlan", 'String'>
    readonly totalAmount: FieldRef<"PaymentPlan", 'Decimal'>
    readonly paidAmount: FieldRef<"PaymentPlan", 'Decimal'>
    readonly remainingAmount: FieldRef<"PaymentPlan", 'Decimal'>
    readonly status: FieldRef<"PaymentPlan", 'String'>
    readonly createdAt: FieldRef<"PaymentPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentPlan findUnique
   */
  export type PaymentPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan findUniqueOrThrow
   */
  export type PaymentPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan findFirst
   */
  export type PaymentPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentPlans.
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentPlans.
     */
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * PaymentPlan findFirstOrThrow
   */
  export type PaymentPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlan to fetch.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentPlans.
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentPlans.
     */
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * PaymentPlan findMany
   */
  export type PaymentPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which PaymentPlans to fetch.
     */
    where?: PaymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentPlans to fetch.
     */
    orderBy?: PaymentPlanOrderByWithRelationInput | PaymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentPlans.
     */
    cursor?: PaymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentPlans.
     */
    skip?: number
    distinct?: PaymentPlanScalarFieldEnum | PaymentPlanScalarFieldEnum[]
  }

  /**
   * PaymentPlan create
   */
  export type PaymentPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentPlan.
     */
    data: XOR<PaymentPlanCreateInput, PaymentPlanUncheckedCreateInput>
  }

  /**
   * PaymentPlan createMany
   */
  export type PaymentPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentPlans.
     */
    data: PaymentPlanCreateManyInput | PaymentPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentPlan createManyAndReturn
   */
  export type PaymentPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentPlans.
     */
    data: PaymentPlanCreateManyInput | PaymentPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentPlan update
   */
  export type PaymentPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentPlan.
     */
    data: XOR<PaymentPlanUpdateInput, PaymentPlanUncheckedUpdateInput>
    /**
     * Choose, which PaymentPlan to update.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan updateMany
   */
  export type PaymentPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentPlans.
     */
    data: XOR<PaymentPlanUpdateManyMutationInput, PaymentPlanUncheckedUpdateManyInput>
    /**
     * Filter which PaymentPlans to update
     */
    where?: PaymentPlanWhereInput
    /**
     * Limit how many PaymentPlans to update.
     */
    limit?: number
  }

  /**
   * PaymentPlan updateManyAndReturn
   */
  export type PaymentPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * The data used to update PaymentPlans.
     */
    data: XOR<PaymentPlanUpdateManyMutationInput, PaymentPlanUncheckedUpdateManyInput>
    /**
     * Filter which PaymentPlans to update
     */
    where?: PaymentPlanWhereInput
    /**
     * Limit how many PaymentPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentPlan upsert
   */
  export type PaymentPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentPlan to update in case it exists.
     */
    where: PaymentPlanWhereUniqueInput
    /**
     * In case the PaymentPlan found by the `where` argument doesn't exist, create a new PaymentPlan with this data.
     */
    create: XOR<PaymentPlanCreateInput, PaymentPlanUncheckedCreateInput>
    /**
     * In case the PaymentPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentPlanUpdateInput, PaymentPlanUncheckedUpdateInput>
  }

  /**
   * PaymentPlan delete
   */
  export type PaymentPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
    /**
     * Filter which PaymentPlan to delete.
     */
    where: PaymentPlanWhereUniqueInput
  }

  /**
   * PaymentPlan deleteMany
   */
  export type PaymentPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentPlans to delete
     */
    where?: PaymentPlanWhereInput
    /**
     * Limit how many PaymentPlans to delete.
     */
    limit?: number
  }

  /**
   * PaymentPlan without action
   */
  export type PaymentPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentPlan
     */
    select?: PaymentPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentPlan
     */
    omit?: PaymentPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentPlanInclude<ExtArgs> | null
  }


  /**
   * Model AIAgent
   */

  export type AggregateAIAgent = {
    _count: AIAgentCountAggregateOutputType | null
    _avg: AIAgentAvgAggregateOutputType | null
    _sum: AIAgentSumAggregateOutputType | null
    _min: AIAgentMinAggregateOutputType | null
    _max: AIAgentMaxAggregateOutputType | null
  }

  export type AIAgentAvgAggregateOutputType = {
    maxTokensPerCall: number | null
    temperature: number | null
  }

  export type AIAgentSumAggregateOutputType = {
    maxTokensPerCall: number | null
    temperature: number | null
  }

  export type AIAgentMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    type: string | null
    name: string | null
    personality: string | null
    specialization: string | null
    maxTokensPerCall: number | null
    temperature: number | null
    systemPrompt: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AIAgentMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    type: string | null
    name: string | null
    personality: string | null
    specialization: string | null
    maxTokensPerCall: number | null
    temperature: number | null
    systemPrompt: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AIAgentCountAggregateOutputType = {
    id: number
    institutionId: number
    type: number
    name: number
    personality: number
    specialization: number
    maxTokensPerCall: number
    temperature: number
    systemPrompt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AIAgentAvgAggregateInputType = {
    maxTokensPerCall?: true
    temperature?: true
  }

  export type AIAgentSumAggregateInputType = {
    maxTokensPerCall?: true
    temperature?: true
  }

  export type AIAgentMinAggregateInputType = {
    id?: true
    institutionId?: true
    type?: true
    name?: true
    personality?: true
    specialization?: true
    maxTokensPerCall?: true
    temperature?: true
    systemPrompt?: true
    isActive?: true
    createdAt?: true
  }

  export type AIAgentMaxAggregateInputType = {
    id?: true
    institutionId?: true
    type?: true
    name?: true
    personality?: true
    specialization?: true
    maxTokensPerCall?: true
    temperature?: true
    systemPrompt?: true
    isActive?: true
    createdAt?: true
  }

  export type AIAgentCountAggregateInputType = {
    id?: true
    institutionId?: true
    type?: true
    name?: true
    personality?: true
    specialization?: true
    maxTokensPerCall?: true
    temperature?: true
    systemPrompt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AIAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgent to aggregate.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: AIAgentOrderByWithRelationInput | AIAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIAgents
    **/
    _count?: true | AIAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIAgentMaxAggregateInputType
  }

  export type GetAIAgentAggregateType<T extends AIAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAIAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIAgent[P]>
      : GetScalarType<T[P], AggregateAIAgent[P]>
  }




  export type AIAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAgentWhereInput
    orderBy?: AIAgentOrderByWithAggregationInput | AIAgentOrderByWithAggregationInput[]
    by: AIAgentScalarFieldEnum[] | AIAgentScalarFieldEnum
    having?: AIAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIAgentCountAggregateInputType | true
    _avg?: AIAgentAvgAggregateInputType
    _sum?: AIAgentSumAggregateInputType
    _min?: AIAgentMinAggregateInputType
    _max?: AIAgentMaxAggregateInputType
  }

  export type AIAgentGroupByOutputType = {
    id: string
    institutionId: string
    type: string
    name: string
    personality: string
    specialization: string | null
    maxTokensPerCall: number
    temperature: number
    systemPrompt: string
    isActive: boolean
    createdAt: Date
    _count: AIAgentCountAggregateOutputType | null
    _avg: AIAgentAvgAggregateOutputType | null
    _sum: AIAgentSumAggregateOutputType | null
    _min: AIAgentMinAggregateOutputType | null
    _max: AIAgentMaxAggregateOutputType | null
  }

  type GetAIAgentGroupByPayload<T extends AIAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AIAgentGroupByOutputType[P]>
        }
      >
    >


  export type AIAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    type?: boolean
    name?: boolean
    personality?: boolean
    specialization?: boolean
    maxTokensPerCall?: boolean
    temperature?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    conversations?: boolean | AIAgent$conversationsArgs<ExtArgs>
    classrooms?: boolean | AIAgent$classroomsArgs<ExtArgs>
    _count?: boolean | AIAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgent"]>

  export type AIAgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    type?: boolean
    name?: boolean
    personality?: boolean
    specialization?: boolean
    maxTokensPerCall?: boolean
    temperature?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgent"]>

  export type AIAgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    type?: boolean
    name?: boolean
    personality?: boolean
    specialization?: boolean
    maxTokensPerCall?: boolean
    temperature?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgent"]>

  export type AIAgentSelectScalar = {
    id?: boolean
    institutionId?: boolean
    type?: boolean
    name?: boolean
    personality?: boolean
    specialization?: boolean
    maxTokensPerCall?: boolean
    temperature?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AIAgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "type" | "name" | "personality" | "specialization" | "maxTokensPerCall" | "temperature" | "systemPrompt" | "isActive" | "createdAt", ExtArgs["result"]["aIAgent"]>
  export type AIAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    conversations?: boolean | AIAgent$conversationsArgs<ExtArgs>
    classrooms?: boolean | AIAgent$classroomsArgs<ExtArgs>
    _count?: boolean | AIAgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIAgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type AIAgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $AIAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIAgent"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      conversations: Prisma.$AIConversationPayload<ExtArgs>[]
      classrooms: Prisma.$VirtualClassroomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      type: string
      name: string
      personality: string
      specialization: string | null
      maxTokensPerCall: number
      temperature: number
      systemPrompt: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["aIAgent"]>
    composites: {}
  }

  type AIAgentGetPayload<S extends boolean | null | undefined | AIAgentDefaultArgs> = $Result.GetResult<Prisma.$AIAgentPayload, S>

  type AIAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIAgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIAgentCountAggregateInputType | true
    }

  export interface AIAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIAgent'], meta: { name: 'AIAgent' } }
    /**
     * Find zero or one AIAgent that matches the filter.
     * @param {AIAgentFindUniqueArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIAgentFindUniqueArgs>(args: SelectSubset<T, AIAgentFindUniqueArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIAgent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIAgentFindUniqueOrThrowArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AIAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentFindFirstArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIAgentFindFirstArgs>(args?: SelectSubset<T, AIAgentFindFirstArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentFindFirstOrThrowArgs} args - Arguments to find a AIAgent
     * @example
     * // Get one AIAgent
     * const aIAgent = await prisma.aIAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AIAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIAgents
     * const aIAgents = await prisma.aIAgent.findMany()
     * 
     * // Get first 10 AIAgents
     * const aIAgents = await prisma.aIAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIAgentWithIdOnly = await prisma.aIAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIAgentFindManyArgs>(args?: SelectSubset<T, AIAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIAgent.
     * @param {AIAgentCreateArgs} args - Arguments to create a AIAgent.
     * @example
     * // Create one AIAgent
     * const AIAgent = await prisma.aIAgent.create({
     *   data: {
     *     // ... data to create a AIAgent
     *   }
     * })
     * 
     */
    create<T extends AIAgentCreateArgs>(args: SelectSubset<T, AIAgentCreateArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIAgents.
     * @param {AIAgentCreateManyArgs} args - Arguments to create many AIAgents.
     * @example
     * // Create many AIAgents
     * const aIAgent = await prisma.aIAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIAgentCreateManyArgs>(args?: SelectSubset<T, AIAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIAgents and returns the data saved in the database.
     * @param {AIAgentCreateManyAndReturnArgs} args - Arguments to create many AIAgents.
     * @example
     * // Create many AIAgents
     * const aIAgent = await prisma.aIAgent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIAgents and only return the `id`
     * const aIAgentWithIdOnly = await prisma.aIAgent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIAgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AIAgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIAgent.
     * @param {AIAgentDeleteArgs} args - Arguments to delete one AIAgent.
     * @example
     * // Delete one AIAgent
     * const AIAgent = await prisma.aIAgent.delete({
     *   where: {
     *     // ... filter to delete one AIAgent
     *   }
     * })
     * 
     */
    delete<T extends AIAgentDeleteArgs>(args: SelectSubset<T, AIAgentDeleteArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIAgent.
     * @param {AIAgentUpdateArgs} args - Arguments to update one AIAgent.
     * @example
     * // Update one AIAgent
     * const aIAgent = await prisma.aIAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIAgentUpdateArgs>(args: SelectSubset<T, AIAgentUpdateArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIAgents.
     * @param {AIAgentDeleteManyArgs} args - Arguments to filter AIAgents to delete.
     * @example
     * // Delete a few AIAgents
     * const { count } = await prisma.aIAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIAgentDeleteManyArgs>(args?: SelectSubset<T, AIAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIAgents
     * const aIAgent = await prisma.aIAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIAgentUpdateManyArgs>(args: SelectSubset<T, AIAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgents and returns the data updated in the database.
     * @param {AIAgentUpdateManyAndReturnArgs} args - Arguments to update many AIAgents.
     * @example
     * // Update many AIAgents
     * const aIAgent = await prisma.aIAgent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIAgents and only return the `id`
     * const aIAgentWithIdOnly = await prisma.aIAgent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIAgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AIAgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIAgent.
     * @param {AIAgentUpsertArgs} args - Arguments to update or create a AIAgent.
     * @example
     * // Update or create a AIAgent
     * const aIAgent = await prisma.aIAgent.upsert({
     *   create: {
     *     // ... data to create a AIAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIAgent we want to update
     *   }
     * })
     */
    upsert<T extends AIAgentUpsertArgs>(args: SelectSubset<T, AIAgentUpsertArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentCountArgs} args - Arguments to filter AIAgents to count.
     * @example
     * // Count the number of AIAgents
     * const count = await prisma.aIAgent.count({
     *   where: {
     *     // ... the filter for the AIAgents we want to count
     *   }
     * })
    **/
    count<T extends AIAgentCountArgs>(
      args?: Subset<T, AIAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIAgentAggregateArgs>(args: Subset<T, AIAgentAggregateArgs>): Prisma.PrismaPromise<GetAIAgentAggregateType<T>>

    /**
     * Group by AIAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIAgentGroupByArgs['orderBy'] }
        : { orderBy?: AIAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIAgent model
   */
  readonly fields: AIAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversations<T extends AIAgent$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, AIAgent$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classrooms<T extends AIAgent$classroomsArgs<ExtArgs> = {}>(args?: Subset<T, AIAgent$classroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIAgent model
   */
  interface AIAgentFieldRefs {
    readonly id: FieldRef<"AIAgent", 'String'>
    readonly institutionId: FieldRef<"AIAgent", 'String'>
    readonly type: FieldRef<"AIAgent", 'String'>
    readonly name: FieldRef<"AIAgent", 'String'>
    readonly personality: FieldRef<"AIAgent", 'String'>
    readonly specialization: FieldRef<"AIAgent", 'String'>
    readonly maxTokensPerCall: FieldRef<"AIAgent", 'Int'>
    readonly temperature: FieldRef<"AIAgent", 'Float'>
    readonly systemPrompt: FieldRef<"AIAgent", 'String'>
    readonly isActive: FieldRef<"AIAgent", 'Boolean'>
    readonly createdAt: FieldRef<"AIAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIAgent findUnique
   */
  export type AIAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where: AIAgentWhereUniqueInput
  }

  /**
   * AIAgent findUniqueOrThrow
   */
  export type AIAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where: AIAgentWhereUniqueInput
  }

  /**
   * AIAgent findFirst
   */
  export type AIAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: AIAgentOrderByWithRelationInput | AIAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgents.
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgents.
     */
    distinct?: AIAgentScalarFieldEnum | AIAgentScalarFieldEnum[]
  }

  /**
   * AIAgent findFirstOrThrow
   */
  export type AIAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgent to fetch.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: AIAgentOrderByWithRelationInput | AIAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgents.
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgents.
     */
    distinct?: AIAgentScalarFieldEnum | AIAgentScalarFieldEnum[]
  }

  /**
   * AIAgent findMany
   */
  export type AIAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter, which AIAgents to fetch.
     */
    where?: AIAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgents to fetch.
     */
    orderBy?: AIAgentOrderByWithRelationInput | AIAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIAgents.
     */
    cursor?: AIAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgents.
     */
    skip?: number
    distinct?: AIAgentScalarFieldEnum | AIAgentScalarFieldEnum[]
  }

  /**
   * AIAgent create
   */
  export type AIAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AIAgent.
     */
    data: XOR<AIAgentCreateInput, AIAgentUncheckedCreateInput>
  }

  /**
   * AIAgent createMany
   */
  export type AIAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIAgents.
     */
    data: AIAgentCreateManyInput | AIAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIAgent createManyAndReturn
   */
  export type AIAgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * The data used to create many AIAgents.
     */
    data: AIAgentCreateManyInput | AIAgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIAgent update
   */
  export type AIAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AIAgent.
     */
    data: XOR<AIAgentUpdateInput, AIAgentUncheckedUpdateInput>
    /**
     * Choose, which AIAgent to update.
     */
    where: AIAgentWhereUniqueInput
  }

  /**
   * AIAgent updateMany
   */
  export type AIAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIAgents.
     */
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyInput>
    /**
     * Filter which AIAgents to update
     */
    where?: AIAgentWhereInput
    /**
     * Limit how many AIAgents to update.
     */
    limit?: number
  }

  /**
   * AIAgent updateManyAndReturn
   */
  export type AIAgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * The data used to update AIAgents.
     */
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyInput>
    /**
     * Filter which AIAgents to update
     */
    where?: AIAgentWhereInput
    /**
     * Limit how many AIAgents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIAgent upsert
   */
  export type AIAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AIAgent to update in case it exists.
     */
    where: AIAgentWhereUniqueInput
    /**
     * In case the AIAgent found by the `where` argument doesn't exist, create a new AIAgent with this data.
     */
    create: XOR<AIAgentCreateInput, AIAgentUncheckedCreateInput>
    /**
     * In case the AIAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIAgentUpdateInput, AIAgentUncheckedUpdateInput>
  }

  /**
   * AIAgent delete
   */
  export type AIAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
    /**
     * Filter which AIAgent to delete.
     */
    where: AIAgentWhereUniqueInput
  }

  /**
   * AIAgent deleteMany
   */
  export type AIAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgents to delete
     */
    where?: AIAgentWhereInput
    /**
     * Limit how many AIAgents to delete.
     */
    limit?: number
  }

  /**
   * AIAgent.conversations
   */
  export type AIAgent$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    cursor?: AIConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIAgent.classrooms
   */
  export type AIAgent$classroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    where?: VirtualClassroomWhereInput
    orderBy?: VirtualClassroomOrderByWithRelationInput | VirtualClassroomOrderByWithRelationInput[]
    cursor?: VirtualClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassroomScalarFieldEnum | VirtualClassroomScalarFieldEnum[]
  }

  /**
   * AIAgent without action
   */
  export type AIAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgent
     */
    select?: AIAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgent
     */
    omit?: AIAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentInclude<ExtArgs> | null
  }


  /**
   * Model AIConversation
   */

  export type AggregateAIConversation = {
    _count: AIConversationCountAggregateOutputType | null
    _avg: AIConversationAvgAggregateOutputType | null
    _sum: AIConversationSumAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  export type AIConversationAvgAggregateOutputType = {
    totalTokens: number | null
    totalCost: Decimal | null
  }

  export type AIConversationSumAggregateOutputType = {
    totalTokens: number | null
    totalCost: Decimal | null
  }

  export type AIConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agentId: string | null
    sessionId: string | null
    startedAt: Date | null
    endedAt: Date | null
    totalTokens: number | null
    totalCost: Decimal | null
  }

  export type AIConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agentId: string | null
    sessionId: string | null
    startedAt: Date | null
    endedAt: Date | null
    totalTokens: number | null
    totalCost: Decimal | null
  }

  export type AIConversationCountAggregateOutputType = {
    id: number
    userId: number
    agentId: number
    sessionId: number
    startedAt: number
    endedAt: number
    totalTokens: number
    totalCost: number
    _all: number
  }


  export type AIConversationAvgAggregateInputType = {
    totalTokens?: true
    totalCost?: true
  }

  export type AIConversationSumAggregateInputType = {
    totalTokens?: true
    totalCost?: true
  }

  export type AIConversationMinAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    sessionId?: true
    startedAt?: true
    endedAt?: true
    totalTokens?: true
    totalCost?: true
  }

  export type AIConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    sessionId?: true
    startedAt?: true
    endedAt?: true
    totalTokens?: true
    totalCost?: true
  }

  export type AIConversationCountAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    sessionId?: true
    startedAt?: true
    endedAt?: true
    totalTokens?: true
    totalCost?: true
    _all?: true
  }

  export type AIConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversation to aggregate.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIConversations
    **/
    _count?: true | AIConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIConversationMaxAggregateInputType
  }

  export type GetAIConversationAggregateType<T extends AIConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIConversation[P]>
      : GetScalarType<T[P], AggregateAIConversation[P]>
  }




  export type AIConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIConversationWhereInput
    orderBy?: AIConversationOrderByWithAggregationInput | AIConversationOrderByWithAggregationInput[]
    by: AIConversationScalarFieldEnum[] | AIConversationScalarFieldEnum
    having?: AIConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIConversationCountAggregateInputType | true
    _avg?: AIConversationAvgAggregateInputType
    _sum?: AIConversationSumAggregateInputType
    _min?: AIConversationMinAggregateInputType
    _max?: AIConversationMaxAggregateInputType
  }

  export type AIConversationGroupByOutputType = {
    id: string
    userId: string
    agentId: string
    sessionId: string
    startedAt: Date
    endedAt: Date | null
    totalTokens: number
    totalCost: Decimal | null
    _count: AIConversationCountAggregateOutputType | null
    _avg: AIConversationAvgAggregateOutputType | null
    _sum: AIConversationSumAggregateOutputType | null
    _min: AIConversationMinAggregateOutputType | null
    _max: AIConversationMaxAggregateOutputType | null
  }

  type GetAIConversationGroupByPayload<T extends AIConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AIConversationGroupByOutputType[P]>
        }
      >
    >


  export type AIConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AIAgentDefaultArgs<ExtArgs>
    messages?: boolean | AIConversation$messagesArgs<ExtArgs>
    _count?: boolean | AIConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AIAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AIAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIConversation"]>

  export type AIConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    agentId?: boolean
    sessionId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    totalTokens?: boolean
    totalCost?: boolean
  }

  export type AIConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agentId" | "sessionId" | "startedAt" | "endedAt" | "totalTokens" | "totalCost", ExtArgs["result"]["aIConversation"]>
  export type AIConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AIAgentDefaultArgs<ExtArgs>
    messages?: boolean | AIConversation$messagesArgs<ExtArgs>
    _count?: boolean | AIConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AIAgentDefaultArgs<ExtArgs>
  }
  export type AIConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AIAgentDefaultArgs<ExtArgs>
  }

  export type $AIConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIConversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      agent: Prisma.$AIAgentPayload<ExtArgs>
      messages: Prisma.$AIMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agentId: string
      sessionId: string
      startedAt: Date
      endedAt: Date | null
      totalTokens: number
      totalCost: Prisma.Decimal | null
    }, ExtArgs["result"]["aIConversation"]>
    composites: {}
  }

  type AIConversationGetPayload<S extends boolean | null | undefined | AIConversationDefaultArgs> = $Result.GetResult<Prisma.$AIConversationPayload, S>

  type AIConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIConversationCountAggregateInputType | true
    }

  export interface AIConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIConversation'], meta: { name: 'AIConversation' } }
    /**
     * Find zero or one AIConversation that matches the filter.
     * @param {AIConversationFindUniqueArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIConversationFindUniqueArgs>(args: SelectSubset<T, AIConversationFindUniqueArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIConversationFindUniqueOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIConversationFindFirstArgs>(args?: SelectSubset<T, AIConversationFindFirstArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindFirstOrThrowArgs} args - Arguments to find a AIConversation
     * @example
     * // Get one AIConversation
     * const aIConversation = await prisma.aIConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIConversations
     * const aIConversations = await prisma.aIConversation.findMany()
     * 
     * // Get first 10 AIConversations
     * const aIConversations = await prisma.aIConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIConversationFindManyArgs>(args?: SelectSubset<T, AIConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIConversation.
     * @param {AIConversationCreateArgs} args - Arguments to create a AIConversation.
     * @example
     * // Create one AIConversation
     * const AIConversation = await prisma.aIConversation.create({
     *   data: {
     *     // ... data to create a AIConversation
     *   }
     * })
     * 
     */
    create<T extends AIConversationCreateArgs>(args: SelectSubset<T, AIConversationCreateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIConversations.
     * @param {AIConversationCreateManyArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIConversationCreateManyArgs>(args?: SelectSubset<T, AIConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIConversations and returns the data saved in the database.
     * @param {AIConversationCreateManyAndReturnArgs} args - Arguments to create many AIConversations.
     * @example
     * // Create many AIConversations
     * const aIConversation = await prisma.aIConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIConversations and only return the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIConversation.
     * @param {AIConversationDeleteArgs} args - Arguments to delete one AIConversation.
     * @example
     * // Delete one AIConversation
     * const AIConversation = await prisma.aIConversation.delete({
     *   where: {
     *     // ... filter to delete one AIConversation
     *   }
     * })
     * 
     */
    delete<T extends AIConversationDeleteArgs>(args: SelectSubset<T, AIConversationDeleteArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIConversation.
     * @param {AIConversationUpdateArgs} args - Arguments to update one AIConversation.
     * @example
     * // Update one AIConversation
     * const aIConversation = await prisma.aIConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIConversationUpdateArgs>(args: SelectSubset<T, AIConversationUpdateArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIConversations.
     * @param {AIConversationDeleteManyArgs} args - Arguments to filter AIConversations to delete.
     * @example
     * // Delete a few AIConversations
     * const { count } = await prisma.aIConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIConversationDeleteManyArgs>(args?: SelectSubset<T, AIConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIConversations
     * const aIConversation = await prisma.aIConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIConversationUpdateManyArgs>(args: SelectSubset<T, AIConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIConversations and returns the data updated in the database.
     * @param {AIConversationUpdateManyAndReturnArgs} args - Arguments to update many AIConversations.
     * @example
     * // Update many AIConversations
     * const aIConversation = await prisma.aIConversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIConversations and only return the `id`
     * const aIConversationWithIdOnly = await prisma.aIConversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, AIConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIConversation.
     * @param {AIConversationUpsertArgs} args - Arguments to update or create a AIConversation.
     * @example
     * // Update or create a AIConversation
     * const aIConversation = await prisma.aIConversation.upsert({
     *   create: {
     *     // ... data to create a AIConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIConversation we want to update
     *   }
     * })
     */
    upsert<T extends AIConversationUpsertArgs>(args: SelectSubset<T, AIConversationUpsertArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationCountArgs} args - Arguments to filter AIConversations to count.
     * @example
     * // Count the number of AIConversations
     * const count = await prisma.aIConversation.count({
     *   where: {
     *     // ... the filter for the AIConversations we want to count
     *   }
     * })
    **/
    count<T extends AIConversationCountArgs>(
      args?: Subset<T, AIConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIConversationAggregateArgs>(args: Subset<T, AIConversationAggregateArgs>): Prisma.PrismaPromise<GetAIConversationAggregateType<T>>

    /**
     * Group by AIConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIConversationGroupByArgs['orderBy'] }
        : { orderBy?: AIConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIConversation model
   */
  readonly fields: AIConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AIAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIAgentDefaultArgs<ExtArgs>>): Prisma__AIAgentClient<$Result.GetResult<Prisma.$AIAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends AIConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AIConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIConversation model
   */
  interface AIConversationFieldRefs {
    readonly id: FieldRef<"AIConversation", 'String'>
    readonly userId: FieldRef<"AIConversation", 'String'>
    readonly agentId: FieldRef<"AIConversation", 'String'>
    readonly sessionId: FieldRef<"AIConversation", 'String'>
    readonly startedAt: FieldRef<"AIConversation", 'DateTime'>
    readonly endedAt: FieldRef<"AIConversation", 'DateTime'>
    readonly totalTokens: FieldRef<"AIConversation", 'Int'>
    readonly totalCost: FieldRef<"AIConversation", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * AIConversation findUnique
   */
  export type AIConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findUniqueOrThrow
   */
  export type AIConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation findFirst
   */
  export type AIConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findFirstOrThrow
   */
  export type AIConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversation to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIConversations.
     */
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation findMany
   */
  export type AIConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter, which AIConversations to fetch.
     */
    where?: AIConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIConversations to fetch.
     */
    orderBy?: AIConversationOrderByWithRelationInput | AIConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIConversations.
     */
    cursor?: AIConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIConversations.
     */
    skip?: number
    distinct?: AIConversationScalarFieldEnum | AIConversationScalarFieldEnum[]
  }

  /**
   * AIConversation create
   */
  export type AIConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIConversation.
     */
    data: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
  }

  /**
   * AIConversation createMany
   */
  export type AIConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIConversation createManyAndReturn
   */
  export type AIConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * The data used to create many AIConversations.
     */
    data: AIConversationCreateManyInput | AIConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIConversation update
   */
  export type AIConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIConversation.
     */
    data: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
    /**
     * Choose, which AIConversation to update.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation updateMany
   */
  export type AIConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIConversations.
     */
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyInput>
    /**
     * Filter which AIConversations to update
     */
    where?: AIConversationWhereInput
    /**
     * Limit how many AIConversations to update.
     */
    limit?: number
  }

  /**
   * AIConversation updateManyAndReturn
   */
  export type AIConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * The data used to update AIConversations.
     */
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyInput>
    /**
     * Filter which AIConversations to update
     */
    where?: AIConversationWhereInput
    /**
     * Limit how many AIConversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIConversation upsert
   */
  export type AIConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIConversation to update in case it exists.
     */
    where: AIConversationWhereUniqueInput
    /**
     * In case the AIConversation found by the `where` argument doesn't exist, create a new AIConversation with this data.
     */
    create: XOR<AIConversationCreateInput, AIConversationUncheckedCreateInput>
    /**
     * In case the AIConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIConversationUpdateInput, AIConversationUncheckedUpdateInput>
  }

  /**
   * AIConversation delete
   */
  export type AIConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
    /**
     * Filter which AIConversation to delete.
     */
    where: AIConversationWhereUniqueInput
  }

  /**
   * AIConversation deleteMany
   */
  export type AIConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIConversations to delete
     */
    where?: AIConversationWhereInput
    /**
     * Limit how many AIConversations to delete.
     */
    limit?: number
  }

  /**
   * AIConversation.messages
   */
  export type AIConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    where?: AIMessageWhereInput
    orderBy?: AIMessageOrderByWithRelationInput | AIMessageOrderByWithRelationInput[]
    cursor?: AIMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIMessageScalarFieldEnum | AIMessageScalarFieldEnum[]
  }

  /**
   * AIConversation without action
   */
  export type AIConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIConversation
     */
    select?: AIConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIConversation
     */
    omit?: AIConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIConversationInclude<ExtArgs> | null
  }


  /**
   * Model AIMessage
   */

  export type AggregateAIMessage = {
    _count: AIMessageCountAggregateOutputType | null
    _avg: AIMessageAvgAggregateOutputType | null
    _sum: AIMessageSumAggregateOutputType | null
    _min: AIMessageMinAggregateOutputType | null
    _max: AIMessageMaxAggregateOutputType | null
  }

  export type AIMessageAvgAggregateOutputType = {
    tokens: number | null
  }

  export type AIMessageSumAggregateOutputType = {
    tokens: number | null
  }

  export type AIMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    tokens: number | null
    createdAt: Date | null
  }

  export type AIMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    tokens: number | null
    createdAt: Date | null
  }

  export type AIMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    tokens: number
    createdAt: number
    _all: number
  }


  export type AIMessageAvgAggregateInputType = {
    tokens?: true
  }

  export type AIMessageSumAggregateInputType = {
    tokens?: true
  }

  export type AIMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokens?: true
    createdAt?: true
  }

  export type AIMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokens?: true
    createdAt?: true
  }

  export type AIMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokens?: true
    createdAt?: true
    _all?: true
  }

  export type AIMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIMessage to aggregate.
     */
    where?: AIMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIMessages to fetch.
     */
    orderBy?: AIMessageOrderByWithRelationInput | AIMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIMessages
    **/
    _count?: true | AIMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIMessageMaxAggregateInputType
  }

  export type GetAIMessageAggregateType<T extends AIMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAIMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIMessage[P]>
      : GetScalarType<T[P], AggregateAIMessage[P]>
  }




  export type AIMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIMessageWhereInput
    orderBy?: AIMessageOrderByWithAggregationInput | AIMessageOrderByWithAggregationInput[]
    by: AIMessageScalarFieldEnum[] | AIMessageScalarFieldEnum
    having?: AIMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIMessageCountAggregateInputType | true
    _avg?: AIMessageAvgAggregateInputType
    _sum?: AIMessageSumAggregateInputType
    _min?: AIMessageMinAggregateInputType
    _max?: AIMessageMaxAggregateInputType
  }

  export type AIMessageGroupByOutputType = {
    id: string
    conversationId: string
    role: string
    content: string
    tokens: number | null
    createdAt: Date
    _count: AIMessageCountAggregateOutputType | null
    _avg: AIMessageAvgAggregateOutputType | null
    _sum: AIMessageSumAggregateOutputType | null
    _min: AIMessageMinAggregateOutputType | null
    _max: AIMessageMaxAggregateOutputType | null
  }

  type GetAIMessageGroupByPayload<T extends AIMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AIMessageGroupByOutputType[P]>
        }
      >
    >


  export type AIMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokens?: boolean
    createdAt?: boolean
    conversation?: boolean | AIConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIMessage"]>

  export type AIMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokens?: boolean
    createdAt?: boolean
    conversation?: boolean | AIConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIMessage"]>

  export type AIMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokens?: boolean
    createdAt?: boolean
    conversation?: boolean | AIConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIMessage"]>

  export type AIMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    tokens?: boolean
    createdAt?: boolean
  }

  export type AIMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "role" | "content" | "tokens" | "createdAt", ExtArgs["result"]["aIMessage"]>
  export type AIMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AIConversationDefaultArgs<ExtArgs>
  }
  export type AIMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AIConversationDefaultArgs<ExtArgs>
  }
  export type AIMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AIConversationDefaultArgs<ExtArgs>
  }

  export type $AIMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIMessage"
    objects: {
      conversation: Prisma.$AIConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: string
      content: string
      tokens: number | null
      createdAt: Date
    }, ExtArgs["result"]["aIMessage"]>
    composites: {}
  }

  type AIMessageGetPayload<S extends boolean | null | undefined | AIMessageDefaultArgs> = $Result.GetResult<Prisma.$AIMessagePayload, S>

  type AIMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIMessageCountAggregateInputType | true
    }

  export interface AIMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIMessage'], meta: { name: 'AIMessage' } }
    /**
     * Find zero or one AIMessage that matches the filter.
     * @param {AIMessageFindUniqueArgs} args - Arguments to find a AIMessage
     * @example
     * // Get one AIMessage
     * const aIMessage = await prisma.aIMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIMessageFindUniqueArgs>(args: SelectSubset<T, AIMessageFindUniqueArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIMessageFindUniqueOrThrowArgs} args - Arguments to find a AIMessage
     * @example
     * // Get one AIMessage
     * const aIMessage = await prisma.aIMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AIMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageFindFirstArgs} args - Arguments to find a AIMessage
     * @example
     * // Get one AIMessage
     * const aIMessage = await prisma.aIMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIMessageFindFirstArgs>(args?: SelectSubset<T, AIMessageFindFirstArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageFindFirstOrThrowArgs} args - Arguments to find a AIMessage
     * @example
     * // Get one AIMessage
     * const aIMessage = await prisma.aIMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AIMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIMessages
     * const aIMessages = await prisma.aIMessage.findMany()
     * 
     * // Get first 10 AIMessages
     * const aIMessages = await prisma.aIMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIMessageWithIdOnly = await prisma.aIMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIMessageFindManyArgs>(args?: SelectSubset<T, AIMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIMessage.
     * @param {AIMessageCreateArgs} args - Arguments to create a AIMessage.
     * @example
     * // Create one AIMessage
     * const AIMessage = await prisma.aIMessage.create({
     *   data: {
     *     // ... data to create a AIMessage
     *   }
     * })
     * 
     */
    create<T extends AIMessageCreateArgs>(args: SelectSubset<T, AIMessageCreateArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIMessages.
     * @param {AIMessageCreateManyArgs} args - Arguments to create many AIMessages.
     * @example
     * // Create many AIMessages
     * const aIMessage = await prisma.aIMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIMessageCreateManyArgs>(args?: SelectSubset<T, AIMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIMessages and returns the data saved in the database.
     * @param {AIMessageCreateManyAndReturnArgs} args - Arguments to create many AIMessages.
     * @example
     * // Create many AIMessages
     * const aIMessage = await prisma.aIMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIMessages and only return the `id`
     * const aIMessageWithIdOnly = await prisma.aIMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AIMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIMessage.
     * @param {AIMessageDeleteArgs} args - Arguments to delete one AIMessage.
     * @example
     * // Delete one AIMessage
     * const AIMessage = await prisma.aIMessage.delete({
     *   where: {
     *     // ... filter to delete one AIMessage
     *   }
     * })
     * 
     */
    delete<T extends AIMessageDeleteArgs>(args: SelectSubset<T, AIMessageDeleteArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIMessage.
     * @param {AIMessageUpdateArgs} args - Arguments to update one AIMessage.
     * @example
     * // Update one AIMessage
     * const aIMessage = await prisma.aIMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIMessageUpdateArgs>(args: SelectSubset<T, AIMessageUpdateArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIMessages.
     * @param {AIMessageDeleteManyArgs} args - Arguments to filter AIMessages to delete.
     * @example
     * // Delete a few AIMessages
     * const { count } = await prisma.aIMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIMessageDeleteManyArgs>(args?: SelectSubset<T, AIMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIMessages
     * const aIMessage = await prisma.aIMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIMessageUpdateManyArgs>(args: SelectSubset<T, AIMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIMessages and returns the data updated in the database.
     * @param {AIMessageUpdateManyAndReturnArgs} args - Arguments to update many AIMessages.
     * @example
     * // Update many AIMessages
     * const aIMessage = await prisma.aIMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIMessages and only return the `id`
     * const aIMessageWithIdOnly = await prisma.aIMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, AIMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIMessage.
     * @param {AIMessageUpsertArgs} args - Arguments to update or create a AIMessage.
     * @example
     * // Update or create a AIMessage
     * const aIMessage = await prisma.aIMessage.upsert({
     *   create: {
     *     // ... data to create a AIMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIMessage we want to update
     *   }
     * })
     */
    upsert<T extends AIMessageUpsertArgs>(args: SelectSubset<T, AIMessageUpsertArgs<ExtArgs>>): Prisma__AIMessageClient<$Result.GetResult<Prisma.$AIMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageCountArgs} args - Arguments to filter AIMessages to count.
     * @example
     * // Count the number of AIMessages
     * const count = await prisma.aIMessage.count({
     *   where: {
     *     // ... the filter for the AIMessages we want to count
     *   }
     * })
    **/
    count<T extends AIMessageCountArgs>(
      args?: Subset<T, AIMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIMessageAggregateArgs>(args: Subset<T, AIMessageAggregateArgs>): Prisma.PrismaPromise<GetAIMessageAggregateType<T>>

    /**
     * Group by AIMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIMessageGroupByArgs['orderBy'] }
        : { orderBy?: AIMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIMessage model
   */
  readonly fields: AIMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends AIConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIConversationDefaultArgs<ExtArgs>>): Prisma__AIConversationClient<$Result.GetResult<Prisma.$AIConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIMessage model
   */
  interface AIMessageFieldRefs {
    readonly id: FieldRef<"AIMessage", 'String'>
    readonly conversationId: FieldRef<"AIMessage", 'String'>
    readonly role: FieldRef<"AIMessage", 'String'>
    readonly content: FieldRef<"AIMessage", 'String'>
    readonly tokens: FieldRef<"AIMessage", 'Int'>
    readonly createdAt: FieldRef<"AIMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIMessage findUnique
   */
  export type AIMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIMessage to fetch.
     */
    where: AIMessageWhereUniqueInput
  }

  /**
   * AIMessage findUniqueOrThrow
   */
  export type AIMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIMessage to fetch.
     */
    where: AIMessageWhereUniqueInput
  }

  /**
   * AIMessage findFirst
   */
  export type AIMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIMessage to fetch.
     */
    where?: AIMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIMessages to fetch.
     */
    orderBy?: AIMessageOrderByWithRelationInput | AIMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIMessages.
     */
    cursor?: AIMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIMessages.
     */
    distinct?: AIMessageScalarFieldEnum | AIMessageScalarFieldEnum[]
  }

  /**
   * AIMessage findFirstOrThrow
   */
  export type AIMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIMessage to fetch.
     */
    where?: AIMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIMessages to fetch.
     */
    orderBy?: AIMessageOrderByWithRelationInput | AIMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIMessages.
     */
    cursor?: AIMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIMessages.
     */
    distinct?: AIMessageScalarFieldEnum | AIMessageScalarFieldEnum[]
  }

  /**
   * AIMessage findMany
   */
  export type AIMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIMessages to fetch.
     */
    where?: AIMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIMessages to fetch.
     */
    orderBy?: AIMessageOrderByWithRelationInput | AIMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIMessages.
     */
    cursor?: AIMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIMessages.
     */
    skip?: number
    distinct?: AIMessageScalarFieldEnum | AIMessageScalarFieldEnum[]
  }

  /**
   * AIMessage create
   */
  export type AIMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AIMessage.
     */
    data: XOR<AIMessageCreateInput, AIMessageUncheckedCreateInput>
  }

  /**
   * AIMessage createMany
   */
  export type AIMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIMessages.
     */
    data: AIMessageCreateManyInput | AIMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIMessage createManyAndReturn
   */
  export type AIMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * The data used to create many AIMessages.
     */
    data: AIMessageCreateManyInput | AIMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIMessage update
   */
  export type AIMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AIMessage.
     */
    data: XOR<AIMessageUpdateInput, AIMessageUncheckedUpdateInput>
    /**
     * Choose, which AIMessage to update.
     */
    where: AIMessageWhereUniqueInput
  }

  /**
   * AIMessage updateMany
   */
  export type AIMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIMessages.
     */
    data: XOR<AIMessageUpdateManyMutationInput, AIMessageUncheckedUpdateManyInput>
    /**
     * Filter which AIMessages to update
     */
    where?: AIMessageWhereInput
    /**
     * Limit how many AIMessages to update.
     */
    limit?: number
  }

  /**
   * AIMessage updateManyAndReturn
   */
  export type AIMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * The data used to update AIMessages.
     */
    data: XOR<AIMessageUpdateManyMutationInput, AIMessageUncheckedUpdateManyInput>
    /**
     * Filter which AIMessages to update
     */
    where?: AIMessageWhereInput
    /**
     * Limit how many AIMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIMessage upsert
   */
  export type AIMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AIMessage to update in case it exists.
     */
    where: AIMessageWhereUniqueInput
    /**
     * In case the AIMessage found by the `where` argument doesn't exist, create a new AIMessage with this data.
     */
    create: XOR<AIMessageCreateInput, AIMessageUncheckedCreateInput>
    /**
     * In case the AIMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIMessageUpdateInput, AIMessageUncheckedUpdateInput>
  }

  /**
   * AIMessage delete
   */
  export type AIMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
    /**
     * Filter which AIMessage to delete.
     */
    where: AIMessageWhereUniqueInput
  }

  /**
   * AIMessage deleteMany
   */
  export type AIMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIMessages to delete
     */
    where?: AIMessageWhereInput
    /**
     * Limit how many AIMessages to delete.
     */
    limit?: number
  }

  /**
   * AIMessage without action
   */
  export type AIMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIMessage
     */
    select?: AIMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIMessage
     */
    omit?: AIMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIMessageInclude<ExtArgs> | null
  }


  /**
   * Model AIUsageLog
   */

  export type AggregateAIUsageLog = {
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  export type AIUsageLogAvgAggregateOutputType = {
    tokensUsed: number | null
    cost: Decimal | null
  }

  export type AIUsageLogSumAggregateOutputType = {
    tokensUsed: number | null
    cost: Decimal | null
  }

  export type AIUsageLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
    classroomId: string | null
    promptSummary: string | null
    responseSummary: string | null
    tokensUsed: number | null
    cost: Decimal | null
    createdAt: Date | null
  }

  export type AIUsageLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
    classroomId: string | null
    promptSummary: string | null
    responseSummary: string | null
    tokensUsed: number | null
    cost: Decimal | null
    createdAt: Date | null
  }

  export type AIUsageLogCountAggregateOutputType = {
    id: number
    userId: number
    institutionId: number
    classroomId: number
    promptSummary: number
    responseSummary: number
    tokensUsed: number
    cost: number
    createdAt: number
    _all: number
  }


  export type AIUsageLogAvgAggregateInputType = {
    tokensUsed?: true
    cost?: true
  }

  export type AIUsageLogSumAggregateInputType = {
    tokensUsed?: true
    cost?: true
  }

  export type AIUsageLogMinAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    classroomId?: true
    promptSummary?: true
    responseSummary?: true
    tokensUsed?: true
    cost?: true
    createdAt?: true
  }

  export type AIUsageLogMaxAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    classroomId?: true
    promptSummary?: true
    responseSummary?: true
    tokensUsed?: true
    cost?: true
    createdAt?: true
  }

  export type AIUsageLogCountAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    classroomId?: true
    promptSummary?: true
    responseSummary?: true
    tokensUsed?: true
    cost?: true
    createdAt?: true
    _all?: true
  }

  export type AIUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLog to aggregate.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsageLogs
    **/
    _count?: true | AIUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type GetAIUsageLogAggregateType<T extends AIUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsageLog[P]>
      : GetScalarType<T[P], AggregateAIUsageLog[P]>
  }




  export type AIUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithAggregationInput | AIUsageLogOrderByWithAggregationInput[]
    by: AIUsageLogScalarFieldEnum[] | AIUsageLogScalarFieldEnum
    having?: AIUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageLogCountAggregateInputType | true
    _avg?: AIUsageLogAvgAggregateInputType
    _sum?: AIUsageLogSumAggregateInputType
    _min?: AIUsageLogMinAggregateInputType
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type AIUsageLogGroupByOutputType = {
    id: string
    userId: string
    institutionId: string
    classroomId: string | null
    promptSummary: string | null
    responseSummary: string | null
    tokensUsed: number | null
    cost: Decimal | null
    createdAt: Date
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  type GetAIUsageLogGroupByPayload<T extends AIUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    classroomId?: boolean
    promptSummary?: boolean
    responseSummary?: boolean
    tokensUsed?: boolean
    cost?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    classroom?: boolean | AIUsageLog$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    classroomId?: boolean
    promptSummary?: boolean
    responseSummary?: boolean
    tokensUsed?: boolean
    cost?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    classroom?: boolean | AIUsageLog$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    classroomId?: boolean
    promptSummary?: boolean
    responseSummary?: boolean
    tokensUsed?: boolean
    cost?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    classroom?: boolean | AIUsageLog$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectScalar = {
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    classroomId?: boolean
    promptSummary?: boolean
    responseSummary?: boolean
    tokensUsed?: boolean
    cost?: boolean
    createdAt?: boolean
  }

  export type AIUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "institutionId" | "classroomId" | "promptSummary" | "responseSummary" | "tokensUsed" | "cost" | "createdAt", ExtArgs["result"]["aIUsageLog"]>
  export type AIUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    classroom?: boolean | AIUsageLog$classroomArgs<ExtArgs>
  }
  export type AIUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    classroom?: boolean | AIUsageLog$classroomArgs<ExtArgs>
  }
  export type AIUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    classroom?: boolean | AIUsageLog$classroomArgs<ExtArgs>
  }

  export type $AIUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsageLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
      classroom: Prisma.$VirtualClassroomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      institutionId: string
      classroomId: string | null
      promptSummary: string | null
      responseSummary: string | null
      tokensUsed: number | null
      cost: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["aIUsageLog"]>
    composites: {}
  }

  type AIUsageLogGetPayload<S extends boolean | null | undefined | AIUsageLogDefaultArgs> = $Result.GetResult<Prisma.$AIUsageLogPayload, S>

  type AIUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIUsageLogCountAggregateInputType | true
    }

  export interface AIUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsageLog'], meta: { name: 'AIUsageLog' } }
    /**
     * Find zero or one AIUsageLog that matches the filter.
     * @param {AIUsageLogFindUniqueArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageLogFindUniqueArgs>(args: SelectSubset<T, AIUsageLogFindUniqueArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIUsageLogFindUniqueOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageLogFindFirstArgs>(args?: SelectSubset<T, AIUsageLogFindFirstArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany()
     * 
     * // Get first 10 AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageLogFindManyArgs>(args?: SelectSubset<T, AIUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIUsageLog.
     * @param {AIUsageLogCreateArgs} args - Arguments to create a AIUsageLog.
     * @example
     * // Create one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.create({
     *   data: {
     *     // ... data to create a AIUsageLog
     *   }
     * })
     * 
     */
    create<T extends AIUsageLogCreateArgs>(args: SelectSubset<T, AIUsageLogCreateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIUsageLogs.
     * @param {AIUsageLogCreateManyArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageLogCreateManyArgs>(args?: SelectSubset<T, AIUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsageLogs and returns the data saved in the database.
     * @param {AIUsageLogCreateManyAndReturnArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIUsageLog.
     * @param {AIUsageLogDeleteArgs} args - Arguments to delete one AIUsageLog.
     * @example
     * // Delete one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.delete({
     *   where: {
     *     // ... filter to delete one AIUsageLog
     *   }
     * })
     * 
     */
    delete<T extends AIUsageLogDeleteArgs>(args: SelectSubset<T, AIUsageLogDeleteArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIUsageLog.
     * @param {AIUsageLogUpdateArgs} args - Arguments to update one AIUsageLog.
     * @example
     * // Update one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageLogUpdateArgs>(args: SelectSubset<T, AIUsageLogUpdateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIUsageLogs.
     * @param {AIUsageLogDeleteManyArgs} args - Arguments to filter AIUsageLogs to delete.
     * @example
     * // Delete a few AIUsageLogs
     * const { count } = await prisma.aIUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageLogDeleteManyArgs>(args?: SelectSubset<T, AIUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageLogUpdateManyArgs>(args: SelectSubset<T, AIUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs and returns the data updated in the database.
     * @param {AIUsageLogUpdateManyAndReturnArgs} args - Arguments to update many AIUsageLogs.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AIUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIUsageLog.
     * @param {AIUsageLogUpsertArgs} args - Arguments to update or create a AIUsageLog.
     * @example
     * // Update or create a AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.upsert({
     *   create: {
     *     // ... data to create a AIUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageLogUpsertArgs>(args: SelectSubset<T, AIUsageLogUpsertArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogCountArgs} args - Arguments to filter AIUsageLogs to count.
     * @example
     * // Count the number of AIUsageLogs
     * const count = await prisma.aIUsageLog.count({
     *   where: {
     *     // ... the filter for the AIUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends AIUsageLogCountArgs>(
      args?: Subset<T, AIUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageLogAggregateArgs>(args: Subset<T, AIUsageLogAggregateArgs>): Prisma.PrismaPromise<GetAIUsageLogAggregateType<T>>

    /**
     * Group by AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsageLog model
   */
  readonly fields: AIUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classroom<T extends AIUsageLog$classroomArgs<ExtArgs> = {}>(args?: Subset<T, AIUsageLog$classroomArgs<ExtArgs>>): Prisma__VirtualClassroomClient<$Result.GetResult<Prisma.$VirtualClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsageLog model
   */
  interface AIUsageLogFieldRefs {
    readonly id: FieldRef<"AIUsageLog", 'String'>
    readonly userId: FieldRef<"AIUsageLog", 'String'>
    readonly institutionId: FieldRef<"AIUsageLog", 'String'>
    readonly classroomId: FieldRef<"AIUsageLog", 'String'>
    readonly promptSummary: FieldRef<"AIUsageLog", 'String'>
    readonly responseSummary: FieldRef<"AIUsageLog", 'String'>
    readonly tokensUsed: FieldRef<"AIUsageLog", 'Int'>
    readonly cost: FieldRef<"AIUsageLog", 'Decimal'>
    readonly createdAt: FieldRef<"AIUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIUsageLog findUnique
   */
  export type AIUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findUniqueOrThrow
   */
  export type AIUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findFirst
   */
  export type AIUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findFirstOrThrow
   */
  export type AIUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findMany
   */
  export type AIUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLogs to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog create
   */
  export type AIUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AIUsageLog.
     */
    data: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
  }

  /**
   * AIUsageLog createMany
   */
  export type AIUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageLog createManyAndReturn
   */
  export type AIUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIUsageLog update
   */
  export type AIUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AIUsageLog.
     */
    data: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
    /**
     * Choose, which AIUsageLog to update.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog updateMany
   */
  export type AIUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to update.
     */
    limit?: number
  }

  /**
   * AIUsageLog updateManyAndReturn
   */
  export type AIUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIUsageLog upsert
   */
  export type AIUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AIUsageLog to update in case it exists.
     */
    where: AIUsageLogWhereUniqueInput
    /**
     * In case the AIUsageLog found by the `where` argument doesn't exist, create a new AIUsageLog with this data.
     */
    create: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
    /**
     * In case the AIUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
  }

  /**
   * AIUsageLog delete
   */
  export type AIUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter which AIUsageLog to delete.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog deleteMany
   */
  export type AIUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLogs to delete
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * AIUsageLog.classroom
   */
  export type AIUsageLog$classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassroom
     */
    select?: VirtualClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualClassroom
     */
    omit?: VirtualClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassroomInclude<ExtArgs> | null
    where?: VirtualClassroomWhereInput
  }

  /**
   * AIUsageLog without action
   */
  export type AIUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    title: string | null
    body: string | null
    isRead: boolean | null
    readAt: Date | null
    pushSent: boolean | null
    emailSent: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    title: string | null
    body: string | null
    isRead: boolean | null
    readAt: Date | null
    pushSent: boolean | null
    emailSent: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    title: number
    body: number
    meta: number
    isRead: number
    readAt: number
    pushSent: number
    emailSent: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    title?: true
    body?: true
    isRead?: true
    readAt?: true
    pushSent?: true
    emailSent?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    title?: true
    body?: true
    isRead?: true
    readAt?: true
    pushSent?: true
    emailSent?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    title?: true
    body?: true
    meta?: true
    isRead?: true
    readAt?: true
    pushSent?: true
    emailSent?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    title: string
    body: string
    meta: JsonValue | null
    isRead: boolean
    readAt: Date | null
    pushSent: boolean
    emailSent: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    meta?: boolean
    isRead?: boolean
    readAt?: boolean
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    meta?: boolean
    isRead?: boolean
    readAt?: boolean
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    meta?: boolean
    isRead?: boolean
    readAt?: boolean
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    meta?: boolean
    isRead?: boolean
    readAt?: boolean
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipientId" | "title" | "body" | "meta" | "isRead" | "readAt" | "pushSent" | "emailSent" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      title: string
      body: string
      meta: Prisma.JsonValue | null
      isRead: boolean
      readAt: Date | null
      pushSent: boolean
      emailSent: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly meta: FieldRef<"Notification", 'Json'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly pushSent: FieldRef<"Notification", 'Boolean'>
    readonly emailSent: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    preferences: number
    createdAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    preferences?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    preferences: JsonValue | null
    createdAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "preferences" | "createdAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      preferences: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly preferences: FieldRef<"NotificationPreference", 'Json'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    subject: string | null
    body: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    subject: string | null
    body: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    recipientId: number
    subject: number
    body: number
    attachments: number
    isRead: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    subject?: true
    body?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    subject?: true
    body?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    subject?: true
    body?: true
    attachments?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    recipientId: string
    subject: string | null
    body: string
    attachments: JsonValue | null
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    body?: boolean
    attachments?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    body?: boolean
    attachments?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    body?: boolean
    attachments?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    body?: boolean
    attachments?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "recipientId" | "subject" | "body" | "attachments" | "isRead" | "readAt" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      recipientId: string
      subject: string | null
      body: string
      attachments: Prisma.JsonValue | null
      isRead: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientId: FieldRef<"Message", 'String'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly body: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'Json'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    title: string | null
    body: string | null
    startsAt: Date | null
    endsAt: Date | null
    createdById: string | null
    createdAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    title: string | null
    body: string | null
    startsAt: Date | null
    endsAt: Date | null
    createdById: string | null
    createdAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    institutionId: number
    title: number
    body: number
    targetRoles: number
    startsAt: number
    endsAt: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    institutionId?: true
    title?: true
    body?: true
    startsAt?: true
    endsAt?: true
    createdById?: true
    createdAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    institutionId?: true
    title?: true
    body?: true
    startsAt?: true
    endsAt?: true
    createdById?: true
    createdAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    institutionId?: true
    title?: true
    body?: true
    targetRoles?: true
    startsAt?: true
    endsAt?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    institutionId: string
    title: string
    body: string
    targetRoles: string[]
    startsAt: Date | null
    endsAt: Date | null
    createdById: string | null
    createdAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    title?: boolean
    body?: boolean
    targetRoles?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Announcement$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    title?: boolean
    body?: boolean
    targetRoles?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Announcement$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    title?: boolean
    body?: boolean
    targetRoles?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Announcement$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    institutionId?: boolean
    title?: boolean
    body?: boolean
    targetRoles?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "title" | "body" | "targetRoles" | "startsAt" | "endsAt" | "createdById" | "createdAt", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Announcement$createdByArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Announcement$createdByArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Announcement$createdByArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      title: string
      body: string
      targetRoles: string[]
      startsAt: Date | null
      endsAt: Date | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Announcement$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly institutionId: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly body: FieldRef<"Announcement", 'String'>
    readonly targetRoles: FieldRef<"Announcement", 'String[]'>
    readonly startsAt: FieldRef<"Announcement", 'DateTime'>
    readonly endsAt: FieldRef<"Announcement", 'DateTime'>
    readonly createdById: FieldRef<"Announcement", 'String'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement.createdBy
   */
  export type Announcement$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model DataBackup
   */

  export type AggregateDataBackup = {
    _count: DataBackupCountAggregateOutputType | null
    _avg: DataBackupAvgAggregateOutputType | null
    _sum: DataBackupSumAggregateOutputType | null
    _min: DataBackupMinAggregateOutputType | null
    _max: DataBackupMaxAggregateOutputType | null
  }

  export type DataBackupAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type DataBackupSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type DataBackupMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    description: string | null
    storageUrl: string | null
    sizeBytes: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type DataBackupMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    description: string | null
    storageUrl: string | null
    sizeBytes: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type DataBackupCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    description: number
    storageUrl: number
    sizeBytes: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type DataBackupAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type DataBackupSumAggregateInputType = {
    sizeBytes?: true
  }

  export type DataBackupMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    storageUrl?: true
    sizeBytes?: true
    createdById?: true
    createdAt?: true
  }

  export type DataBackupMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    storageUrl?: true
    sizeBytes?: true
    createdById?: true
    createdAt?: true
  }

  export type DataBackupCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    description?: true
    storageUrl?: true
    sizeBytes?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type DataBackupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataBackup to aggregate.
     */
    where?: DataBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataBackups to fetch.
     */
    orderBy?: DataBackupOrderByWithRelationInput | DataBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataBackups
    **/
    _count?: true | DataBackupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataBackupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataBackupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataBackupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataBackupMaxAggregateInputType
  }

  export type GetDataBackupAggregateType<T extends DataBackupAggregateArgs> = {
        [P in keyof T & keyof AggregateDataBackup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataBackup[P]>
      : GetScalarType<T[P], AggregateDataBackup[P]>
  }




  export type DataBackupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataBackupWhereInput
    orderBy?: DataBackupOrderByWithAggregationInput | DataBackupOrderByWithAggregationInput[]
    by: DataBackupScalarFieldEnum[] | DataBackupScalarFieldEnum
    having?: DataBackupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataBackupCountAggregateInputType | true
    _avg?: DataBackupAvgAggregateInputType
    _sum?: DataBackupSumAggregateInputType
    _min?: DataBackupMinAggregateInputType
    _max?: DataBackupMaxAggregateInputType
  }

  export type DataBackupGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    description: string | null
    storageUrl: string
    sizeBytes: number | null
    createdById: string | null
    createdAt: Date
    _count: DataBackupCountAggregateOutputType | null
    _avg: DataBackupAvgAggregateOutputType | null
    _sum: DataBackupSumAggregateOutputType | null
    _min: DataBackupMinAggregateOutputType | null
    _max: DataBackupMaxAggregateOutputType | null
  }

  type GetDataBackupGroupByPayload<T extends DataBackupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataBackupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataBackupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataBackupGroupByOutputType[P]>
            : GetScalarType<T[P], DataBackupGroupByOutputType[P]>
        }
      >
    >


  export type DataBackupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    storageUrl?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | DataBackup$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["dataBackup"]>

  export type DataBackupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    storageUrl?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | DataBackup$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["dataBackup"]>

  export type DataBackupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    storageUrl?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | DataBackup$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["dataBackup"]>

  export type DataBackupSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    description?: boolean
    storageUrl?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type DataBackupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "description" | "storageUrl" | "sizeBytes" | "createdById" | "createdAt", ExtArgs["result"]["dataBackup"]>
  export type DataBackupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | DataBackup$createdByArgs<ExtArgs>
  }
  export type DataBackupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | DataBackup$createdByArgs<ExtArgs>
  }
  export type DataBackupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | DataBackup$createdByArgs<ExtArgs>
  }

  export type $DataBackupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataBackup"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      description: string | null
      storageUrl: string
      sizeBytes: number | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["dataBackup"]>
    composites: {}
  }

  type DataBackupGetPayload<S extends boolean | null | undefined | DataBackupDefaultArgs> = $Result.GetResult<Prisma.$DataBackupPayload, S>

  type DataBackupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataBackupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataBackupCountAggregateInputType | true
    }

  export interface DataBackupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataBackup'], meta: { name: 'DataBackup' } }
    /**
     * Find zero or one DataBackup that matches the filter.
     * @param {DataBackupFindUniqueArgs} args - Arguments to find a DataBackup
     * @example
     * // Get one DataBackup
     * const dataBackup = await prisma.dataBackup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataBackupFindUniqueArgs>(args: SelectSubset<T, DataBackupFindUniqueArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataBackup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataBackupFindUniqueOrThrowArgs} args - Arguments to find a DataBackup
     * @example
     * // Get one DataBackup
     * const dataBackup = await prisma.dataBackup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataBackupFindUniqueOrThrowArgs>(args: SelectSubset<T, DataBackupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataBackup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupFindFirstArgs} args - Arguments to find a DataBackup
     * @example
     * // Get one DataBackup
     * const dataBackup = await prisma.dataBackup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataBackupFindFirstArgs>(args?: SelectSubset<T, DataBackupFindFirstArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataBackup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupFindFirstOrThrowArgs} args - Arguments to find a DataBackup
     * @example
     * // Get one DataBackup
     * const dataBackup = await prisma.dataBackup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataBackupFindFirstOrThrowArgs>(args?: SelectSubset<T, DataBackupFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataBackups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataBackups
     * const dataBackups = await prisma.dataBackup.findMany()
     * 
     * // Get first 10 DataBackups
     * const dataBackups = await prisma.dataBackup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataBackupWithIdOnly = await prisma.dataBackup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataBackupFindManyArgs>(args?: SelectSubset<T, DataBackupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataBackup.
     * @param {DataBackupCreateArgs} args - Arguments to create a DataBackup.
     * @example
     * // Create one DataBackup
     * const DataBackup = await prisma.dataBackup.create({
     *   data: {
     *     // ... data to create a DataBackup
     *   }
     * })
     * 
     */
    create<T extends DataBackupCreateArgs>(args: SelectSubset<T, DataBackupCreateArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataBackups.
     * @param {DataBackupCreateManyArgs} args - Arguments to create many DataBackups.
     * @example
     * // Create many DataBackups
     * const dataBackup = await prisma.dataBackup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataBackupCreateManyArgs>(args?: SelectSubset<T, DataBackupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataBackups and returns the data saved in the database.
     * @param {DataBackupCreateManyAndReturnArgs} args - Arguments to create many DataBackups.
     * @example
     * // Create many DataBackups
     * const dataBackup = await prisma.dataBackup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataBackups and only return the `id`
     * const dataBackupWithIdOnly = await prisma.dataBackup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataBackupCreateManyAndReturnArgs>(args?: SelectSubset<T, DataBackupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataBackup.
     * @param {DataBackupDeleteArgs} args - Arguments to delete one DataBackup.
     * @example
     * // Delete one DataBackup
     * const DataBackup = await prisma.dataBackup.delete({
     *   where: {
     *     // ... filter to delete one DataBackup
     *   }
     * })
     * 
     */
    delete<T extends DataBackupDeleteArgs>(args: SelectSubset<T, DataBackupDeleteArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataBackup.
     * @param {DataBackupUpdateArgs} args - Arguments to update one DataBackup.
     * @example
     * // Update one DataBackup
     * const dataBackup = await prisma.dataBackup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataBackupUpdateArgs>(args: SelectSubset<T, DataBackupUpdateArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataBackups.
     * @param {DataBackupDeleteManyArgs} args - Arguments to filter DataBackups to delete.
     * @example
     * // Delete a few DataBackups
     * const { count } = await prisma.dataBackup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataBackupDeleteManyArgs>(args?: SelectSubset<T, DataBackupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataBackups
     * const dataBackup = await prisma.dataBackup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataBackupUpdateManyArgs>(args: SelectSubset<T, DataBackupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataBackups and returns the data updated in the database.
     * @param {DataBackupUpdateManyAndReturnArgs} args - Arguments to update many DataBackups.
     * @example
     * // Update many DataBackups
     * const dataBackup = await prisma.dataBackup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataBackups and only return the `id`
     * const dataBackupWithIdOnly = await prisma.dataBackup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataBackupUpdateManyAndReturnArgs>(args: SelectSubset<T, DataBackupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataBackup.
     * @param {DataBackupUpsertArgs} args - Arguments to update or create a DataBackup.
     * @example
     * // Update or create a DataBackup
     * const dataBackup = await prisma.dataBackup.upsert({
     *   create: {
     *     // ... data to create a DataBackup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataBackup we want to update
     *   }
     * })
     */
    upsert<T extends DataBackupUpsertArgs>(args: SelectSubset<T, DataBackupUpsertArgs<ExtArgs>>): Prisma__DataBackupClient<$Result.GetResult<Prisma.$DataBackupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupCountArgs} args - Arguments to filter DataBackups to count.
     * @example
     * // Count the number of DataBackups
     * const count = await prisma.dataBackup.count({
     *   where: {
     *     // ... the filter for the DataBackups we want to count
     *   }
     * })
    **/
    count<T extends DataBackupCountArgs>(
      args?: Subset<T, DataBackupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataBackupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataBackupAggregateArgs>(args: Subset<T, DataBackupAggregateArgs>): Prisma.PrismaPromise<GetDataBackupAggregateType<T>>

    /**
     * Group by DataBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataBackupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataBackupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataBackupGroupByArgs['orderBy'] }
        : { orderBy?: DataBackupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataBackupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataBackupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataBackup model
   */
  readonly fields: DataBackupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataBackup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataBackupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends DataBackup$createdByArgs<ExtArgs> = {}>(args?: Subset<T, DataBackup$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataBackup model
   */
  interface DataBackupFieldRefs {
    readonly id: FieldRef<"DataBackup", 'String'>
    readonly institutionId: FieldRef<"DataBackup", 'String'>
    readonly name: FieldRef<"DataBackup", 'String'>
    readonly description: FieldRef<"DataBackup", 'String'>
    readonly storageUrl: FieldRef<"DataBackup", 'String'>
    readonly sizeBytes: FieldRef<"DataBackup", 'Int'>
    readonly createdById: FieldRef<"DataBackup", 'String'>
    readonly createdAt: FieldRef<"DataBackup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataBackup findUnique
   */
  export type DataBackupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * Filter, which DataBackup to fetch.
     */
    where: DataBackupWhereUniqueInput
  }

  /**
   * DataBackup findUniqueOrThrow
   */
  export type DataBackupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * Filter, which DataBackup to fetch.
     */
    where: DataBackupWhereUniqueInput
  }

  /**
   * DataBackup findFirst
   */
  export type DataBackupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * Filter, which DataBackup to fetch.
     */
    where?: DataBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataBackups to fetch.
     */
    orderBy?: DataBackupOrderByWithRelationInput | DataBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataBackups.
     */
    cursor?: DataBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataBackups.
     */
    distinct?: DataBackupScalarFieldEnum | DataBackupScalarFieldEnum[]
  }

  /**
   * DataBackup findFirstOrThrow
   */
  export type DataBackupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * Filter, which DataBackup to fetch.
     */
    where?: DataBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataBackups to fetch.
     */
    orderBy?: DataBackupOrderByWithRelationInput | DataBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataBackups.
     */
    cursor?: DataBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataBackups.
     */
    distinct?: DataBackupScalarFieldEnum | DataBackupScalarFieldEnum[]
  }

  /**
   * DataBackup findMany
   */
  export type DataBackupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * Filter, which DataBackups to fetch.
     */
    where?: DataBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataBackups to fetch.
     */
    orderBy?: DataBackupOrderByWithRelationInput | DataBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataBackups.
     */
    cursor?: DataBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataBackups.
     */
    skip?: number
    distinct?: DataBackupScalarFieldEnum | DataBackupScalarFieldEnum[]
  }

  /**
   * DataBackup create
   */
  export type DataBackupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * The data needed to create a DataBackup.
     */
    data: XOR<DataBackupCreateInput, DataBackupUncheckedCreateInput>
  }

  /**
   * DataBackup createMany
   */
  export type DataBackupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataBackups.
     */
    data: DataBackupCreateManyInput | DataBackupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataBackup createManyAndReturn
   */
  export type DataBackupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * The data used to create many DataBackups.
     */
    data: DataBackupCreateManyInput | DataBackupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataBackup update
   */
  export type DataBackupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * The data needed to update a DataBackup.
     */
    data: XOR<DataBackupUpdateInput, DataBackupUncheckedUpdateInput>
    /**
     * Choose, which DataBackup to update.
     */
    where: DataBackupWhereUniqueInput
  }

  /**
   * DataBackup updateMany
   */
  export type DataBackupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataBackups.
     */
    data: XOR<DataBackupUpdateManyMutationInput, DataBackupUncheckedUpdateManyInput>
    /**
     * Filter which DataBackups to update
     */
    where?: DataBackupWhereInput
    /**
     * Limit how many DataBackups to update.
     */
    limit?: number
  }

  /**
   * DataBackup updateManyAndReturn
   */
  export type DataBackupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * The data used to update DataBackups.
     */
    data: XOR<DataBackupUpdateManyMutationInput, DataBackupUncheckedUpdateManyInput>
    /**
     * Filter which DataBackups to update
     */
    where?: DataBackupWhereInput
    /**
     * Limit how many DataBackups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataBackup upsert
   */
  export type DataBackupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * The filter to search for the DataBackup to update in case it exists.
     */
    where: DataBackupWhereUniqueInput
    /**
     * In case the DataBackup found by the `where` argument doesn't exist, create a new DataBackup with this data.
     */
    create: XOR<DataBackupCreateInput, DataBackupUncheckedCreateInput>
    /**
     * In case the DataBackup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataBackupUpdateInput, DataBackupUncheckedUpdateInput>
  }

  /**
   * DataBackup delete
   */
  export type DataBackupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
    /**
     * Filter which DataBackup to delete.
     */
    where: DataBackupWhereUniqueInput
  }

  /**
   * DataBackup deleteMany
   */
  export type DataBackupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataBackups to delete
     */
    where?: DataBackupWhereInput
    /**
     * Limit how many DataBackups to delete.
     */
    limit?: number
  }

  /**
   * DataBackup.createdBy
   */
  export type DataBackup$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DataBackup without action
   */
  export type DataBackupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataBackup
     */
    select?: DataBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataBackup
     */
    omit?: DataBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataBackupInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    type: string | null
    body: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    type: string | null
    body: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    type: number
    body: number
    metadata: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    type?: true
    body?: true
    createdById?: true
    createdAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    type?: true
    body?: true
    createdById?: true
    createdAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    type?: true
    body?: true
    metadata?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    type: string
    body: string
    metadata: JsonValue | null
    createdById: string | null
    createdAt: Date
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    type?: boolean
    body?: boolean
    metadata?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Template$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    type?: boolean
    body?: boolean
    metadata?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Template$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    type?: boolean
    body?: boolean
    metadata?: boolean
    createdById?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Template$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    type?: boolean
    body?: boolean
    metadata?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type TemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "type" | "body" | "metadata" | "createdById" | "createdAt", ExtArgs["result"]["template"]>
  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Template$createdByArgs<ExtArgs>
  }
  export type TemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Template$createdByArgs<ExtArgs>
  }
  export type TemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    createdBy?: boolean | Template$createdByArgs<ExtArgs>
  }

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      type: string
      body: string
      metadata: Prisma.JsonValue | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {TemplateCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates and returns the data updated in the database.
     * @param {TemplateUpdateManyAndReturnArgs} args - Arguments to update many Templates.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Template$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Template$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly institutionId: FieldRef<"Template", 'String'>
    readonly name: FieldRef<"Template", 'String'>
    readonly type: FieldRef<"Template", 'String'>
    readonly body: FieldRef<"Template", 'String'>
    readonly metadata: FieldRef<"Template", 'Json'>
    readonly createdById: FieldRef<"Template", 'String'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template createManyAndReturn
   */
  export type TemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template updateManyAndReturn
   */
  export type TemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to delete.
     */
    limit?: number
  }

  /**
   * Template.createdBy
   */
  export type Template$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    config: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    isActive?: true
    createdAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    isActive?: true
    createdAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    config?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    config: JsonValue | null
    isActive: boolean
    createdAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "config" | "isActive" | "createdAt", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      config: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {IntegrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly institutionId: FieldRef<"Integration", 'String'>
    readonly name: FieldRef<"Integration", 'String'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration updateManyAndReturn
   */
  export type IntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model ApiClient
   */

  export type AggregateApiClient = {
    _count: ApiClientCountAggregateOutputType | null
    _min: ApiClientMinAggregateOutputType | null
    _max: ApiClientMaxAggregateOutputType | null
  }

  export type ApiClientMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    clientId: string | null
    clientName: string | null
    clientType: string | null
    apiKeyHash: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ApiClientMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    clientId: string | null
    clientName: string | null
    clientType: string | null
    apiKeyHash: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ApiClientCountAggregateOutputType = {
    id: number
    institutionId: number
    clientId: number
    clientName: number
    clientType: number
    apiKeyHash: number
    scopes: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ApiClientMinAggregateInputType = {
    id?: true
    institutionId?: true
    clientId?: true
    clientName?: true
    clientType?: true
    apiKeyHash?: true
    isActive?: true
    createdAt?: true
  }

  export type ApiClientMaxAggregateInputType = {
    id?: true
    institutionId?: true
    clientId?: true
    clientName?: true
    clientType?: true
    apiKeyHash?: true
    isActive?: true
    createdAt?: true
  }

  export type ApiClientCountAggregateInputType = {
    id?: true
    institutionId?: true
    clientId?: true
    clientName?: true
    clientType?: true
    apiKeyHash?: true
    scopes?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ApiClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiClient to aggregate.
     */
    where?: ApiClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiClients to fetch.
     */
    orderBy?: ApiClientOrderByWithRelationInput | ApiClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiClients
    **/
    _count?: true | ApiClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiClientMaxAggregateInputType
  }

  export type GetApiClientAggregateType<T extends ApiClientAggregateArgs> = {
        [P in keyof T & keyof AggregateApiClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiClient[P]>
      : GetScalarType<T[P], AggregateApiClient[P]>
  }




  export type ApiClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiClientWhereInput
    orderBy?: ApiClientOrderByWithAggregationInput | ApiClientOrderByWithAggregationInput[]
    by: ApiClientScalarFieldEnum[] | ApiClientScalarFieldEnum
    having?: ApiClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiClientCountAggregateInputType | true
    _min?: ApiClientMinAggregateInputType
    _max?: ApiClientMaxAggregateInputType
  }

  export type ApiClientGroupByOutputType = {
    id: string
    institutionId: string | null
    clientId: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes: string[]
    isActive: boolean
    createdAt: Date
    _count: ApiClientCountAggregateOutputType | null
    _min: ApiClientMinAggregateOutputType | null
    _max: ApiClientMaxAggregateOutputType | null
  }

  type GetApiClientGroupByPayload<T extends ApiClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiClientGroupByOutputType[P]>
            : GetScalarType<T[P], ApiClientGroupByOutputType[P]>
        }
      >
    >


  export type ApiClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    clientId?: boolean
    clientName?: boolean
    clientType?: boolean
    apiKeyHash?: boolean
    scopes?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | ApiClient$institutionArgs<ExtArgs>
    usageLogs?: boolean | ApiClient$usageLogsArgs<ExtArgs>
    rotations?: boolean | ApiClient$rotationsArgs<ExtArgs>
    _count?: boolean | ApiClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiClient"]>

  export type ApiClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    clientId?: boolean
    clientName?: boolean
    clientType?: boolean
    apiKeyHash?: boolean
    scopes?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | ApiClient$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["apiClient"]>

  export type ApiClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    clientId?: boolean
    clientName?: boolean
    clientType?: boolean
    apiKeyHash?: boolean
    scopes?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | ApiClient$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["apiClient"]>

  export type ApiClientSelectScalar = {
    id?: boolean
    institutionId?: boolean
    clientId?: boolean
    clientName?: boolean
    clientType?: boolean
    apiKeyHash?: boolean
    scopes?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ApiClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "clientId" | "clientName" | "clientType" | "apiKeyHash" | "scopes" | "isActive" | "createdAt", ExtArgs["result"]["apiClient"]>
  export type ApiClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | ApiClient$institutionArgs<ExtArgs>
    usageLogs?: boolean | ApiClient$usageLogsArgs<ExtArgs>
    rotations?: boolean | ApiClient$rotationsArgs<ExtArgs>
    _count?: boolean | ApiClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | ApiClient$institutionArgs<ExtArgs>
  }
  export type ApiClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | ApiClient$institutionArgs<ExtArgs>
  }

  export type $ApiClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiClient"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      usageLogs: Prisma.$ApiUsageLogPayload<ExtArgs>[]
      rotations: Prisma.$ApiKeyRotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string | null
      clientId: string
      clientName: string
      clientType: string
      apiKeyHash: string
      scopes: string[]
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["apiClient"]>
    composites: {}
  }

  type ApiClientGetPayload<S extends boolean | null | undefined | ApiClientDefaultArgs> = $Result.GetResult<Prisma.$ApiClientPayload, S>

  type ApiClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiClientCountAggregateInputType | true
    }

  export interface ApiClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiClient'], meta: { name: 'ApiClient' } }
    /**
     * Find zero or one ApiClient that matches the filter.
     * @param {ApiClientFindUniqueArgs} args - Arguments to find a ApiClient
     * @example
     * // Get one ApiClient
     * const apiClient = await prisma.apiClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiClientFindUniqueArgs>(args: SelectSubset<T, ApiClientFindUniqueArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiClientFindUniqueOrThrowArgs} args - Arguments to find a ApiClient
     * @example
     * // Get one ApiClient
     * const apiClient = await prisma.apiClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientFindFirstArgs} args - Arguments to find a ApiClient
     * @example
     * // Get one ApiClient
     * const apiClient = await prisma.apiClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiClientFindFirstArgs>(args?: SelectSubset<T, ApiClientFindFirstArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientFindFirstOrThrowArgs} args - Arguments to find a ApiClient
     * @example
     * // Get one ApiClient
     * const apiClient = await prisma.apiClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiClients
     * const apiClients = await prisma.apiClient.findMany()
     * 
     * // Get first 10 ApiClients
     * const apiClients = await prisma.apiClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiClientWithIdOnly = await prisma.apiClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiClientFindManyArgs>(args?: SelectSubset<T, ApiClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiClient.
     * @param {ApiClientCreateArgs} args - Arguments to create a ApiClient.
     * @example
     * // Create one ApiClient
     * const ApiClient = await prisma.apiClient.create({
     *   data: {
     *     // ... data to create a ApiClient
     *   }
     * })
     * 
     */
    create<T extends ApiClientCreateArgs>(args: SelectSubset<T, ApiClientCreateArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiClients.
     * @param {ApiClientCreateManyArgs} args - Arguments to create many ApiClients.
     * @example
     * // Create many ApiClients
     * const apiClient = await prisma.apiClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiClientCreateManyArgs>(args?: SelectSubset<T, ApiClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiClients and returns the data saved in the database.
     * @param {ApiClientCreateManyAndReturnArgs} args - Arguments to create many ApiClients.
     * @example
     * // Create many ApiClients
     * const apiClient = await prisma.apiClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiClients and only return the `id`
     * const apiClientWithIdOnly = await prisma.apiClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiClient.
     * @param {ApiClientDeleteArgs} args - Arguments to delete one ApiClient.
     * @example
     * // Delete one ApiClient
     * const ApiClient = await prisma.apiClient.delete({
     *   where: {
     *     // ... filter to delete one ApiClient
     *   }
     * })
     * 
     */
    delete<T extends ApiClientDeleteArgs>(args: SelectSubset<T, ApiClientDeleteArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiClient.
     * @param {ApiClientUpdateArgs} args - Arguments to update one ApiClient.
     * @example
     * // Update one ApiClient
     * const apiClient = await prisma.apiClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiClientUpdateArgs>(args: SelectSubset<T, ApiClientUpdateArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiClients.
     * @param {ApiClientDeleteManyArgs} args - Arguments to filter ApiClients to delete.
     * @example
     * // Delete a few ApiClients
     * const { count } = await prisma.apiClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiClientDeleteManyArgs>(args?: SelectSubset<T, ApiClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiClients
     * const apiClient = await prisma.apiClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiClientUpdateManyArgs>(args: SelectSubset<T, ApiClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiClients and returns the data updated in the database.
     * @param {ApiClientUpdateManyAndReturnArgs} args - Arguments to update many ApiClients.
     * @example
     * // Update many ApiClients
     * const apiClient = await prisma.apiClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiClients and only return the `id`
     * const apiClientWithIdOnly = await prisma.apiClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiClient.
     * @param {ApiClientUpsertArgs} args - Arguments to update or create a ApiClient.
     * @example
     * // Update or create a ApiClient
     * const apiClient = await prisma.apiClient.upsert({
     *   create: {
     *     // ... data to create a ApiClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiClient we want to update
     *   }
     * })
     */
    upsert<T extends ApiClientUpsertArgs>(args: SelectSubset<T, ApiClientUpsertArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientCountArgs} args - Arguments to filter ApiClients to count.
     * @example
     * // Count the number of ApiClients
     * const count = await prisma.apiClient.count({
     *   where: {
     *     // ... the filter for the ApiClients we want to count
     *   }
     * })
    **/
    count<T extends ApiClientCountArgs>(
      args?: Subset<T, ApiClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiClientAggregateArgs>(args: Subset<T, ApiClientAggregateArgs>): Prisma.PrismaPromise<GetApiClientAggregateType<T>>

    /**
     * Group by ApiClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiClientGroupByArgs['orderBy'] }
        : { orderBy?: ApiClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiClient model
   */
  readonly fields: ApiClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends ApiClient$institutionArgs<ExtArgs> = {}>(args?: Subset<T, ApiClient$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usageLogs<T extends ApiClient$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApiClient$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotations<T extends ApiClient$rotationsArgs<ExtArgs> = {}>(args?: Subset<T, ApiClient$rotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiClient model
   */
  interface ApiClientFieldRefs {
    readonly id: FieldRef<"ApiClient", 'String'>
    readonly institutionId: FieldRef<"ApiClient", 'String'>
    readonly clientId: FieldRef<"ApiClient", 'String'>
    readonly clientName: FieldRef<"ApiClient", 'String'>
    readonly clientType: FieldRef<"ApiClient", 'String'>
    readonly apiKeyHash: FieldRef<"ApiClient", 'String'>
    readonly scopes: FieldRef<"ApiClient", 'String[]'>
    readonly isActive: FieldRef<"ApiClient", 'Boolean'>
    readonly createdAt: FieldRef<"ApiClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiClient findUnique
   */
  export type ApiClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * Filter, which ApiClient to fetch.
     */
    where: ApiClientWhereUniqueInput
  }

  /**
   * ApiClient findUniqueOrThrow
   */
  export type ApiClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * Filter, which ApiClient to fetch.
     */
    where: ApiClientWhereUniqueInput
  }

  /**
   * ApiClient findFirst
   */
  export type ApiClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * Filter, which ApiClient to fetch.
     */
    where?: ApiClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiClients to fetch.
     */
    orderBy?: ApiClientOrderByWithRelationInput | ApiClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiClients.
     */
    cursor?: ApiClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiClients.
     */
    distinct?: ApiClientScalarFieldEnum | ApiClientScalarFieldEnum[]
  }

  /**
   * ApiClient findFirstOrThrow
   */
  export type ApiClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * Filter, which ApiClient to fetch.
     */
    where?: ApiClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiClients to fetch.
     */
    orderBy?: ApiClientOrderByWithRelationInput | ApiClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiClients.
     */
    cursor?: ApiClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiClients.
     */
    distinct?: ApiClientScalarFieldEnum | ApiClientScalarFieldEnum[]
  }

  /**
   * ApiClient findMany
   */
  export type ApiClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * Filter, which ApiClients to fetch.
     */
    where?: ApiClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiClients to fetch.
     */
    orderBy?: ApiClientOrderByWithRelationInput | ApiClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiClients.
     */
    cursor?: ApiClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiClients.
     */
    skip?: number
    distinct?: ApiClientScalarFieldEnum | ApiClientScalarFieldEnum[]
  }

  /**
   * ApiClient create
   */
  export type ApiClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiClient.
     */
    data: XOR<ApiClientCreateInput, ApiClientUncheckedCreateInput>
  }

  /**
   * ApiClient createMany
   */
  export type ApiClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiClients.
     */
    data: ApiClientCreateManyInput | ApiClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiClient createManyAndReturn
   */
  export type ApiClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * The data used to create many ApiClients.
     */
    data: ApiClientCreateManyInput | ApiClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiClient update
   */
  export type ApiClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiClient.
     */
    data: XOR<ApiClientUpdateInput, ApiClientUncheckedUpdateInput>
    /**
     * Choose, which ApiClient to update.
     */
    where: ApiClientWhereUniqueInput
  }

  /**
   * ApiClient updateMany
   */
  export type ApiClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiClients.
     */
    data: XOR<ApiClientUpdateManyMutationInput, ApiClientUncheckedUpdateManyInput>
    /**
     * Filter which ApiClients to update
     */
    where?: ApiClientWhereInput
    /**
     * Limit how many ApiClients to update.
     */
    limit?: number
  }

  /**
   * ApiClient updateManyAndReturn
   */
  export type ApiClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * The data used to update ApiClients.
     */
    data: XOR<ApiClientUpdateManyMutationInput, ApiClientUncheckedUpdateManyInput>
    /**
     * Filter which ApiClients to update
     */
    where?: ApiClientWhereInput
    /**
     * Limit how many ApiClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiClient upsert
   */
  export type ApiClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiClient to update in case it exists.
     */
    where: ApiClientWhereUniqueInput
    /**
     * In case the ApiClient found by the `where` argument doesn't exist, create a new ApiClient with this data.
     */
    create: XOR<ApiClientCreateInput, ApiClientUncheckedCreateInput>
    /**
     * In case the ApiClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiClientUpdateInput, ApiClientUncheckedUpdateInput>
  }

  /**
   * ApiClient delete
   */
  export type ApiClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
    /**
     * Filter which ApiClient to delete.
     */
    where: ApiClientWhereUniqueInput
  }

  /**
   * ApiClient deleteMany
   */
  export type ApiClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiClients to delete
     */
    where?: ApiClientWhereInput
    /**
     * Limit how many ApiClients to delete.
     */
    limit?: number
  }

  /**
   * ApiClient.institution
   */
  export type ApiClient$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * ApiClient.usageLogs
   */
  export type ApiClient$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    where?: ApiUsageLogWhereInput
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    cursor?: ApiUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiClient.rotations
   */
  export type ApiClient$rotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    where?: ApiKeyRotationWhereInput
    orderBy?: ApiKeyRotationOrderByWithRelationInput | ApiKeyRotationOrderByWithRelationInput[]
    cursor?: ApiKeyRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyRotationScalarFieldEnum | ApiKeyRotationScalarFieldEnum[]
  }

  /**
   * ApiClient without action
   */
  export type ApiClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiClient
     */
    select?: ApiClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiClient
     */
    omit?: ApiClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiClientInclude<ExtArgs> | null
  }


  /**
   * Model ApiUsageLog
   */

  export type AggregateApiUsageLog = {
    _count: ApiUsageLogCountAggregateOutputType | null
    _avg: ApiUsageLogAvgAggregateOutputType | null
    _sum: ApiUsageLogSumAggregateOutputType | null
    _min: ApiUsageLogMinAggregateOutputType | null
    _max: ApiUsageLogMaxAggregateOutputType | null
  }

  export type ApiUsageLogAvgAggregateOutputType = {
    statusCode: number | null
    latencyMs: number | null
  }

  export type ApiUsageLogSumAggregateOutputType = {
    statusCode: number | null
    latencyMs: number | null
  }

  export type ApiUsageLogMinAggregateOutputType = {
    id: string | null
    apiClientId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    latencyMs: number | null
    createdAt: Date | null
  }

  export type ApiUsageLogMaxAggregateOutputType = {
    id: string | null
    apiClientId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    latencyMs: number | null
    createdAt: Date | null
  }

  export type ApiUsageLogCountAggregateOutputType = {
    id: number
    apiClientId: number
    endpoint: number
    method: number
    statusCode: number
    latencyMs: number
    createdAt: number
    _all: number
  }


  export type ApiUsageLogAvgAggregateInputType = {
    statusCode?: true
    latencyMs?: true
  }

  export type ApiUsageLogSumAggregateInputType = {
    statusCode?: true
    latencyMs?: true
  }

  export type ApiUsageLogMinAggregateInputType = {
    id?: true
    apiClientId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    latencyMs?: true
    createdAt?: true
  }

  export type ApiUsageLogMaxAggregateInputType = {
    id?: true
    apiClientId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    latencyMs?: true
    createdAt?: true
  }

  export type ApiUsageLogCountAggregateInputType = {
    id?: true
    apiClientId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    latencyMs?: true
    createdAt?: true
    _all?: true
  }

  export type ApiUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiUsageLog to aggregate.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiUsageLogs
    **/
    _count?: true | ApiUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiUsageLogMaxAggregateInputType
  }

  export type GetApiUsageLogAggregateType<T extends ApiUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiUsageLog[P]>
      : GetScalarType<T[P], AggregateApiUsageLog[P]>
  }




  export type ApiUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageLogWhereInput
    orderBy?: ApiUsageLogOrderByWithAggregationInput | ApiUsageLogOrderByWithAggregationInput[]
    by: ApiUsageLogScalarFieldEnum[] | ApiUsageLogScalarFieldEnum
    having?: ApiUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiUsageLogCountAggregateInputType | true
    _avg?: ApiUsageLogAvgAggregateInputType
    _sum?: ApiUsageLogSumAggregateInputType
    _min?: ApiUsageLogMinAggregateInputType
    _max?: ApiUsageLogMaxAggregateInputType
  }

  export type ApiUsageLogGroupByOutputType = {
    id: string
    apiClientId: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs: number | null
    createdAt: Date
    _count: ApiUsageLogCountAggregateOutputType | null
    _avg: ApiUsageLogAvgAggregateOutputType | null
    _sum: ApiUsageLogSumAggregateOutputType | null
    _min: ApiUsageLogMinAggregateOutputType | null
    _max: ApiUsageLogMaxAggregateOutputType | null
  }

  type GetApiUsageLogGroupByPayload<T extends ApiUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiClientId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    latencyMs?: boolean
    createdAt?: boolean
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsageLog"]>

  export type ApiUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiClientId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    latencyMs?: boolean
    createdAt?: boolean
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsageLog"]>

  export type ApiUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiClientId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    latencyMs?: boolean
    createdAt?: boolean
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsageLog"]>

  export type ApiUsageLogSelectScalar = {
    id?: boolean
    apiClientId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    latencyMs?: boolean
    createdAt?: boolean
  }

  export type ApiUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apiClientId" | "endpoint" | "method" | "statusCode" | "latencyMs" | "createdAt", ExtArgs["result"]["apiUsageLog"]>
  export type ApiUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }
  export type ApiUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }
  export type ApiUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }

  export type $ApiUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiUsageLog"
    objects: {
      apiClient: Prisma.$ApiClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apiClientId: string
      endpoint: string
      method: string
      statusCode: number
      latencyMs: number | null
      createdAt: Date
    }, ExtArgs["result"]["apiUsageLog"]>
    composites: {}
  }

  type ApiUsageLogGetPayload<S extends boolean | null | undefined | ApiUsageLogDefaultArgs> = $Result.GetResult<Prisma.$ApiUsageLogPayload, S>

  type ApiUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiUsageLogCountAggregateInputType | true
    }

  export interface ApiUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiUsageLog'], meta: { name: 'ApiUsageLog' } }
    /**
     * Find zero or one ApiUsageLog that matches the filter.
     * @param {ApiUsageLogFindUniqueArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiUsageLogFindUniqueArgs>(args: SelectSubset<T, ApiUsageLogFindUniqueArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiUsageLogFindUniqueOrThrowArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogFindFirstArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiUsageLogFindFirstArgs>(args?: SelectSubset<T, ApiUsageLogFindFirstArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogFindFirstOrThrowArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiUsageLogs
     * const apiUsageLogs = await prisma.apiUsageLog.findMany()
     * 
     * // Get first 10 ApiUsageLogs
     * const apiUsageLogs = await prisma.apiUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiUsageLogWithIdOnly = await prisma.apiUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiUsageLogFindManyArgs>(args?: SelectSubset<T, ApiUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiUsageLog.
     * @param {ApiUsageLogCreateArgs} args - Arguments to create a ApiUsageLog.
     * @example
     * // Create one ApiUsageLog
     * const ApiUsageLog = await prisma.apiUsageLog.create({
     *   data: {
     *     // ... data to create a ApiUsageLog
     *   }
     * })
     * 
     */
    create<T extends ApiUsageLogCreateArgs>(args: SelectSubset<T, ApiUsageLogCreateArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiUsageLogs.
     * @param {ApiUsageLogCreateManyArgs} args - Arguments to create many ApiUsageLogs.
     * @example
     * // Create many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiUsageLogCreateManyArgs>(args?: SelectSubset<T, ApiUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiUsageLogs and returns the data saved in the database.
     * @param {ApiUsageLogCreateManyAndReturnArgs} args - Arguments to create many ApiUsageLogs.
     * @example
     * // Create many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiUsageLogs and only return the `id`
     * const apiUsageLogWithIdOnly = await prisma.apiUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiUsageLog.
     * @param {ApiUsageLogDeleteArgs} args - Arguments to delete one ApiUsageLog.
     * @example
     * // Delete one ApiUsageLog
     * const ApiUsageLog = await prisma.apiUsageLog.delete({
     *   where: {
     *     // ... filter to delete one ApiUsageLog
     *   }
     * })
     * 
     */
    delete<T extends ApiUsageLogDeleteArgs>(args: SelectSubset<T, ApiUsageLogDeleteArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiUsageLog.
     * @param {ApiUsageLogUpdateArgs} args - Arguments to update one ApiUsageLog.
     * @example
     * // Update one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiUsageLogUpdateArgs>(args: SelectSubset<T, ApiUsageLogUpdateArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiUsageLogs.
     * @param {ApiUsageLogDeleteManyArgs} args - Arguments to filter ApiUsageLogs to delete.
     * @example
     * // Delete a few ApiUsageLogs
     * const { count } = await prisma.apiUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiUsageLogDeleteManyArgs>(args?: SelectSubset<T, ApiUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiUsageLogUpdateManyArgs>(args: SelectSubset<T, ApiUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiUsageLogs and returns the data updated in the database.
     * @param {ApiUsageLogUpdateManyAndReturnArgs} args - Arguments to update many ApiUsageLogs.
     * @example
     * // Update many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiUsageLogs and only return the `id`
     * const apiUsageLogWithIdOnly = await prisma.apiUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiUsageLog.
     * @param {ApiUsageLogUpsertArgs} args - Arguments to update or create a ApiUsageLog.
     * @example
     * // Update or create a ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.upsert({
     *   create: {
     *     // ... data to create a ApiUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiUsageLogUpsertArgs>(args: SelectSubset<T, ApiUsageLogUpsertArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogCountArgs} args - Arguments to filter ApiUsageLogs to count.
     * @example
     * // Count the number of ApiUsageLogs
     * const count = await prisma.apiUsageLog.count({
     *   where: {
     *     // ... the filter for the ApiUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiUsageLogCountArgs>(
      args?: Subset<T, ApiUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiUsageLogAggregateArgs>(args: Subset<T, ApiUsageLogAggregateArgs>): Prisma.PrismaPromise<GetApiUsageLogAggregateType<T>>

    /**
     * Group by ApiUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiUsageLog model
   */
  readonly fields: ApiUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiClient<T extends ApiClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiClientDefaultArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiUsageLog model
   */
  interface ApiUsageLogFieldRefs {
    readonly id: FieldRef<"ApiUsageLog", 'String'>
    readonly apiClientId: FieldRef<"ApiUsageLog", 'String'>
    readonly endpoint: FieldRef<"ApiUsageLog", 'String'>
    readonly method: FieldRef<"ApiUsageLog", 'String'>
    readonly statusCode: FieldRef<"ApiUsageLog", 'Int'>
    readonly latencyMs: FieldRef<"ApiUsageLog", 'Int'>
    readonly createdAt: FieldRef<"ApiUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiUsageLog findUnique
   */
  export type ApiUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog findUniqueOrThrow
   */
  export type ApiUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog findFirst
   */
  export type ApiUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiUsageLogs.
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiUsageLogs.
     */
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiUsageLog findFirstOrThrow
   */
  export type ApiUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiUsageLogs.
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiUsageLogs.
     */
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiUsageLog findMany
   */
  export type ApiUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLogs to fetch.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiUsageLogs.
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiUsageLog create
   */
  export type ApiUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiUsageLog.
     */
    data: XOR<ApiUsageLogCreateInput, ApiUsageLogUncheckedCreateInput>
  }

  /**
   * ApiUsageLog createMany
   */
  export type ApiUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiUsageLogs.
     */
    data: ApiUsageLogCreateManyInput | ApiUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiUsageLog createManyAndReturn
   */
  export type ApiUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many ApiUsageLogs.
     */
    data: ApiUsageLogCreateManyInput | ApiUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiUsageLog update
   */
  export type ApiUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiUsageLog.
     */
    data: XOR<ApiUsageLogUpdateInput, ApiUsageLogUncheckedUpdateInput>
    /**
     * Choose, which ApiUsageLog to update.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog updateMany
   */
  export type ApiUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiUsageLogs.
     */
    data: XOR<ApiUsageLogUpdateManyMutationInput, ApiUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiUsageLogs to update
     */
    where?: ApiUsageLogWhereInput
    /**
     * Limit how many ApiUsageLogs to update.
     */
    limit?: number
  }

  /**
   * ApiUsageLog updateManyAndReturn
   */
  export type ApiUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update ApiUsageLogs.
     */
    data: XOR<ApiUsageLogUpdateManyMutationInput, ApiUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiUsageLogs to update
     */
    where?: ApiUsageLogWhereInput
    /**
     * Limit how many ApiUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiUsageLog upsert
   */
  export type ApiUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiUsageLog to update in case it exists.
     */
    where: ApiUsageLogWhereUniqueInput
    /**
     * In case the ApiUsageLog found by the `where` argument doesn't exist, create a new ApiUsageLog with this data.
     */
    create: XOR<ApiUsageLogCreateInput, ApiUsageLogUncheckedCreateInput>
    /**
     * In case the ApiUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiUsageLogUpdateInput, ApiUsageLogUncheckedUpdateInput>
  }

  /**
   * ApiUsageLog delete
   */
  export type ApiUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter which ApiUsageLog to delete.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog deleteMany
   */
  export type ApiUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiUsageLogs to delete
     */
    where?: ApiUsageLogWhereInput
    /**
     * Limit how many ApiUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * ApiUsageLog without action
   */
  export type ApiUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiUsageLog
     */
    omit?: ApiUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ApiScope
   */

  export type AggregateApiScope = {
    _count: ApiScopeCountAggregateOutputType | null
    _min: ApiScopeMinAggregateOutputType | null
    _max: ApiScopeMaxAggregateOutputType | null
  }

  export type ApiScopeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type ApiScopeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type ApiScopeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type ApiScopeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ApiScopeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ApiScopeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ApiScopeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiScope to aggregate.
     */
    where?: ApiScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiScopes to fetch.
     */
    orderBy?: ApiScopeOrderByWithRelationInput | ApiScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiScopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiScopes
    **/
    _count?: true | ApiScopeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiScopeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiScopeMaxAggregateInputType
  }

  export type GetApiScopeAggregateType<T extends ApiScopeAggregateArgs> = {
        [P in keyof T & keyof AggregateApiScope]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiScope[P]>
      : GetScalarType<T[P], AggregateApiScope[P]>
  }




  export type ApiScopeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiScopeWhereInput
    orderBy?: ApiScopeOrderByWithAggregationInput | ApiScopeOrderByWithAggregationInput[]
    by: ApiScopeScalarFieldEnum[] | ApiScopeScalarFieldEnum
    having?: ApiScopeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiScopeCountAggregateInputType | true
    _min?: ApiScopeMinAggregateInputType
    _max?: ApiScopeMaxAggregateInputType
  }

  export type ApiScopeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: ApiScopeCountAggregateOutputType | null
    _min: ApiScopeMinAggregateOutputType | null
    _max: ApiScopeMaxAggregateOutputType | null
  }

  type GetApiScopeGroupByPayload<T extends ApiScopeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiScopeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiScopeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiScopeGroupByOutputType[P]>
            : GetScalarType<T[P], ApiScopeGroupByOutputType[P]>
        }
      >
    >


  export type ApiScopeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["apiScope"]>

  export type ApiScopeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["apiScope"]>

  export type ApiScopeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["apiScope"]>

  export type ApiScopeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type ApiScopeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["apiScope"]>

  export type $ApiScopePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiScope"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["apiScope"]>
    composites: {}
  }

  type ApiScopeGetPayload<S extends boolean | null | undefined | ApiScopeDefaultArgs> = $Result.GetResult<Prisma.$ApiScopePayload, S>

  type ApiScopeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiScopeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiScopeCountAggregateInputType | true
    }

  export interface ApiScopeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiScope'], meta: { name: 'ApiScope' } }
    /**
     * Find zero or one ApiScope that matches the filter.
     * @param {ApiScopeFindUniqueArgs} args - Arguments to find a ApiScope
     * @example
     * // Get one ApiScope
     * const apiScope = await prisma.apiScope.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiScopeFindUniqueArgs>(args: SelectSubset<T, ApiScopeFindUniqueArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiScope that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiScopeFindUniqueOrThrowArgs} args - Arguments to find a ApiScope
     * @example
     * // Get one ApiScope
     * const apiScope = await prisma.apiScope.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiScopeFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiScopeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiScope that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeFindFirstArgs} args - Arguments to find a ApiScope
     * @example
     * // Get one ApiScope
     * const apiScope = await prisma.apiScope.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiScopeFindFirstArgs>(args?: SelectSubset<T, ApiScopeFindFirstArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiScope that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeFindFirstOrThrowArgs} args - Arguments to find a ApiScope
     * @example
     * // Get one ApiScope
     * const apiScope = await prisma.apiScope.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiScopeFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiScopeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiScopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiScopes
     * const apiScopes = await prisma.apiScope.findMany()
     * 
     * // Get first 10 ApiScopes
     * const apiScopes = await prisma.apiScope.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiScopeWithIdOnly = await prisma.apiScope.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiScopeFindManyArgs>(args?: SelectSubset<T, ApiScopeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiScope.
     * @param {ApiScopeCreateArgs} args - Arguments to create a ApiScope.
     * @example
     * // Create one ApiScope
     * const ApiScope = await prisma.apiScope.create({
     *   data: {
     *     // ... data to create a ApiScope
     *   }
     * })
     * 
     */
    create<T extends ApiScopeCreateArgs>(args: SelectSubset<T, ApiScopeCreateArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiScopes.
     * @param {ApiScopeCreateManyArgs} args - Arguments to create many ApiScopes.
     * @example
     * // Create many ApiScopes
     * const apiScope = await prisma.apiScope.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiScopeCreateManyArgs>(args?: SelectSubset<T, ApiScopeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiScopes and returns the data saved in the database.
     * @param {ApiScopeCreateManyAndReturnArgs} args - Arguments to create many ApiScopes.
     * @example
     * // Create many ApiScopes
     * const apiScope = await prisma.apiScope.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiScopes and only return the `id`
     * const apiScopeWithIdOnly = await prisma.apiScope.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiScopeCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiScopeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiScope.
     * @param {ApiScopeDeleteArgs} args - Arguments to delete one ApiScope.
     * @example
     * // Delete one ApiScope
     * const ApiScope = await prisma.apiScope.delete({
     *   where: {
     *     // ... filter to delete one ApiScope
     *   }
     * })
     * 
     */
    delete<T extends ApiScopeDeleteArgs>(args: SelectSubset<T, ApiScopeDeleteArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiScope.
     * @param {ApiScopeUpdateArgs} args - Arguments to update one ApiScope.
     * @example
     * // Update one ApiScope
     * const apiScope = await prisma.apiScope.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiScopeUpdateArgs>(args: SelectSubset<T, ApiScopeUpdateArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiScopes.
     * @param {ApiScopeDeleteManyArgs} args - Arguments to filter ApiScopes to delete.
     * @example
     * // Delete a few ApiScopes
     * const { count } = await prisma.apiScope.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiScopeDeleteManyArgs>(args?: SelectSubset<T, ApiScopeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiScopes
     * const apiScope = await prisma.apiScope.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiScopeUpdateManyArgs>(args: SelectSubset<T, ApiScopeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiScopes and returns the data updated in the database.
     * @param {ApiScopeUpdateManyAndReturnArgs} args - Arguments to update many ApiScopes.
     * @example
     * // Update many ApiScopes
     * const apiScope = await prisma.apiScope.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiScopes and only return the `id`
     * const apiScopeWithIdOnly = await prisma.apiScope.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiScopeUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiScopeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiScope.
     * @param {ApiScopeUpsertArgs} args - Arguments to update or create a ApiScope.
     * @example
     * // Update or create a ApiScope
     * const apiScope = await prisma.apiScope.upsert({
     *   create: {
     *     // ... data to create a ApiScope
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiScope we want to update
     *   }
     * })
     */
    upsert<T extends ApiScopeUpsertArgs>(args: SelectSubset<T, ApiScopeUpsertArgs<ExtArgs>>): Prisma__ApiScopeClient<$Result.GetResult<Prisma.$ApiScopePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeCountArgs} args - Arguments to filter ApiScopes to count.
     * @example
     * // Count the number of ApiScopes
     * const count = await prisma.apiScope.count({
     *   where: {
     *     // ... the filter for the ApiScopes we want to count
     *   }
     * })
    **/
    count<T extends ApiScopeCountArgs>(
      args?: Subset<T, ApiScopeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiScopeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiScope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiScopeAggregateArgs>(args: Subset<T, ApiScopeAggregateArgs>): Prisma.PrismaPromise<GetApiScopeAggregateType<T>>

    /**
     * Group by ApiScope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiScopeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiScopeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiScopeGroupByArgs['orderBy'] }
        : { orderBy?: ApiScopeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiScopeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiScopeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiScope model
   */
  readonly fields: ApiScopeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiScope.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiScopeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiScope model
   */
  interface ApiScopeFieldRefs {
    readonly id: FieldRef<"ApiScope", 'String'>
    readonly name: FieldRef<"ApiScope", 'String'>
    readonly description: FieldRef<"ApiScope", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiScope findUnique
   */
  export type ApiScopeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * Filter, which ApiScope to fetch.
     */
    where: ApiScopeWhereUniqueInput
  }

  /**
   * ApiScope findUniqueOrThrow
   */
  export type ApiScopeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * Filter, which ApiScope to fetch.
     */
    where: ApiScopeWhereUniqueInput
  }

  /**
   * ApiScope findFirst
   */
  export type ApiScopeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * Filter, which ApiScope to fetch.
     */
    where?: ApiScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiScopes to fetch.
     */
    orderBy?: ApiScopeOrderByWithRelationInput | ApiScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiScopes.
     */
    cursor?: ApiScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiScopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiScopes.
     */
    distinct?: ApiScopeScalarFieldEnum | ApiScopeScalarFieldEnum[]
  }

  /**
   * ApiScope findFirstOrThrow
   */
  export type ApiScopeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * Filter, which ApiScope to fetch.
     */
    where?: ApiScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiScopes to fetch.
     */
    orderBy?: ApiScopeOrderByWithRelationInput | ApiScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiScopes.
     */
    cursor?: ApiScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiScopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiScopes.
     */
    distinct?: ApiScopeScalarFieldEnum | ApiScopeScalarFieldEnum[]
  }

  /**
   * ApiScope findMany
   */
  export type ApiScopeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * Filter, which ApiScopes to fetch.
     */
    where?: ApiScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiScopes to fetch.
     */
    orderBy?: ApiScopeOrderByWithRelationInput | ApiScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiScopes.
     */
    cursor?: ApiScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiScopes.
     */
    skip?: number
    distinct?: ApiScopeScalarFieldEnum | ApiScopeScalarFieldEnum[]
  }

  /**
   * ApiScope create
   */
  export type ApiScopeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiScope.
     */
    data: XOR<ApiScopeCreateInput, ApiScopeUncheckedCreateInput>
  }

  /**
   * ApiScope createMany
   */
  export type ApiScopeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiScopes.
     */
    data: ApiScopeCreateManyInput | ApiScopeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiScope createManyAndReturn
   */
  export type ApiScopeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * The data used to create many ApiScopes.
     */
    data: ApiScopeCreateManyInput | ApiScopeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiScope update
   */
  export type ApiScopeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiScope.
     */
    data: XOR<ApiScopeUpdateInput, ApiScopeUncheckedUpdateInput>
    /**
     * Choose, which ApiScope to update.
     */
    where: ApiScopeWhereUniqueInput
  }

  /**
   * ApiScope updateMany
   */
  export type ApiScopeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiScopes.
     */
    data: XOR<ApiScopeUpdateManyMutationInput, ApiScopeUncheckedUpdateManyInput>
    /**
     * Filter which ApiScopes to update
     */
    where?: ApiScopeWhereInput
    /**
     * Limit how many ApiScopes to update.
     */
    limit?: number
  }

  /**
   * ApiScope updateManyAndReturn
   */
  export type ApiScopeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * The data used to update ApiScopes.
     */
    data: XOR<ApiScopeUpdateManyMutationInput, ApiScopeUncheckedUpdateManyInput>
    /**
     * Filter which ApiScopes to update
     */
    where?: ApiScopeWhereInput
    /**
     * Limit how many ApiScopes to update.
     */
    limit?: number
  }

  /**
   * ApiScope upsert
   */
  export type ApiScopeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiScope to update in case it exists.
     */
    where: ApiScopeWhereUniqueInput
    /**
     * In case the ApiScope found by the `where` argument doesn't exist, create a new ApiScope with this data.
     */
    create: XOR<ApiScopeCreateInput, ApiScopeUncheckedCreateInput>
    /**
     * In case the ApiScope was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiScopeUpdateInput, ApiScopeUncheckedUpdateInput>
  }

  /**
   * ApiScope delete
   */
  export type ApiScopeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
    /**
     * Filter which ApiScope to delete.
     */
    where: ApiScopeWhereUniqueInput
  }

  /**
   * ApiScope deleteMany
   */
  export type ApiScopeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiScopes to delete
     */
    where?: ApiScopeWhereInput
    /**
     * Limit how many ApiScopes to delete.
     */
    limit?: number
  }

  /**
   * ApiScope without action
   */
  export type ApiScopeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiScope
     */
    select?: ApiScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiScope
     */
    omit?: ApiScopeOmit<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    url: number
    events: number
    secret: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type WebhookMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    createdAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    url?: true
    events?: true
    secret?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    url: string
    events: string[]
    secret: string | null
    isActive: boolean
    createdAt: Date
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "url" | "events" | "secret" | "isActive" | "createdAt", ExtArgs["result"]["webhook"]>
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      url: string
      events: string[]
      secret: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends Webhook$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly institutionId: FieldRef<"Webhook", 'String'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook.deliveries
   */
  export type Webhook$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    attempt: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    attempt: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    webhookId: string | null
    status: string | null
    attempt: number | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    webhookId: string | null
    status: string | null
    attempt: number | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    webhookId: number
    status: number
    response: number
    attempt: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    attempt?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    attempt?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    webhookId?: true
    status?: true
    attempt?: true
    sentAt?: true
    createdAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    webhookId?: true
    status?: true
    attempt?: true
    sentAt?: true
    createdAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    webhookId?: true
    status?: true
    response?: true
    attempt?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    webhookId: string
    status: string
    response: JsonValue | null
    attempt: number
    sentAt: Date | null
    createdAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    status?: boolean
    response?: boolean
    attempt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    status?: boolean
    response?: boolean
    attempt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    status?: boolean
    response?: boolean
    attempt?: boolean
    sentAt?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    webhookId?: boolean
    status?: boolean
    response?: boolean
    attempt?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type WebhookDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "webhookId" | "status" | "response" | "attempt" | "sentAt" | "createdAt", ExtArgs["result"]["webhookDelivery"]>
  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      webhookId: string
      status: string
      response: Prisma.JsonValue | null
      attempt: number
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries and returns the data updated in the database.
     * @param {WebhookDeliveryUpdateManyAndReturnArgs} args - Arguments to update many WebhookDeliveries.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly status: FieldRef<"WebhookDelivery", 'String'>
    readonly response: FieldRef<"WebhookDelivery", 'Json'>
    readonly attempt: FieldRef<"WebhookDelivery", 'Int'>
    readonly sentAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
  }

  /**
   * WebhookDelivery updateManyAndReturn
   */
  export type WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to delete.
     */
    limit?: number
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model ApiKeyRotation
   */

  export type AggregateApiKeyRotation = {
    _count: ApiKeyRotationCountAggregateOutputType | null
    _min: ApiKeyRotationMinAggregateOutputType | null
    _max: ApiKeyRotationMaxAggregateOutputType | null
  }

  export type ApiKeyRotationMinAggregateOutputType = {
    id: string | null
    apiClientId: string | null
    keyHash: string | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type ApiKeyRotationMaxAggregateOutputType = {
    id: string | null
    apiClientId: string | null
    keyHash: string | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type ApiKeyRotationCountAggregateOutputType = {
    id: number
    apiClientId: number
    keyHash: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type ApiKeyRotationMinAggregateInputType = {
    id?: true
    apiClientId?: true
    keyHash?: true
    createdAt?: true
    revokedAt?: true
  }

  export type ApiKeyRotationMaxAggregateInputType = {
    id?: true
    apiClientId?: true
    keyHash?: true
    createdAt?: true
    revokedAt?: true
  }

  export type ApiKeyRotationCountAggregateInputType = {
    id?: true
    apiClientId?: true
    keyHash?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type ApiKeyRotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyRotation to aggregate.
     */
    where?: ApiKeyRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyRotations to fetch.
     */
    orderBy?: ApiKeyRotationOrderByWithRelationInput | ApiKeyRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeyRotations
    **/
    _count?: true | ApiKeyRotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyRotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyRotationMaxAggregateInputType
  }

  export type GetApiKeyRotationAggregateType<T extends ApiKeyRotationAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeyRotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeyRotation[P]>
      : GetScalarType<T[P], AggregateApiKeyRotation[P]>
  }




  export type ApiKeyRotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyRotationWhereInput
    orderBy?: ApiKeyRotationOrderByWithAggregationInput | ApiKeyRotationOrderByWithAggregationInput[]
    by: ApiKeyRotationScalarFieldEnum[] | ApiKeyRotationScalarFieldEnum
    having?: ApiKeyRotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyRotationCountAggregateInputType | true
    _min?: ApiKeyRotationMinAggregateInputType
    _max?: ApiKeyRotationMaxAggregateInputType
  }

  export type ApiKeyRotationGroupByOutputType = {
    id: string
    apiClientId: string
    keyHash: string
    createdAt: Date
    revokedAt: Date | null
    _count: ApiKeyRotationCountAggregateOutputType | null
    _min: ApiKeyRotationMinAggregateOutputType | null
    _max: ApiKeyRotationMaxAggregateOutputType | null
  }

  type GetApiKeyRotationGroupByPayload<T extends ApiKeyRotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyRotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyRotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyRotationGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyRotationGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeyRotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiClientId?: boolean
    keyHash?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyRotation"]>

  export type ApiKeyRotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiClientId?: boolean
    keyHash?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyRotation"]>

  export type ApiKeyRotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiClientId?: boolean
    keyHash?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyRotation"]>

  export type ApiKeyRotationSelectScalar = {
    id?: boolean
    apiClientId?: boolean
    keyHash?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type ApiKeyRotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apiClientId" | "keyHash" | "createdAt" | "revokedAt", ExtArgs["result"]["apiKeyRotation"]>
  export type ApiKeyRotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }
  export type ApiKeyRotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }
  export type ApiKeyRotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiClient?: boolean | ApiClientDefaultArgs<ExtArgs>
  }

  export type $ApiKeyRotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeyRotation"
    objects: {
      apiClient: Prisma.$ApiClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apiClientId: string
      keyHash: string
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["apiKeyRotation"]>
    composites: {}
  }

  type ApiKeyRotationGetPayload<S extends boolean | null | undefined | ApiKeyRotationDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyRotationPayload, S>

  type ApiKeyRotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyRotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyRotationCountAggregateInputType | true
    }

  export interface ApiKeyRotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeyRotation'], meta: { name: 'ApiKeyRotation' } }
    /**
     * Find zero or one ApiKeyRotation that matches the filter.
     * @param {ApiKeyRotationFindUniqueArgs} args - Arguments to find a ApiKeyRotation
     * @example
     * // Get one ApiKeyRotation
     * const apiKeyRotation = await prisma.apiKeyRotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyRotationFindUniqueArgs>(args: SelectSubset<T, ApiKeyRotationFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKeyRotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyRotationFindUniqueOrThrowArgs} args - Arguments to find a ApiKeyRotation
     * @example
     * // Get one ApiKeyRotation
     * const apiKeyRotation = await prisma.apiKeyRotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyRotationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyRotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKeyRotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationFindFirstArgs} args - Arguments to find a ApiKeyRotation
     * @example
     * // Get one ApiKeyRotation
     * const apiKeyRotation = await prisma.apiKeyRotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyRotationFindFirstArgs>(args?: SelectSubset<T, ApiKeyRotationFindFirstArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKeyRotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationFindFirstOrThrowArgs} args - Arguments to find a ApiKeyRotation
     * @example
     * // Get one ApiKeyRotation
     * const apiKeyRotation = await prisma.apiKeyRotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyRotationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyRotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeyRotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeyRotations
     * const apiKeyRotations = await prisma.apiKeyRotation.findMany()
     * 
     * // Get first 10 ApiKeyRotations
     * const apiKeyRotations = await prisma.apiKeyRotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyRotationWithIdOnly = await prisma.apiKeyRotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyRotationFindManyArgs>(args?: SelectSubset<T, ApiKeyRotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKeyRotation.
     * @param {ApiKeyRotationCreateArgs} args - Arguments to create a ApiKeyRotation.
     * @example
     * // Create one ApiKeyRotation
     * const ApiKeyRotation = await prisma.apiKeyRotation.create({
     *   data: {
     *     // ... data to create a ApiKeyRotation
     *   }
     * })
     * 
     */
    create<T extends ApiKeyRotationCreateArgs>(args: SelectSubset<T, ApiKeyRotationCreateArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeyRotations.
     * @param {ApiKeyRotationCreateManyArgs} args - Arguments to create many ApiKeyRotations.
     * @example
     * // Create many ApiKeyRotations
     * const apiKeyRotation = await prisma.apiKeyRotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyRotationCreateManyArgs>(args?: SelectSubset<T, ApiKeyRotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeyRotations and returns the data saved in the database.
     * @param {ApiKeyRotationCreateManyAndReturnArgs} args - Arguments to create many ApiKeyRotations.
     * @example
     * // Create many ApiKeyRotations
     * const apiKeyRotation = await prisma.apiKeyRotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeyRotations and only return the `id`
     * const apiKeyRotationWithIdOnly = await prisma.apiKeyRotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyRotationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyRotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKeyRotation.
     * @param {ApiKeyRotationDeleteArgs} args - Arguments to delete one ApiKeyRotation.
     * @example
     * // Delete one ApiKeyRotation
     * const ApiKeyRotation = await prisma.apiKeyRotation.delete({
     *   where: {
     *     // ... filter to delete one ApiKeyRotation
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyRotationDeleteArgs>(args: SelectSubset<T, ApiKeyRotationDeleteArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKeyRotation.
     * @param {ApiKeyRotationUpdateArgs} args - Arguments to update one ApiKeyRotation.
     * @example
     * // Update one ApiKeyRotation
     * const apiKeyRotation = await prisma.apiKeyRotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyRotationUpdateArgs>(args: SelectSubset<T, ApiKeyRotationUpdateArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeyRotations.
     * @param {ApiKeyRotationDeleteManyArgs} args - Arguments to filter ApiKeyRotations to delete.
     * @example
     * // Delete a few ApiKeyRotations
     * const { count } = await prisma.apiKeyRotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyRotationDeleteManyArgs>(args?: SelectSubset<T, ApiKeyRotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeyRotations
     * const apiKeyRotation = await prisma.apiKeyRotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyRotationUpdateManyArgs>(args: SelectSubset<T, ApiKeyRotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyRotations and returns the data updated in the database.
     * @param {ApiKeyRotationUpdateManyAndReturnArgs} args - Arguments to update many ApiKeyRotations.
     * @example
     * // Update many ApiKeyRotations
     * const apiKeyRotation = await prisma.apiKeyRotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeyRotations and only return the `id`
     * const apiKeyRotationWithIdOnly = await prisma.apiKeyRotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyRotationUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyRotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKeyRotation.
     * @param {ApiKeyRotationUpsertArgs} args - Arguments to update or create a ApiKeyRotation.
     * @example
     * // Update or create a ApiKeyRotation
     * const apiKeyRotation = await prisma.apiKeyRotation.upsert({
     *   create: {
     *     // ... data to create a ApiKeyRotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeyRotation we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyRotationUpsertArgs>(args: SelectSubset<T, ApiKeyRotationUpsertArgs<ExtArgs>>): Prisma__ApiKeyRotationClient<$Result.GetResult<Prisma.$ApiKeyRotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeyRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationCountArgs} args - Arguments to filter ApiKeyRotations to count.
     * @example
     * // Count the number of ApiKeyRotations
     * const count = await prisma.apiKeyRotation.count({
     *   where: {
     *     // ... the filter for the ApiKeyRotations we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyRotationCountArgs>(
      args?: Subset<T, ApiKeyRotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyRotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeyRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyRotationAggregateArgs>(args: Subset<T, ApiKeyRotationAggregateArgs>): Prisma.PrismaPromise<GetApiKeyRotationAggregateType<T>>

    /**
     * Group by ApiKeyRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyRotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyRotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyRotationGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyRotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyRotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyRotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeyRotation model
   */
  readonly fields: ApiKeyRotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeyRotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyRotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiClient<T extends ApiClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiClientDefaultArgs<ExtArgs>>): Prisma__ApiClientClient<$Result.GetResult<Prisma.$ApiClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeyRotation model
   */
  interface ApiKeyRotationFieldRefs {
    readonly id: FieldRef<"ApiKeyRotation", 'String'>
    readonly apiClientId: FieldRef<"ApiKeyRotation", 'String'>
    readonly keyHash: FieldRef<"ApiKeyRotation", 'String'>
    readonly createdAt: FieldRef<"ApiKeyRotation", 'DateTime'>
    readonly revokedAt: FieldRef<"ApiKeyRotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeyRotation findUnique
   */
  export type ApiKeyRotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyRotation to fetch.
     */
    where: ApiKeyRotationWhereUniqueInput
  }

  /**
   * ApiKeyRotation findUniqueOrThrow
   */
  export type ApiKeyRotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyRotation to fetch.
     */
    where: ApiKeyRotationWhereUniqueInput
  }

  /**
   * ApiKeyRotation findFirst
   */
  export type ApiKeyRotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyRotation to fetch.
     */
    where?: ApiKeyRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyRotations to fetch.
     */
    orderBy?: ApiKeyRotationOrderByWithRelationInput | ApiKeyRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyRotations.
     */
    cursor?: ApiKeyRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyRotations.
     */
    distinct?: ApiKeyRotationScalarFieldEnum | ApiKeyRotationScalarFieldEnum[]
  }

  /**
   * ApiKeyRotation findFirstOrThrow
   */
  export type ApiKeyRotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyRotation to fetch.
     */
    where?: ApiKeyRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyRotations to fetch.
     */
    orderBy?: ApiKeyRotationOrderByWithRelationInput | ApiKeyRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyRotations.
     */
    cursor?: ApiKeyRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyRotations.
     */
    distinct?: ApiKeyRotationScalarFieldEnum | ApiKeyRotationScalarFieldEnum[]
  }

  /**
   * ApiKeyRotation findMany
   */
  export type ApiKeyRotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyRotations to fetch.
     */
    where?: ApiKeyRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyRotations to fetch.
     */
    orderBy?: ApiKeyRotationOrderByWithRelationInput | ApiKeyRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeyRotations.
     */
    cursor?: ApiKeyRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyRotations.
     */
    skip?: number
    distinct?: ApiKeyRotationScalarFieldEnum | ApiKeyRotationScalarFieldEnum[]
  }

  /**
   * ApiKeyRotation create
   */
  export type ApiKeyRotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKeyRotation.
     */
    data: XOR<ApiKeyRotationCreateInput, ApiKeyRotationUncheckedCreateInput>
  }

  /**
   * ApiKeyRotation createMany
   */
  export type ApiKeyRotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeyRotations.
     */
    data: ApiKeyRotationCreateManyInput | ApiKeyRotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeyRotation createManyAndReturn
   */
  export type ApiKeyRotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeyRotations.
     */
    data: ApiKeyRotationCreateManyInput | ApiKeyRotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyRotation update
   */
  export type ApiKeyRotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKeyRotation.
     */
    data: XOR<ApiKeyRotationUpdateInput, ApiKeyRotationUncheckedUpdateInput>
    /**
     * Choose, which ApiKeyRotation to update.
     */
    where: ApiKeyRotationWhereUniqueInput
  }

  /**
   * ApiKeyRotation updateMany
   */
  export type ApiKeyRotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeyRotations.
     */
    data: XOR<ApiKeyRotationUpdateManyMutationInput, ApiKeyRotationUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyRotations to update
     */
    where?: ApiKeyRotationWhereInput
    /**
     * Limit how many ApiKeyRotations to update.
     */
    limit?: number
  }

  /**
   * ApiKeyRotation updateManyAndReturn
   */
  export type ApiKeyRotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeyRotations.
     */
    data: XOR<ApiKeyRotationUpdateManyMutationInput, ApiKeyRotationUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyRotations to update
     */
    where?: ApiKeyRotationWhereInput
    /**
     * Limit how many ApiKeyRotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyRotation upsert
   */
  export type ApiKeyRotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKeyRotation to update in case it exists.
     */
    where: ApiKeyRotationWhereUniqueInput
    /**
     * In case the ApiKeyRotation found by the `where` argument doesn't exist, create a new ApiKeyRotation with this data.
     */
    create: XOR<ApiKeyRotationCreateInput, ApiKeyRotationUncheckedCreateInput>
    /**
     * In case the ApiKeyRotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyRotationUpdateInput, ApiKeyRotationUncheckedUpdateInput>
  }

  /**
   * ApiKeyRotation delete
   */
  export type ApiKeyRotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
    /**
     * Filter which ApiKeyRotation to delete.
     */
    where: ApiKeyRotationWhereUniqueInput
  }

  /**
   * ApiKeyRotation deleteMany
   */
  export type ApiKeyRotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyRotations to delete
     */
    where?: ApiKeyRotationWhereInput
    /**
     * Limit how many ApiKeyRotations to delete.
     */
    limit?: number
  }

  /**
   * ApiKeyRotation without action
   */
  export type ApiKeyRotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyRotation
     */
    select?: ApiKeyRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyRotation
     */
    omit?: ApiKeyRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyRotationInclude<ExtArgs> | null
  }


  /**
   * Model DashboardConfig
   */

  export type AggregateDashboardConfig = {
    _count: DashboardConfigCountAggregateOutputType | null
    _min: DashboardConfigMinAggregateOutputType | null
    _max: DashboardConfigMaxAggregateOutputType | null
  }

  export type DashboardConfigMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type DashboardConfigMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type DashboardConfigCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    config: number
    updatedAt: number
    _all: number
  }


  export type DashboardConfigMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    updatedAt?: true
  }

  export type DashboardConfigMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    updatedAt?: true
  }

  export type DashboardConfigCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    config?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardConfig to aggregate.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardConfigs
    **/
    _count?: true | DashboardConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardConfigMaxAggregateInputType
  }

  export type GetDashboardConfigAggregateType<T extends DashboardConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardConfig[P]>
      : GetScalarType<T[P], AggregateDashboardConfig[P]>
  }




  export type DashboardConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardConfigWhereInput
    orderBy?: DashboardConfigOrderByWithAggregationInput | DashboardConfigOrderByWithAggregationInput[]
    by: DashboardConfigScalarFieldEnum[] | DashboardConfigScalarFieldEnum
    having?: DashboardConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardConfigCountAggregateInputType | true
    _min?: DashboardConfigMinAggregateInputType
    _max?: DashboardConfigMaxAggregateInputType
  }

  export type DashboardConfigGroupByOutputType = {
    id: string
    userId: string
    type: string
    config: JsonValue
    updatedAt: Date
    _count: DashboardConfigCountAggregateOutputType | null
    _min: DashboardConfigMinAggregateOutputType | null
    _max: DashboardConfigMaxAggregateOutputType | null
  }

  type GetDashboardConfigGroupByPayload<T extends DashboardConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardConfigGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardConfigGroupByOutputType[P]>
        }
      >
    >


  export type DashboardConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    config?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardConfig"]>

  export type DashboardConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    config?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardConfig"]>

  export type DashboardConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    config?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardConfig"]>

  export type DashboardConfigSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    config?: boolean
    updatedAt?: boolean
  }

  export type DashboardConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "config" | "updatedAt", ExtArgs["result"]["dashboardConfig"]>
  export type DashboardConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DashboardConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DashboardConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DashboardConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardConfig"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      config: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["dashboardConfig"]>
    composites: {}
  }

  type DashboardConfigGetPayload<S extends boolean | null | undefined | DashboardConfigDefaultArgs> = $Result.GetResult<Prisma.$DashboardConfigPayload, S>

  type DashboardConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardConfigCountAggregateInputType | true
    }

  export interface DashboardConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardConfig'], meta: { name: 'DashboardConfig' } }
    /**
     * Find zero or one DashboardConfig that matches the filter.
     * @param {DashboardConfigFindUniqueArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardConfigFindUniqueArgs>(args: SelectSubset<T, DashboardConfigFindUniqueArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardConfigFindUniqueOrThrowArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigFindFirstArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardConfigFindFirstArgs>(args?: SelectSubset<T, DashboardConfigFindFirstArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigFindFirstOrThrowArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardConfigs
     * const dashboardConfigs = await prisma.dashboardConfig.findMany()
     * 
     * // Get first 10 DashboardConfigs
     * const dashboardConfigs = await prisma.dashboardConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardConfigWithIdOnly = await prisma.dashboardConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardConfigFindManyArgs>(args?: SelectSubset<T, DashboardConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardConfig.
     * @param {DashboardConfigCreateArgs} args - Arguments to create a DashboardConfig.
     * @example
     * // Create one DashboardConfig
     * const DashboardConfig = await prisma.dashboardConfig.create({
     *   data: {
     *     // ... data to create a DashboardConfig
     *   }
     * })
     * 
     */
    create<T extends DashboardConfigCreateArgs>(args: SelectSubset<T, DashboardConfigCreateArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardConfigs.
     * @param {DashboardConfigCreateManyArgs} args - Arguments to create many DashboardConfigs.
     * @example
     * // Create many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardConfigCreateManyArgs>(args?: SelectSubset<T, DashboardConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardConfigs and returns the data saved in the database.
     * @param {DashboardConfigCreateManyAndReturnArgs} args - Arguments to create many DashboardConfigs.
     * @example
     * // Create many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardConfigs and only return the `id`
     * const dashboardConfigWithIdOnly = await prisma.dashboardConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardConfig.
     * @param {DashboardConfigDeleteArgs} args - Arguments to delete one DashboardConfig.
     * @example
     * // Delete one DashboardConfig
     * const DashboardConfig = await prisma.dashboardConfig.delete({
     *   where: {
     *     // ... filter to delete one DashboardConfig
     *   }
     * })
     * 
     */
    delete<T extends DashboardConfigDeleteArgs>(args: SelectSubset<T, DashboardConfigDeleteArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardConfig.
     * @param {DashboardConfigUpdateArgs} args - Arguments to update one DashboardConfig.
     * @example
     * // Update one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardConfigUpdateArgs>(args: SelectSubset<T, DashboardConfigUpdateArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardConfigs.
     * @param {DashboardConfigDeleteManyArgs} args - Arguments to filter DashboardConfigs to delete.
     * @example
     * // Delete a few DashboardConfigs
     * const { count } = await prisma.dashboardConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardConfigDeleteManyArgs>(args?: SelectSubset<T, DashboardConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardConfigUpdateManyArgs>(args: SelectSubset<T, DashboardConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardConfigs and returns the data updated in the database.
     * @param {DashboardConfigUpdateManyAndReturnArgs} args - Arguments to update many DashboardConfigs.
     * @example
     * // Update many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardConfigs and only return the `id`
     * const dashboardConfigWithIdOnly = await prisma.dashboardConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardConfig.
     * @param {DashboardConfigUpsertArgs} args - Arguments to update or create a DashboardConfig.
     * @example
     * // Update or create a DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.upsert({
     *   create: {
     *     // ... data to create a DashboardConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardConfig we want to update
     *   }
     * })
     */
    upsert<T extends DashboardConfigUpsertArgs>(args: SelectSubset<T, DashboardConfigUpsertArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigCountArgs} args - Arguments to filter DashboardConfigs to count.
     * @example
     * // Count the number of DashboardConfigs
     * const count = await prisma.dashboardConfig.count({
     *   where: {
     *     // ... the filter for the DashboardConfigs we want to count
     *   }
     * })
    **/
    count<T extends DashboardConfigCountArgs>(
      args?: Subset<T, DashboardConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardConfigAggregateArgs>(args: Subset<T, DashboardConfigAggregateArgs>): Prisma.PrismaPromise<GetDashboardConfigAggregateType<T>>

    /**
     * Group by DashboardConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardConfigGroupByArgs['orderBy'] }
        : { orderBy?: DashboardConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardConfig model
   */
  readonly fields: DashboardConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardConfig model
   */
  interface DashboardConfigFieldRefs {
    readonly id: FieldRef<"DashboardConfig", 'String'>
    readonly userId: FieldRef<"DashboardConfig", 'String'>
    readonly type: FieldRef<"DashboardConfig", 'String'>
    readonly config: FieldRef<"DashboardConfig", 'Json'>
    readonly updatedAt: FieldRef<"DashboardConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardConfig findUnique
   */
  export type DashboardConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig findUniqueOrThrow
   */
  export type DashboardConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig findFirst
   */
  export type DashboardConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardConfigs.
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardConfigs.
     */
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * DashboardConfig findFirstOrThrow
   */
  export type DashboardConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardConfigs.
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardConfigs.
     */
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * DashboardConfig findMany
   */
  export type DashboardConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfigs to fetch.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardConfigs.
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * DashboardConfig create
   */
  export type DashboardConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardConfig.
     */
    data: XOR<DashboardConfigCreateInput, DashboardConfigUncheckedCreateInput>
  }

  /**
   * DashboardConfig createMany
   */
  export type DashboardConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardConfigs.
     */
    data: DashboardConfigCreateManyInput | DashboardConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardConfig createManyAndReturn
   */
  export type DashboardConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardConfigs.
     */
    data: DashboardConfigCreateManyInput | DashboardConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardConfig update
   */
  export type DashboardConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardConfig.
     */
    data: XOR<DashboardConfigUpdateInput, DashboardConfigUncheckedUpdateInput>
    /**
     * Choose, which DashboardConfig to update.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig updateMany
   */
  export type DashboardConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardConfigs.
     */
    data: XOR<DashboardConfigUpdateManyMutationInput, DashboardConfigUncheckedUpdateManyInput>
    /**
     * Filter which DashboardConfigs to update
     */
    where?: DashboardConfigWhereInput
    /**
     * Limit how many DashboardConfigs to update.
     */
    limit?: number
  }

  /**
   * DashboardConfig updateManyAndReturn
   */
  export type DashboardConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * The data used to update DashboardConfigs.
     */
    data: XOR<DashboardConfigUpdateManyMutationInput, DashboardConfigUncheckedUpdateManyInput>
    /**
     * Filter which DashboardConfigs to update
     */
    where?: DashboardConfigWhereInput
    /**
     * Limit how many DashboardConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardConfig upsert
   */
  export type DashboardConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardConfig to update in case it exists.
     */
    where: DashboardConfigWhereUniqueInput
    /**
     * In case the DashboardConfig found by the `where` argument doesn't exist, create a new DashboardConfig with this data.
     */
    create: XOR<DashboardConfigCreateInput, DashboardConfigUncheckedCreateInput>
    /**
     * In case the DashboardConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardConfigUpdateInput, DashboardConfigUncheckedUpdateInput>
  }

  /**
   * DashboardConfig delete
   */
  export type DashboardConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter which DashboardConfig to delete.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig deleteMany
   */
  export type DashboardConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardConfigs to delete
     */
    where?: DashboardConfigWhereInput
    /**
     * Limit how many DashboardConfigs to delete.
     */
    limit?: number
  }

  /**
   * DashboardConfig without action
   */
  export type DashboardConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardConfig
     */
    omit?: DashboardConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    hireDate: Date | null
    createdAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    hireDate: Date | null
    createdAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    bio: number
    specialties: number
    hireDate: number
    createdAt: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    hireDate?: true
    createdAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    hireDate?: true
    createdAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    specialties?: true
    hireDate?: true
    createdAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    bio: string | null
    specialties: string[]
    hireDate: Date | null
    createdAt: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hireDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hireDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hireDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hireDate?: boolean
    createdAt?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bio" | "specialties" | "hireDate" | "createdAt", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bio: string | null
      specialties: string[]
      hireDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly bio: FieldRef<"Teacher", 'String'>
    readonly specialties: FieldRef<"Teacher", 'String[]'>
    readonly hireDate: FieldRef<"Teacher", 'DateTime'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher updateManyAndReturn
   */
  export type TeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model InstitutionLog
   */

  export type AggregateInstitutionLog = {
    _count: InstitutionLogCountAggregateOutputType | null
    _min: InstitutionLogMinAggregateOutputType | null
    _max: InstitutionLogMaxAggregateOutputType | null
  }

  export type InstitutionLogMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    userId: string | null
    module: string | null
    action: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type InstitutionLogMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    userId: string | null
    module: string | null
    action: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type InstitutionLogCountAggregateOutputType = {
    id: number
    institutionId: number
    userId: number
    module: number
    action: number
    data: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type InstitutionLogMinAggregateInputType = {
    id?: true
    institutionId?: true
    userId?: true
    module?: true
    action?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type InstitutionLogMaxAggregateInputType = {
    id?: true
    institutionId?: true
    userId?: true
    module?: true
    action?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type InstitutionLogCountAggregateInputType = {
    id?: true
    institutionId?: true
    userId?: true
    module?: true
    action?: true
    data?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type InstitutionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstitutionLog to aggregate.
     */
    where?: InstitutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionLogs to fetch.
     */
    orderBy?: InstitutionLogOrderByWithRelationInput | InstitutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstitutionLogs
    **/
    _count?: true | InstitutionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionLogMaxAggregateInputType
  }

  export type GetInstitutionLogAggregateType<T extends InstitutionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutionLog[P]>
      : GetScalarType<T[P], AggregateInstitutionLog[P]>
  }




  export type InstitutionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionLogWhereInput
    orderBy?: InstitutionLogOrderByWithAggregationInput | InstitutionLogOrderByWithAggregationInput[]
    by: InstitutionLogScalarFieldEnum[] | InstitutionLogScalarFieldEnum
    having?: InstitutionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionLogCountAggregateInputType | true
    _min?: InstitutionLogMinAggregateInputType
    _max?: InstitutionLogMaxAggregateInputType
  }

  export type InstitutionLogGroupByOutputType = {
    id: string
    institutionId: string
    userId: string | null
    module: string | null
    action: string
    data: JsonValue | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    _count: InstitutionLogCountAggregateOutputType | null
    _min: InstitutionLogMinAggregateOutputType | null
    _max: InstitutionLogMaxAggregateOutputType | null
  }

  type GetInstitutionLogGroupByPayload<T extends InstitutionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionLogGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionLogGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    userId?: boolean
    module?: boolean
    action?: boolean
    data?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    user?: boolean | InstitutionLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["institutionLog"]>

  export type InstitutionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    userId?: boolean
    module?: boolean
    action?: boolean
    data?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    user?: boolean | InstitutionLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["institutionLog"]>

  export type InstitutionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    userId?: boolean
    module?: boolean
    action?: boolean
    data?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    user?: boolean | InstitutionLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["institutionLog"]>

  export type InstitutionLogSelectScalar = {
    id?: boolean
    institutionId?: boolean
    userId?: boolean
    module?: boolean
    action?: boolean
    data?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type InstitutionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "userId" | "module" | "action" | "data" | "ip" | "userAgent" | "createdAt", ExtArgs["result"]["institutionLog"]>
  export type InstitutionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    user?: boolean | InstitutionLog$userArgs<ExtArgs>
  }
  export type InstitutionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    user?: boolean | InstitutionLog$userArgs<ExtArgs>
  }
  export type InstitutionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    user?: boolean | InstitutionLog$userArgs<ExtArgs>
  }

  export type $InstitutionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstitutionLog"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      userId: string | null
      module: string | null
      action: string
      data: Prisma.JsonValue | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["institutionLog"]>
    composites: {}
  }

  type InstitutionLogGetPayload<S extends boolean | null | undefined | InstitutionLogDefaultArgs> = $Result.GetResult<Prisma.$InstitutionLogPayload, S>

  type InstitutionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionLogCountAggregateInputType | true
    }

  export interface InstitutionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstitutionLog'], meta: { name: 'InstitutionLog' } }
    /**
     * Find zero or one InstitutionLog that matches the filter.
     * @param {InstitutionLogFindUniqueArgs} args - Arguments to find a InstitutionLog
     * @example
     * // Get one InstitutionLog
     * const institutionLog = await prisma.institutionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionLogFindUniqueArgs>(args: SelectSubset<T, InstitutionLogFindUniqueArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstitutionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionLogFindUniqueOrThrowArgs} args - Arguments to find a InstitutionLog
     * @example
     * // Get one InstitutionLog
     * const institutionLog = await prisma.institutionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstitutionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogFindFirstArgs} args - Arguments to find a InstitutionLog
     * @example
     * // Get one InstitutionLog
     * const institutionLog = await prisma.institutionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionLogFindFirstArgs>(args?: SelectSubset<T, InstitutionLogFindFirstArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstitutionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogFindFirstOrThrowArgs} args - Arguments to find a InstitutionLog
     * @example
     * // Get one InstitutionLog
     * const institutionLog = await prisma.institutionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstitutionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstitutionLogs
     * const institutionLogs = await prisma.institutionLog.findMany()
     * 
     * // Get first 10 InstitutionLogs
     * const institutionLogs = await prisma.institutionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionLogWithIdOnly = await prisma.institutionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionLogFindManyArgs>(args?: SelectSubset<T, InstitutionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstitutionLog.
     * @param {InstitutionLogCreateArgs} args - Arguments to create a InstitutionLog.
     * @example
     * // Create one InstitutionLog
     * const InstitutionLog = await prisma.institutionLog.create({
     *   data: {
     *     // ... data to create a InstitutionLog
     *   }
     * })
     * 
     */
    create<T extends InstitutionLogCreateArgs>(args: SelectSubset<T, InstitutionLogCreateArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstitutionLogs.
     * @param {InstitutionLogCreateManyArgs} args - Arguments to create many InstitutionLogs.
     * @example
     * // Create many InstitutionLogs
     * const institutionLog = await prisma.institutionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionLogCreateManyArgs>(args?: SelectSubset<T, InstitutionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstitutionLogs and returns the data saved in the database.
     * @param {InstitutionLogCreateManyAndReturnArgs} args - Arguments to create many InstitutionLogs.
     * @example
     * // Create many InstitutionLogs
     * const institutionLog = await prisma.institutionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstitutionLogs and only return the `id`
     * const institutionLogWithIdOnly = await prisma.institutionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstitutionLog.
     * @param {InstitutionLogDeleteArgs} args - Arguments to delete one InstitutionLog.
     * @example
     * // Delete one InstitutionLog
     * const InstitutionLog = await prisma.institutionLog.delete({
     *   where: {
     *     // ... filter to delete one InstitutionLog
     *   }
     * })
     * 
     */
    delete<T extends InstitutionLogDeleteArgs>(args: SelectSubset<T, InstitutionLogDeleteArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstitutionLog.
     * @param {InstitutionLogUpdateArgs} args - Arguments to update one InstitutionLog.
     * @example
     * // Update one InstitutionLog
     * const institutionLog = await prisma.institutionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionLogUpdateArgs>(args: SelectSubset<T, InstitutionLogUpdateArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstitutionLogs.
     * @param {InstitutionLogDeleteManyArgs} args - Arguments to filter InstitutionLogs to delete.
     * @example
     * // Delete a few InstitutionLogs
     * const { count } = await prisma.institutionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionLogDeleteManyArgs>(args?: SelectSubset<T, InstitutionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstitutionLogs
     * const institutionLog = await prisma.institutionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionLogUpdateManyArgs>(args: SelectSubset<T, InstitutionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionLogs and returns the data updated in the database.
     * @param {InstitutionLogUpdateManyAndReturnArgs} args - Arguments to update many InstitutionLogs.
     * @example
     * // Update many InstitutionLogs
     * const institutionLog = await prisma.institutionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstitutionLogs and only return the `id`
     * const institutionLogWithIdOnly = await prisma.institutionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstitutionLog.
     * @param {InstitutionLogUpsertArgs} args - Arguments to update or create a InstitutionLog.
     * @example
     * // Update or create a InstitutionLog
     * const institutionLog = await prisma.institutionLog.upsert({
     *   create: {
     *     // ... data to create a InstitutionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstitutionLog we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionLogUpsertArgs>(args: SelectSubset<T, InstitutionLogUpsertArgs<ExtArgs>>): Prisma__InstitutionLogClient<$Result.GetResult<Prisma.$InstitutionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstitutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogCountArgs} args - Arguments to filter InstitutionLogs to count.
     * @example
     * // Count the number of InstitutionLogs
     * const count = await prisma.institutionLog.count({
     *   where: {
     *     // ... the filter for the InstitutionLogs we want to count
     *   }
     * })
    **/
    count<T extends InstitutionLogCountArgs>(
      args?: Subset<T, InstitutionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstitutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionLogAggregateArgs>(args: Subset<T, InstitutionLogAggregateArgs>): Prisma.PrismaPromise<GetInstitutionLogAggregateType<T>>

    /**
     * Group by InstitutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionLogGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstitutionLog model
   */
  readonly fields: InstitutionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstitutionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends InstitutionLog$userArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstitutionLog model
   */
  interface InstitutionLogFieldRefs {
    readonly id: FieldRef<"InstitutionLog", 'String'>
    readonly institutionId: FieldRef<"InstitutionLog", 'String'>
    readonly userId: FieldRef<"InstitutionLog", 'String'>
    readonly module: FieldRef<"InstitutionLog", 'String'>
    readonly action: FieldRef<"InstitutionLog", 'String'>
    readonly data: FieldRef<"InstitutionLog", 'Json'>
    readonly ip: FieldRef<"InstitutionLog", 'String'>
    readonly userAgent: FieldRef<"InstitutionLog", 'String'>
    readonly createdAt: FieldRef<"InstitutionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstitutionLog findUnique
   */
  export type InstitutionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionLog to fetch.
     */
    where: InstitutionLogWhereUniqueInput
  }

  /**
   * InstitutionLog findUniqueOrThrow
   */
  export type InstitutionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionLog to fetch.
     */
    where: InstitutionLogWhereUniqueInput
  }

  /**
   * InstitutionLog findFirst
   */
  export type InstitutionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionLog to fetch.
     */
    where?: InstitutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionLogs to fetch.
     */
    orderBy?: InstitutionLogOrderByWithRelationInput | InstitutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstitutionLogs.
     */
    cursor?: InstitutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstitutionLogs.
     */
    distinct?: InstitutionLogScalarFieldEnum | InstitutionLogScalarFieldEnum[]
  }

  /**
   * InstitutionLog findFirstOrThrow
   */
  export type InstitutionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionLog to fetch.
     */
    where?: InstitutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionLogs to fetch.
     */
    orderBy?: InstitutionLogOrderByWithRelationInput | InstitutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstitutionLogs.
     */
    cursor?: InstitutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstitutionLogs.
     */
    distinct?: InstitutionLogScalarFieldEnum | InstitutionLogScalarFieldEnum[]
  }

  /**
   * InstitutionLog findMany
   */
  export type InstitutionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * Filter, which InstitutionLogs to fetch.
     */
    where?: InstitutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstitutionLogs to fetch.
     */
    orderBy?: InstitutionLogOrderByWithRelationInput | InstitutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstitutionLogs.
     */
    cursor?: InstitutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstitutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstitutionLogs.
     */
    skip?: number
    distinct?: InstitutionLogScalarFieldEnum | InstitutionLogScalarFieldEnum[]
  }

  /**
   * InstitutionLog create
   */
  export type InstitutionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a InstitutionLog.
     */
    data: XOR<InstitutionLogCreateInput, InstitutionLogUncheckedCreateInput>
  }

  /**
   * InstitutionLog createMany
   */
  export type InstitutionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstitutionLogs.
     */
    data: InstitutionLogCreateManyInput | InstitutionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstitutionLog createManyAndReturn
   */
  export type InstitutionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * The data used to create many InstitutionLogs.
     */
    data: InstitutionLogCreateManyInput | InstitutionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstitutionLog update
   */
  export type InstitutionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a InstitutionLog.
     */
    data: XOR<InstitutionLogUpdateInput, InstitutionLogUncheckedUpdateInput>
    /**
     * Choose, which InstitutionLog to update.
     */
    where: InstitutionLogWhereUniqueInput
  }

  /**
   * InstitutionLog updateMany
   */
  export type InstitutionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstitutionLogs.
     */
    data: XOR<InstitutionLogUpdateManyMutationInput, InstitutionLogUncheckedUpdateManyInput>
    /**
     * Filter which InstitutionLogs to update
     */
    where?: InstitutionLogWhereInput
    /**
     * Limit how many InstitutionLogs to update.
     */
    limit?: number
  }

  /**
   * InstitutionLog updateManyAndReturn
   */
  export type InstitutionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * The data used to update InstitutionLogs.
     */
    data: XOR<InstitutionLogUpdateManyMutationInput, InstitutionLogUncheckedUpdateManyInput>
    /**
     * Filter which InstitutionLogs to update
     */
    where?: InstitutionLogWhereInput
    /**
     * Limit how many InstitutionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstitutionLog upsert
   */
  export type InstitutionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the InstitutionLog to update in case it exists.
     */
    where: InstitutionLogWhereUniqueInput
    /**
     * In case the InstitutionLog found by the `where` argument doesn't exist, create a new InstitutionLog with this data.
     */
    create: XOR<InstitutionLogCreateInput, InstitutionLogUncheckedCreateInput>
    /**
     * In case the InstitutionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionLogUpdateInput, InstitutionLogUncheckedUpdateInput>
  }

  /**
   * InstitutionLog delete
   */
  export type InstitutionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
    /**
     * Filter which InstitutionLog to delete.
     */
    where: InstitutionLogWhereUniqueInput
  }

  /**
   * InstitutionLog deleteMany
   */
  export type InstitutionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstitutionLogs to delete
     */
    where?: InstitutionLogWhereInput
    /**
     * Limit how many InstitutionLogs to delete.
     */
    limit?: number
  }

  /**
   * InstitutionLog.user
   */
  export type InstitutionLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InstitutionLog without action
   */
  export type InstitutionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionLog
     */
    select?: InstitutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionLog
     */
    omit?: InstitutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    price: 'price',
    currency: 'currency',
    studentLimit: 'studentLimit',
    teacherLimit: 'teacherLimit',
    adminLimit: 'adminLimit',
    courseLimit: 'courseLimit',
    aiTeacherCallsMonthly: 'aiTeacherCallsMonthly',
    aiStudentMinutesMonthly: 'aiStudentMinutesMonthly',
    certificateMonthly: 'certificateMonthly',
    virtualClassroomLimit: 'virtualClassroomLimit',
    storageMB: 'storageMB',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const InstitutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    contactEmail: 'contactEmail',
    phone: 'phone',
    address: 'address',
    planId: 'planId',
    settings: 'settings',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const InstitutionSubscriptionScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    autoRenew: 'autoRenew',
    billingCycle: 'billingCycle',
    createdAt: 'createdAt'
  };

  export type InstitutionSubscriptionScalarFieldEnum = (typeof InstitutionSubscriptionScalarFieldEnum)[keyof typeof InstitutionSubscriptionScalarFieldEnum]


  export const InstitutionPaymentScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    status: 'status',
    gatewayData: 'gatewayData',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type InstitutionPaymentScalarFieldEnum = (typeof InstitutionPaymentScalarFieldEnum)[keyof typeof InstitutionPaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    ci: 'ci',
    phone: 'phone',
    isActive: 'isActive',
    attributes: 'attributes',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    isPrimary: 'isPrimary',
    assignedAt: 'assignedAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const ABACPolicyScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    description: 'description',
    resource: 'resource',
    action: 'action',
    condition: 'condition',
    effect: 'effect',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ABACPolicyScalarFieldEnum = (typeof ABACPolicyScalarFieldEnum)[keyof typeof ABACPolicyScalarFieldEnum]


  export const CareerScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    code: 'code',
    level: 'level',
    description: 'description',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type CareerScalarFieldEnum = (typeof CareerScalarFieldEnum)[keyof typeof CareerScalarFieldEnum]


  export const AcademicPeriodScalarFieldEnum: {
    id: 'id',
    careerId: 'careerId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AcademicPeriodScalarFieldEnum = (typeof AcademicPeriodScalarFieldEnum)[keyof typeof AcademicPeriodScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    careerId: 'careerId',
    academicPeriodId: 'academicPeriodId',
    name: 'name',
    code: 'code',
    description: 'description',
    credits: 'credits',
    durationSemesters: 'durationSemesters',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    name: 'name',
    code: 'code',
    description: 'description',
    semester: 'semester',
    credits: 'credits',
    createdAt: 'createdAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const VirtualClassroomScalarFieldEnum: {
    id: 'id',
    subjectId: 'subjectId',
    code: 'code',
    title: 'title',
    teacherId: 'teacherId',
    aiEnabled: 'aiEnabled',
    aiConfig: 'aiConfig',
    createdAt: 'createdAt',
    aiagentId: 'aiagentId'
  };

  export type VirtualClassroomScalarFieldEnum = (typeof VirtualClassroomScalarFieldEnum)[keyof typeof VirtualClassroomScalarFieldEnum]


  export const LessonPlanScalarFieldEnum: {
    id: 'id',
    classroomId: 'classroomId',
    date: 'date',
    topic: 'topic',
    aiSuggestions: 'aiSuggestions',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type LessonPlanScalarFieldEnum = (typeof LessonPlanScalarFieldEnum)[keyof typeof LessonPlanScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentNumber: 'studentNumber',
    institutionId: 'institutionId',
    careerId: 'careerId',
    enrollmentDate: 'enrollmentDate',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    academicPeriodId: 'academicPeriodId',
    enrolledAt: 'enrolledAt',
    status: 'status'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const StudentSubjectScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    classroomId: 'classroomId',
    semester: 'semester',
    year: 'year',
    finalGrade: 'finalGrade',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type StudentSubjectScalarFieldEnum = (typeof StudentSubjectScalarFieldEnum)[keyof typeof StudentSubjectScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    studentSubjectId: 'studentSubjectId',
    type: 'type',
    weight: 'weight',
    value: 'value',
    comments: 'comments',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classroomId: 'classroomId',
    date: 'date',
    status: 'status',
    notedById: 'notedById',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const DisciplinaryRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    recordedById: 'recordedById',
    type: 'type',
    description: 'description',
    actionTaken: 'actionTaken',
    date: 'date',
    seenByTutor: 'seenByTutor'
  };

  export type DisciplinaryRecordScalarFieldEnum = (typeof DisciplinaryRecordScalarFieldEnum)[keyof typeof DisciplinaryRecordScalarFieldEnum]


  export const TutorProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    institutionId: 'institutionId',
    relationship: 'relationship',
    phone: 'phone',
    address: 'address',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type TutorProfileScalarFieldEnum = (typeof TutorProfileScalarFieldEnum)[keyof typeof TutorProfileScalarFieldEnum]


  export const TutorStudentScalarFieldEnum: {
    id: 'id',
    tutorId: 'tutorId',
    studentId: 'studentId',
    isPrimary: 'isPrimary',
    assignedAt: 'assignedAt'
  };

  export type TutorStudentScalarFieldEnum = (typeof TutorStudentScalarFieldEnum)[keyof typeof TutorStudentScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    subjectId: 'subjectId',
    type: 'type',
    issuedAt: 'issuedAt',
    fileUrl: 'fileUrl',
    issuedById: 'issuedById',
    metadata: 'metadata'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const FeeScheduleScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    careerId: 'careerId',
    name: 'name',
    totalAmount: 'totalAmount',
    currency: 'currency',
    installments: 'installments',
    frequency: 'frequency',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type FeeScheduleScalarFieldEnum = (typeof FeeScheduleScalarFieldEnum)[keyof typeof FeeScheduleScalarFieldEnum]


  export const FeeInstallmentScalarFieldEnum: {
    id: 'id',
    feeScheduleId: 'feeScheduleId',
    sequence: 'sequence',
    dueDate: 'dueDate',
    amount: 'amount',
    createdAt: 'createdAt'
  };

  export type FeeInstallmentScalarFieldEnum = (typeof FeeInstallmentScalarFieldEnum)[keyof typeof FeeInstallmentScalarFieldEnum]


  export const StudentPaymentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    institutionId: 'institutionId',
    feeInstallmentId: 'feeInstallmentId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    status: 'status',
    reference: 'reference',
    gatewayData: 'gatewayData',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type StudentPaymentScalarFieldEnum = (typeof StudentPaymentScalarFieldEnum)[keyof typeof StudentPaymentScalarFieldEnum]


  export const PaymentPlanScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    feeScheduleId: 'feeScheduleId',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    remainingAmount: 'remainingAmount',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type PaymentPlanScalarFieldEnum = (typeof PaymentPlanScalarFieldEnum)[keyof typeof PaymentPlanScalarFieldEnum]


  export const AIAgentScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    type: 'type',
    name: 'name',
    personality: 'personality',
    specialization: 'specialization',
    maxTokensPerCall: 'maxTokensPerCall',
    temperature: 'temperature',
    systemPrompt: 'systemPrompt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AIAgentScalarFieldEnum = (typeof AIAgentScalarFieldEnum)[keyof typeof AIAgentScalarFieldEnum]


  export const AIConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agentId: 'agentId',
    sessionId: 'sessionId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    totalTokens: 'totalTokens',
    totalCost: 'totalCost'
  };

  export type AIConversationScalarFieldEnum = (typeof AIConversationScalarFieldEnum)[keyof typeof AIConversationScalarFieldEnum]


  export const AIMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    tokens: 'tokens',
    createdAt: 'createdAt'
  };

  export type AIMessageScalarFieldEnum = (typeof AIMessageScalarFieldEnum)[keyof typeof AIMessageScalarFieldEnum]


  export const AIUsageLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    institutionId: 'institutionId',
    classroomId: 'classroomId',
    promptSummary: 'promptSummary',
    responseSummary: 'responseSummary',
    tokensUsed: 'tokensUsed',
    cost: 'cost',
    createdAt: 'createdAt'
  };

  export type AIUsageLogScalarFieldEnum = (typeof AIUsageLogScalarFieldEnum)[keyof typeof AIUsageLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    title: 'title',
    body: 'body',
    meta: 'meta',
    isRead: 'isRead',
    readAt: 'readAt',
    pushSent: 'pushSent',
    emailSent: 'emailSent',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    preferences: 'preferences',
    createdAt: 'createdAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    recipientId: 'recipientId',
    subject: 'subject',
    body: 'body',
    attachments: 'attachments',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    title: 'title',
    body: 'body',
    targetRoles: 'targetRoles',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const DataBackupScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    description: 'description',
    storageUrl: 'storageUrl',
    sizeBytes: 'sizeBytes',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type DataBackupScalarFieldEnum = (typeof DataBackupScalarFieldEnum)[keyof typeof DataBackupScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    type: 'type',
    body: 'body',
    metadata: 'metadata',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    config: 'config',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const ApiClientScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    clientId: 'clientId',
    clientName: 'clientName',
    clientType: 'clientType',
    apiKeyHash: 'apiKeyHash',
    scopes: 'scopes',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ApiClientScalarFieldEnum = (typeof ApiClientScalarFieldEnum)[keyof typeof ApiClientScalarFieldEnum]


  export const ApiUsageLogScalarFieldEnum: {
    id: 'id',
    apiClientId: 'apiClientId',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    latencyMs: 'latencyMs',
    createdAt: 'createdAt'
  };

  export type ApiUsageLogScalarFieldEnum = (typeof ApiUsageLogScalarFieldEnum)[keyof typeof ApiUsageLogScalarFieldEnum]


  export const ApiScopeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type ApiScopeScalarFieldEnum = (typeof ApiScopeScalarFieldEnum)[keyof typeof ApiScopeScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    url: 'url',
    events: 'events',
    secret: 'secret',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    status: 'status',
    response: 'response',
    attempt: 'attempt',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const ApiKeyRotationScalarFieldEnum: {
    id: 'id',
    apiClientId: 'apiClientId',
    keyHash: 'keyHash',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type ApiKeyRotationScalarFieldEnum = (typeof ApiKeyRotationScalarFieldEnum)[keyof typeof ApiKeyRotationScalarFieldEnum]


  export const DashboardConfigScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    config: 'config',
    updatedAt: 'updatedAt'
  };

  export type DashboardConfigScalarFieldEnum = (typeof DashboardConfigScalarFieldEnum)[keyof typeof DashboardConfigScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    specialties: 'specialties',
    hireDate: 'hireDate',
    createdAt: 'createdAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const InstitutionLogScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    userId: 'userId',
    module: 'module',
    action: 'action',
    data: 'data',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type InstitutionLogScalarFieldEnum = (typeof InstitutionLogScalarFieldEnum)[keyof typeof InstitutionLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>
    


  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>
    


  /**
   * Reference to a field of type 'PolicyEffect'
   */
  export type EnumPolicyEffectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PolicyEffect'>
    


  /**
   * Reference to a field of type 'PolicyEffect[]'
   */
  export type ListEnumPolicyEffectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PolicyEffect[]'>
    


  /**
   * Reference to a field of type 'LevelType'
   */
  export type EnumLevelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LevelType'>
    


  /**
   * Reference to a field of type 'LevelType[]'
   */
  export type ListEnumLevelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LevelType[]'>
    


  /**
   * Reference to a field of type 'StudentStatus'
   */
  export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus'>
    


  /**
   * Reference to a field of type 'StudentStatus[]'
   */
  export type ListEnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus[]'>
    


  /**
   * Reference to a field of type 'GradeType'
   */
  export type EnumGradeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GradeType'>
    


  /**
   * Reference to a field of type 'GradeType[]'
   */
  export type ListEnumGradeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GradeType[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'CertificateType'
   */
  export type EnumCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificateType'>
    


  /**
   * Reference to a field of type 'CertificateType[]'
   */
  export type ListEnumCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificateType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    slug?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Plan"> | string
    studentLimit?: IntFilter<"Plan"> | number
    teacherLimit?: IntFilter<"Plan"> | number
    adminLimit?: IntFilter<"Plan"> | number
    courseLimit?: IntFilter<"Plan"> | number
    aiTeacherCallsMonthly?: IntFilter<"Plan"> | number
    aiStudentMinutesMonthly?: IntFilter<"Plan"> | number
    certificateMonthly?: IntFilter<"Plan"> | number
    virtualClassroomLimit?: IntFilter<"Plan"> | number
    storageMB?: IntFilter<"Plan"> | number
    features?: JsonNullableFilter<"Plan">
    isActive?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    institutions?: InstitutionListRelationFilter
    InstitutionSubscription?: InstitutionSubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    institutions?: InstitutionOrderByRelationAggregateInput
    InstitutionSubscription?: InstitutionSubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Plan"> | string
    studentLimit?: IntFilter<"Plan"> | number
    teacherLimit?: IntFilter<"Plan"> | number
    adminLimit?: IntFilter<"Plan"> | number
    courseLimit?: IntFilter<"Plan"> | number
    aiTeacherCallsMonthly?: IntFilter<"Plan"> | number
    aiStudentMinutesMonthly?: IntFilter<"Plan"> | number
    certificateMonthly?: IntFilter<"Plan"> | number
    virtualClassroomLimit?: IntFilter<"Plan"> | number
    storageMB?: IntFilter<"Plan"> | number
    features?: JsonNullableFilter<"Plan">
    isActive?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    institutions?: InstitutionListRelationFilter
    InstitutionSubscription?: InstitutionSubscriptionListRelationFilter
  }, "id" | "slug">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    slug?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    price?: DecimalWithAggregatesFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Plan"> | string
    studentLimit?: IntWithAggregatesFilter<"Plan"> | number
    teacherLimit?: IntWithAggregatesFilter<"Plan"> | number
    adminLimit?: IntWithAggregatesFilter<"Plan"> | number
    courseLimit?: IntWithAggregatesFilter<"Plan"> | number
    aiTeacherCallsMonthly?: IntWithAggregatesFilter<"Plan"> | number
    aiStudentMinutesMonthly?: IntWithAggregatesFilter<"Plan"> | number
    certificateMonthly?: IntWithAggregatesFilter<"Plan"> | number
    virtualClassroomLimit?: IntWithAggregatesFilter<"Plan"> | number
    storageMB?: IntWithAggregatesFilter<"Plan"> | number
    features?: JsonNullableWithAggregatesFilter<"Plan">
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    slug?: StringFilter<"Institution"> | string
    contactEmail?: StringFilter<"Institution"> | string
    phone?: StringNullableFilter<"Institution"> | string | null
    address?: JsonNullableFilter<"Institution">
    planId?: StringNullableFilter<"Institution"> | string | null
    settings?: JsonNullableFilter<"Institution">
    status?: StringNullableFilter<"Institution"> | string | null
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    users?: UserListRelationFilter
    roles?: RoleListRelationFilter
    careers?: CareerListRelationFilter
    subscriptions?: InstitutionSubscriptionListRelationFilter
    institutionPayments?: InstitutionPaymentListRelationFilter
    institutionLogs?: InstitutionLogListRelationFilter
    aiUsageLogs?: AIUsageLogListRelationFilter
    templates?: TemplateListRelationFilter
    integrations?: IntegrationListRelationFilter
    apiClients?: ApiClientListRelationFilter
    announcements?: AnnouncementListRelationFilter
    backups?: DataBackupListRelationFilter
    feeSchedules?: FeeScheduleListRelationFilter
    ABACPolicy?: ABACPolicyListRelationFilter
    students?: StudentListRelationFilter
    tutorProfile?: TutorProfileListRelationFilter
    studentPayments?: StudentPaymentListRelationFilter
    aiAgents?: AIAgentListRelationFilter
    webhooks?: WebhookListRelationFilter
  }

  export type InstitutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    contactEmail?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    careers?: CareerOrderByRelationAggregateInput
    subscriptions?: InstitutionSubscriptionOrderByRelationAggregateInput
    institutionPayments?: InstitutionPaymentOrderByRelationAggregateInput
    institutionLogs?: InstitutionLogOrderByRelationAggregateInput
    aiUsageLogs?: AIUsageLogOrderByRelationAggregateInput
    templates?: TemplateOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    apiClients?: ApiClientOrderByRelationAggregateInput
    announcements?: AnnouncementOrderByRelationAggregateInput
    backups?: DataBackupOrderByRelationAggregateInput
    feeSchedules?: FeeScheduleOrderByRelationAggregateInput
    ABACPolicy?: ABACPolicyOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    tutorProfile?: TutorProfileOrderByRelationAggregateInput
    studentPayments?: StudentPaymentOrderByRelationAggregateInput
    aiAgents?: AIAgentOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
  }

  export type InstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    name?: StringFilter<"Institution"> | string
    contactEmail?: StringFilter<"Institution"> | string
    phone?: StringNullableFilter<"Institution"> | string | null
    address?: JsonNullableFilter<"Institution">
    planId?: StringNullableFilter<"Institution"> | string | null
    settings?: JsonNullableFilter<"Institution">
    status?: StringNullableFilter<"Institution"> | string | null
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    users?: UserListRelationFilter
    roles?: RoleListRelationFilter
    careers?: CareerListRelationFilter
    subscriptions?: InstitutionSubscriptionListRelationFilter
    institutionPayments?: InstitutionPaymentListRelationFilter
    institutionLogs?: InstitutionLogListRelationFilter
    aiUsageLogs?: AIUsageLogListRelationFilter
    templates?: TemplateListRelationFilter
    integrations?: IntegrationListRelationFilter
    apiClients?: ApiClientListRelationFilter
    announcements?: AnnouncementListRelationFilter
    backups?: DataBackupListRelationFilter
    feeSchedules?: FeeScheduleListRelationFilter
    ABACPolicy?: ABACPolicyListRelationFilter
    students?: StudentListRelationFilter
    tutorProfile?: TutorProfileListRelationFilter
    studentPayments?: StudentPaymentListRelationFilter
    aiAgents?: AIAgentListRelationFilter
    webhooks?: WebhookListRelationFilter
  }, "id" | "slug">

  export type InstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    contactEmail?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InstitutionCountOrderByAggregateInput
    _max?: InstitutionMaxOrderByAggregateInput
    _min?: InstitutionMinOrderByAggregateInput
  }

  export type InstitutionScalarWhereWithAggregatesInput = {
    AND?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    OR?: InstitutionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Institution"> | string
    name?: StringWithAggregatesFilter<"Institution"> | string
    slug?: StringWithAggregatesFilter<"Institution"> | string
    contactEmail?: StringWithAggregatesFilter<"Institution"> | string
    phone?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Institution">
    planId?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"Institution">
    status?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
  }

  export type InstitutionSubscriptionWhereInput = {
    AND?: InstitutionSubscriptionWhereInput | InstitutionSubscriptionWhereInput[]
    OR?: InstitutionSubscriptionWhereInput[]
    NOT?: InstitutionSubscriptionWhereInput | InstitutionSubscriptionWhereInput[]
    id?: StringFilter<"InstitutionSubscription"> | string
    institutionId?: StringFilter<"InstitutionSubscription"> | string
    planId?: StringFilter<"InstitutionSubscription"> | string
    startDate?: DateTimeFilter<"InstitutionSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"InstitutionSubscription"> | Date | string | null
    status?: EnumSubscriptionStatusFilter<"InstitutionSubscription"> | $Enums.SubscriptionStatus
    autoRenew?: BoolFilter<"InstitutionSubscription"> | boolean
    billingCycle?: StringNullableFilter<"InstitutionSubscription"> | string | null
    createdAt?: DateTimeFilter<"InstitutionSubscription"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    payments?: InstitutionPaymentListRelationFilter
  }

  export type InstitutionSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    billingCycle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    payments?: InstitutionPaymentOrderByRelationAggregateInput
  }

  export type InstitutionSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstitutionSubscriptionWhereInput | InstitutionSubscriptionWhereInput[]
    OR?: InstitutionSubscriptionWhereInput[]
    NOT?: InstitutionSubscriptionWhereInput | InstitutionSubscriptionWhereInput[]
    institutionId?: StringFilter<"InstitutionSubscription"> | string
    planId?: StringFilter<"InstitutionSubscription"> | string
    startDate?: DateTimeFilter<"InstitutionSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"InstitutionSubscription"> | Date | string | null
    status?: EnumSubscriptionStatusFilter<"InstitutionSubscription"> | $Enums.SubscriptionStatus
    autoRenew?: BoolFilter<"InstitutionSubscription"> | boolean
    billingCycle?: StringNullableFilter<"InstitutionSubscription"> | string | null
    createdAt?: DateTimeFilter<"InstitutionSubscription"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    payments?: InstitutionPaymentListRelationFilter
  }, "id">

  export type InstitutionSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    billingCycle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InstitutionSubscriptionCountOrderByAggregateInput
    _max?: InstitutionSubscriptionMaxOrderByAggregateInput
    _min?: InstitutionSubscriptionMinOrderByAggregateInput
  }

  export type InstitutionSubscriptionScalarWhereWithAggregatesInput = {
    AND?: InstitutionSubscriptionScalarWhereWithAggregatesInput | InstitutionSubscriptionScalarWhereWithAggregatesInput[]
    OR?: InstitutionSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionSubscriptionScalarWhereWithAggregatesInput | InstitutionSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstitutionSubscription"> | string
    institutionId?: StringWithAggregatesFilter<"InstitutionSubscription"> | string
    planId?: StringWithAggregatesFilter<"InstitutionSubscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"InstitutionSubscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"InstitutionSubscription"> | Date | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter<"InstitutionSubscription"> | $Enums.SubscriptionStatus
    autoRenew?: BoolWithAggregatesFilter<"InstitutionSubscription"> | boolean
    billingCycle?: StringNullableWithAggregatesFilter<"InstitutionSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InstitutionSubscription"> | Date | string
  }

  export type InstitutionPaymentWhereInput = {
    AND?: InstitutionPaymentWhereInput | InstitutionPaymentWhereInput[]
    OR?: InstitutionPaymentWhereInput[]
    NOT?: InstitutionPaymentWhereInput | InstitutionPaymentWhereInput[]
    id?: StringFilter<"InstitutionPayment"> | string
    institutionId?: StringFilter<"InstitutionPayment"> | string
    subscriptionId?: StringNullableFilter<"InstitutionPayment"> | string | null
    amount?: DecimalFilter<"InstitutionPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"InstitutionPayment"> | string
    method?: EnumPaymentMethodFilter<"InstitutionPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"InstitutionPayment"> | $Enums.PaymentStatus
    gatewayData?: JsonNullableFilter<"InstitutionPayment">
    reference?: StringNullableFilter<"InstitutionPayment"> | string | null
    createdAt?: DateTimeFilter<"InstitutionPayment"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    subscription?: XOR<InstitutionSubscriptionNullableScalarRelationFilter, InstitutionSubscriptionWhereInput> | null
  }

  export type InstitutionPaymentOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayData?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    subscription?: InstitutionSubscriptionOrderByWithRelationInput
  }

  export type InstitutionPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: InstitutionPaymentWhereInput | InstitutionPaymentWhereInput[]
    OR?: InstitutionPaymentWhereInput[]
    NOT?: InstitutionPaymentWhereInput | InstitutionPaymentWhereInput[]
    institutionId?: StringFilter<"InstitutionPayment"> | string
    subscriptionId?: StringNullableFilter<"InstitutionPayment"> | string | null
    amount?: DecimalFilter<"InstitutionPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"InstitutionPayment"> | string
    method?: EnumPaymentMethodFilter<"InstitutionPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"InstitutionPayment"> | $Enums.PaymentStatus
    gatewayData?: JsonNullableFilter<"InstitutionPayment">
    createdAt?: DateTimeFilter<"InstitutionPayment"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    subscription?: XOR<InstitutionSubscriptionNullableScalarRelationFilter, InstitutionSubscriptionWhereInput> | null
  }, "id" | "reference">

  export type InstitutionPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayData?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InstitutionPaymentCountOrderByAggregateInput
    _avg?: InstitutionPaymentAvgOrderByAggregateInput
    _max?: InstitutionPaymentMaxOrderByAggregateInput
    _min?: InstitutionPaymentMinOrderByAggregateInput
    _sum?: InstitutionPaymentSumOrderByAggregateInput
  }

  export type InstitutionPaymentScalarWhereWithAggregatesInput = {
    AND?: InstitutionPaymentScalarWhereWithAggregatesInput | InstitutionPaymentScalarWhereWithAggregatesInput[]
    OR?: InstitutionPaymentScalarWhereWithAggregatesInput[]
    NOT?: InstitutionPaymentScalarWhereWithAggregatesInput | InstitutionPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstitutionPayment"> | string
    institutionId?: StringWithAggregatesFilter<"InstitutionPayment"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"InstitutionPayment"> | string | null
    amount?: DecimalWithAggregatesFilter<"InstitutionPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"InstitutionPayment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"InstitutionPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"InstitutionPayment"> | $Enums.PaymentStatus
    gatewayData?: JsonNullableWithAggregatesFilter<"InstitutionPayment">
    reference?: StringNullableWithAggregatesFilter<"InstitutionPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InstitutionPayment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    institutionId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    ci?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    attributes?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    tutorProfile?: XOR<TutorProfileNullableScalarRelationFilter, TutorProfileWhereInput> | null
    dashboards?: DashboardConfigListRelationFilter
    aiUsages?: AIUsageLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
    logs?: InstitutionLogListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    careers?: CareerListRelationFilter
    courses?: CourseListRelationFilter
    lessonPlans?: LessonPlanListRelationFilter
    virtualClassrooms?: VirtualClassroomListRelationFilter
    grades?: GradeListRelationFilter
    attendances?: AttendanceListRelationFilter
    disciplinaryRecord?: DisciplinaryRecordListRelationFilter
    certificate?: CertificateListRelationFilter
    aIConversation?: AIConversationListRelationFilter
    notificationPreference?: NotificationPreferenceListRelationFilter
    announcement?: AnnouncementListRelationFilter
    dataBackups?: DataBackupListRelationFilter
    templates?: TemplateListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    fullName?: SortOrder
    ci?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    attributes?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    tutorProfile?: TutorProfileOrderByWithRelationInput
    dashboards?: DashboardConfigOrderByRelationAggregateInput
    aiUsages?: AIUsageLogOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    logs?: InstitutionLogOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    careers?: CareerOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    lessonPlans?: LessonPlanOrderByRelationAggregateInput
    virtualClassrooms?: VirtualClassroomOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    disciplinaryRecord?: DisciplinaryRecordOrderByRelationAggregateInput
    certificate?: CertificateOrderByRelationAggregateInput
    aIConversation?: AIConversationOrderByRelationAggregateInput
    notificationPreference?: NotificationPreferenceOrderByRelationAggregateInput
    announcement?: AnnouncementOrderByRelationAggregateInput
    dataBackups?: DataBackupOrderByRelationAggregateInput
    templates?: TemplateOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    institutionId?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    ci?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    attributes?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    tutorProfile?: XOR<TutorProfileNullableScalarRelationFilter, TutorProfileWhereInput> | null
    dashboards?: DashboardConfigListRelationFilter
    aiUsages?: AIUsageLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
    logs?: InstitutionLogListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    careers?: CareerListRelationFilter
    courses?: CourseListRelationFilter
    lessonPlans?: LessonPlanListRelationFilter
    virtualClassrooms?: VirtualClassroomListRelationFilter
    grades?: GradeListRelationFilter
    attendances?: AttendanceListRelationFilter
    disciplinaryRecord?: DisciplinaryRecordListRelationFilter
    certificate?: CertificateListRelationFilter
    aIConversation?: AIConversationListRelationFilter
    notificationPreference?: NotificationPreferenceListRelationFilter
    announcement?: AnnouncementListRelationFilter
    dataBackups?: DataBackupListRelationFilter
    templates?: TemplateListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    fullName?: SortOrder
    ci?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    attributes?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    institutionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringWithAggregatesFilter<"User"> | string
    ci?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    attributes?: JsonNullableWithAggregatesFilter<"User">
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    institutionId?: StringNullableFilter<"Role"> | string | null
    name?: EnumRoleNameFilter<"Role"> | $Enums.RoleName
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    institutionId?: StringNullableFilter<"Role"> | string | null
    name?: EnumRoleNameFilter<"Role"> | $Enums.RoleName
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    userRoles?: UserRoleListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    institutionId?: StringNullableWithAggregatesFilter<"Role"> | string | null
    name?: EnumRoleNameWithAggregatesFilter<"Role"> | $Enums.RoleName
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    isPrimary?: BoolFilter<"UserRole"> | boolean
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    isPrimary?: BoolFilter<"UserRole"> | boolean
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    isPrimary?: BoolWithAggregatesFilter<"UserRole"> | boolean
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type ABACPolicyWhereInput = {
    AND?: ABACPolicyWhereInput | ABACPolicyWhereInput[]
    OR?: ABACPolicyWhereInput[]
    NOT?: ABACPolicyWhereInput | ABACPolicyWhereInput[]
    id?: StringFilter<"ABACPolicy"> | string
    institutionId?: StringNullableFilter<"ABACPolicy"> | string | null
    name?: StringFilter<"ABACPolicy"> | string
    description?: StringNullableFilter<"ABACPolicy"> | string | null
    resource?: StringFilter<"ABACPolicy"> | string
    action?: StringFilter<"ABACPolicy"> | string
    condition?: JsonNullableFilter<"ABACPolicy">
    effect?: EnumPolicyEffectFilter<"ABACPolicy"> | $Enums.PolicyEffect
    isActive?: BoolFilter<"ABACPolicy"> | boolean
    createdAt?: DateTimeFilter<"ABACPolicy"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
  }

  export type ABACPolicyOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    condition?: SortOrderInput | SortOrder
    effect?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
  }

  export type ABACPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ABACPolicyWhereInput | ABACPolicyWhereInput[]
    OR?: ABACPolicyWhereInput[]
    NOT?: ABACPolicyWhereInput | ABACPolicyWhereInput[]
    institutionId?: StringNullableFilter<"ABACPolicy"> | string | null
    name?: StringFilter<"ABACPolicy"> | string
    description?: StringNullableFilter<"ABACPolicy"> | string | null
    resource?: StringFilter<"ABACPolicy"> | string
    action?: StringFilter<"ABACPolicy"> | string
    condition?: JsonNullableFilter<"ABACPolicy">
    effect?: EnumPolicyEffectFilter<"ABACPolicy"> | $Enums.PolicyEffect
    isActive?: BoolFilter<"ABACPolicy"> | boolean
    createdAt?: DateTimeFilter<"ABACPolicy"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
  }, "id">

  export type ABACPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    condition?: SortOrderInput | SortOrder
    effect?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ABACPolicyCountOrderByAggregateInput
    _max?: ABACPolicyMaxOrderByAggregateInput
    _min?: ABACPolicyMinOrderByAggregateInput
  }

  export type ABACPolicyScalarWhereWithAggregatesInput = {
    AND?: ABACPolicyScalarWhereWithAggregatesInput | ABACPolicyScalarWhereWithAggregatesInput[]
    OR?: ABACPolicyScalarWhereWithAggregatesInput[]
    NOT?: ABACPolicyScalarWhereWithAggregatesInput | ABACPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ABACPolicy"> | string
    institutionId?: StringNullableWithAggregatesFilter<"ABACPolicy"> | string | null
    name?: StringWithAggregatesFilter<"ABACPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"ABACPolicy"> | string | null
    resource?: StringWithAggregatesFilter<"ABACPolicy"> | string
    action?: StringWithAggregatesFilter<"ABACPolicy"> | string
    condition?: JsonNullableWithAggregatesFilter<"ABACPolicy">
    effect?: EnumPolicyEffectWithAggregatesFilter<"ABACPolicy"> | $Enums.PolicyEffect
    isActive?: BoolWithAggregatesFilter<"ABACPolicy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ABACPolicy"> | Date | string
  }

  export type CareerWhereInput = {
    AND?: CareerWhereInput | CareerWhereInput[]
    OR?: CareerWhereInput[]
    NOT?: CareerWhereInput | CareerWhereInput[]
    id?: StringFilter<"Career"> | string
    institutionId?: StringFilter<"Career"> | string
    name?: StringFilter<"Career"> | string
    code?: StringNullableFilter<"Career"> | string | null
    level?: EnumLevelTypeFilter<"Career"> | $Enums.LevelType
    description?: StringNullableFilter<"Career"> | string | null
    createdById?: StringNullableFilter<"Career"> | string | null
    createdAt?: DateTimeFilter<"Career"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courses?: CourseListRelationFilter
    periods?: AcademicPeriodListRelationFilter
    students?: StudentListRelationFilter
    feeSchedule?: FeeScheduleListRelationFilter
  }

  export type CareerOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    courses?: CourseOrderByRelationAggregateInput
    periods?: AcademicPeriodOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    feeSchedule?: FeeScheduleOrderByRelationAggregateInput
  }

  export type CareerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_institution_career_code?: CareerUnique_institution_career_codeCompoundUniqueInput
    AND?: CareerWhereInput | CareerWhereInput[]
    OR?: CareerWhereInput[]
    NOT?: CareerWhereInput | CareerWhereInput[]
    institutionId?: StringFilter<"Career"> | string
    name?: StringFilter<"Career"> | string
    code?: StringNullableFilter<"Career"> | string | null
    level?: EnumLevelTypeFilter<"Career"> | $Enums.LevelType
    description?: StringNullableFilter<"Career"> | string | null
    createdById?: StringNullableFilter<"Career"> | string | null
    createdAt?: DateTimeFilter<"Career"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courses?: CourseListRelationFilter
    periods?: AcademicPeriodListRelationFilter
    students?: StudentListRelationFilter
    feeSchedule?: FeeScheduleListRelationFilter
  }, "id" | "unique_institution_career_code">

  export type CareerOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CareerCountOrderByAggregateInput
    _max?: CareerMaxOrderByAggregateInput
    _min?: CareerMinOrderByAggregateInput
  }

  export type CareerScalarWhereWithAggregatesInput = {
    AND?: CareerScalarWhereWithAggregatesInput | CareerScalarWhereWithAggregatesInput[]
    OR?: CareerScalarWhereWithAggregatesInput[]
    NOT?: CareerScalarWhereWithAggregatesInput | CareerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Career"> | string
    institutionId?: StringWithAggregatesFilter<"Career"> | string
    name?: StringWithAggregatesFilter<"Career"> | string
    code?: StringNullableWithAggregatesFilter<"Career"> | string | null
    level?: EnumLevelTypeWithAggregatesFilter<"Career"> | $Enums.LevelType
    description?: StringNullableWithAggregatesFilter<"Career"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Career"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Career"> | Date | string
  }

  export type AcademicPeriodWhereInput = {
    AND?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    OR?: AcademicPeriodWhereInput[]
    NOT?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    id?: StringFilter<"AcademicPeriod"> | string
    careerId?: StringFilter<"AcademicPeriod"> | string
    name?: StringFilter<"AcademicPeriod"> | string
    startDate?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endDate?: DateTimeFilter<"AcademicPeriod"> | Date | string
    isActive?: BoolFilter<"AcademicPeriod"> | boolean
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    career?: XOR<CareerScalarRelationFilter, CareerWhereInput>
    courses?: CourseListRelationFilter
    enrollments?: EnrollmentListRelationFilter
  }

  export type AcademicPeriodOrderByWithRelationInput = {
    id?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    career?: CareerOrderByWithRelationInput
    courses?: CourseOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
  }

  export type AcademicPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    OR?: AcademicPeriodWhereInput[]
    NOT?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    careerId?: StringFilter<"AcademicPeriod"> | string
    name?: StringFilter<"AcademicPeriod"> | string
    startDate?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endDate?: DateTimeFilter<"AcademicPeriod"> | Date | string
    isActive?: BoolFilter<"AcademicPeriod"> | boolean
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    career?: XOR<CareerScalarRelationFilter, CareerWhereInput>
    courses?: CourseListRelationFilter
    enrollments?: EnrollmentListRelationFilter
  }, "id">

  export type AcademicPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AcademicPeriodCountOrderByAggregateInput
    _max?: AcademicPeriodMaxOrderByAggregateInput
    _min?: AcademicPeriodMinOrderByAggregateInput
  }

  export type AcademicPeriodScalarWhereWithAggregatesInput = {
    AND?: AcademicPeriodScalarWhereWithAggregatesInput | AcademicPeriodScalarWhereWithAggregatesInput[]
    OR?: AcademicPeriodScalarWhereWithAggregatesInput[]
    NOT?: AcademicPeriodScalarWhereWithAggregatesInput | AcademicPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    careerId?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    name?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    isActive?: BoolWithAggregatesFilter<"AcademicPeriod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    careerId?: StringFilter<"Course"> | string
    academicPeriodId?: StringNullableFilter<"Course"> | string | null
    name?: StringFilter<"Course"> | string
    code?: StringNullableFilter<"Course"> | string | null
    description?: StringNullableFilter<"Course"> | string | null
    credits?: IntNullableFilter<"Course"> | number | null
    durationSemesters?: IntNullableFilter<"Course"> | number | null
    createdById?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    career?: XOR<CareerScalarRelationFilter, CareerWhereInput>
    academicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subjects?: SubjectListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    certificate?: CertificateListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    careerId?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    credits?: SortOrderInput | SortOrder
    durationSemesters?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    career?: CareerOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    certificate?: CertificateOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    careerId?: StringFilter<"Course"> | string
    academicPeriodId?: StringNullableFilter<"Course"> | string | null
    name?: StringFilter<"Course"> | string
    code?: StringNullableFilter<"Course"> | string | null
    description?: StringNullableFilter<"Course"> | string | null
    credits?: IntNullableFilter<"Course"> | number | null
    durationSemesters?: IntNullableFilter<"Course"> | number | null
    createdById?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    career?: XOR<CareerScalarRelationFilter, CareerWhereInput>
    academicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subjects?: SubjectListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    certificate?: CertificateListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    careerId?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    credits?: SortOrderInput | SortOrder
    durationSemesters?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    careerId?: StringWithAggregatesFilter<"Course"> | string
    academicPeriodId?: StringNullableWithAggregatesFilter<"Course"> | string | null
    name?: StringWithAggregatesFilter<"Course"> | string
    code?: StringNullableWithAggregatesFilter<"Course"> | string | null
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    credits?: IntNullableWithAggregatesFilter<"Course"> | number | null
    durationSemesters?: IntNullableWithAggregatesFilter<"Course"> | number | null
    createdById?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    courseId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    semester?: IntNullableFilter<"Subject"> | number | null
    credits?: IntNullableFilter<"Subject"> | number | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    classrooms?: VirtualClassroomListRelationFilter
    studentSubjects?: StudentSubjectListRelationFilter
    disciplinaryRecord?: DisciplinaryRecordListRelationFilter
    certificate?: CertificateListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    credits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    classrooms?: VirtualClassroomOrderByRelationAggregateInput
    studentSubjects?: StudentSubjectOrderByRelationAggregateInput
    disciplinaryRecord?: DisciplinaryRecordOrderByRelationAggregateInput
    certificate?: CertificateOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    courseId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    semester?: IntNullableFilter<"Subject"> | number | null
    credits?: IntNullableFilter<"Subject"> | number | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    classrooms?: VirtualClassroomListRelationFilter
    studentSubjects?: StudentSubjectListRelationFilter
    disciplinaryRecord?: DisciplinaryRecordListRelationFilter
    certificate?: CertificateListRelationFilter
  }, "id">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    credits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    courseId?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    semester?: IntNullableWithAggregatesFilter<"Subject"> | number | null
    credits?: IntNullableWithAggregatesFilter<"Subject"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type VirtualClassroomWhereInput = {
    AND?: VirtualClassroomWhereInput | VirtualClassroomWhereInput[]
    OR?: VirtualClassroomWhereInput[]
    NOT?: VirtualClassroomWhereInput | VirtualClassroomWhereInput[]
    id?: StringFilter<"VirtualClassroom"> | string
    subjectId?: StringFilter<"VirtualClassroom"> | string
    code?: StringNullableFilter<"VirtualClassroom"> | string | null
    title?: StringNullableFilter<"VirtualClassroom"> | string | null
    teacherId?: StringNullableFilter<"VirtualClassroom"> | string | null
    aiEnabled?: BoolFilter<"VirtualClassroom"> | boolean
    aiConfig?: JsonNullableFilter<"VirtualClassroom">
    createdAt?: DateTimeFilter<"VirtualClassroom"> | Date | string
    aiagentId?: StringNullableFilter<"VirtualClassroom"> | string | null
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    aiagent?: XOR<AIAgentNullableScalarRelationFilter, AIAgentWhereInput> | null
    lessonPlans?: LessonPlanListRelationFilter
    attendances?: AttendanceListRelationFilter
    aiUsages?: AIUsageLogListRelationFilter
    studentSubject?: StudentSubjectListRelationFilter
  }

  export type VirtualClassroomOrderByWithRelationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    code?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    aiEnabled?: SortOrder
    aiConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    aiagentId?: SortOrderInput | SortOrder
    subject?: SubjectOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
    aiagent?: AIAgentOrderByWithRelationInput
    lessonPlans?: LessonPlanOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    aiUsages?: AIUsageLogOrderByRelationAggregateInput
    studentSubject?: StudentSubjectOrderByRelationAggregateInput
  }

  export type VirtualClassroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VirtualClassroomWhereInput | VirtualClassroomWhereInput[]
    OR?: VirtualClassroomWhereInput[]
    NOT?: VirtualClassroomWhereInput | VirtualClassroomWhereInput[]
    subjectId?: StringFilter<"VirtualClassroom"> | string
    title?: StringNullableFilter<"VirtualClassroom"> | string | null
    teacherId?: StringNullableFilter<"VirtualClassroom"> | string | null
    aiEnabled?: BoolFilter<"VirtualClassroom"> | boolean
    aiConfig?: JsonNullableFilter<"VirtualClassroom">
    createdAt?: DateTimeFilter<"VirtualClassroom"> | Date | string
    aiagentId?: StringNullableFilter<"VirtualClassroom"> | string | null
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    aiagent?: XOR<AIAgentNullableScalarRelationFilter, AIAgentWhereInput> | null
    lessonPlans?: LessonPlanListRelationFilter
    attendances?: AttendanceListRelationFilter
    aiUsages?: AIUsageLogListRelationFilter
    studentSubject?: StudentSubjectListRelationFilter
  }, "id" | "code">

  export type VirtualClassroomOrderByWithAggregationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    code?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    aiEnabled?: SortOrder
    aiConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    aiagentId?: SortOrderInput | SortOrder
    _count?: VirtualClassroomCountOrderByAggregateInput
    _max?: VirtualClassroomMaxOrderByAggregateInput
    _min?: VirtualClassroomMinOrderByAggregateInput
  }

  export type VirtualClassroomScalarWhereWithAggregatesInput = {
    AND?: VirtualClassroomScalarWhereWithAggregatesInput | VirtualClassroomScalarWhereWithAggregatesInput[]
    OR?: VirtualClassroomScalarWhereWithAggregatesInput[]
    NOT?: VirtualClassroomScalarWhereWithAggregatesInput | VirtualClassroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VirtualClassroom"> | string
    subjectId?: StringWithAggregatesFilter<"VirtualClassroom"> | string
    code?: StringNullableWithAggregatesFilter<"VirtualClassroom"> | string | null
    title?: StringNullableWithAggregatesFilter<"VirtualClassroom"> | string | null
    teacherId?: StringNullableWithAggregatesFilter<"VirtualClassroom"> | string | null
    aiEnabled?: BoolWithAggregatesFilter<"VirtualClassroom"> | boolean
    aiConfig?: JsonNullableWithAggregatesFilter<"VirtualClassroom">
    createdAt?: DateTimeWithAggregatesFilter<"VirtualClassroom"> | Date | string
    aiagentId?: StringNullableWithAggregatesFilter<"VirtualClassroom"> | string | null
  }

  export type LessonPlanWhereInput = {
    AND?: LessonPlanWhereInput | LessonPlanWhereInput[]
    OR?: LessonPlanWhereInput[]
    NOT?: LessonPlanWhereInput | LessonPlanWhereInput[]
    id?: StringFilter<"LessonPlan"> | string
    classroomId?: StringFilter<"LessonPlan"> | string
    date?: DateTimeFilter<"LessonPlan"> | Date | string
    topic?: StringFilter<"LessonPlan"> | string
    aiSuggestions?: JsonNullableFilter<"LessonPlan">
    createdById?: StringNullableFilter<"LessonPlan"> | string | null
    createdAt?: DateTimeFilter<"LessonPlan"> | Date | string
    classroom?: XOR<VirtualClassroomScalarRelationFilter, VirtualClassroomWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LessonPlanOrderByWithRelationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    topic?: SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    classroom?: VirtualClassroomOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type LessonPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonPlanWhereInput | LessonPlanWhereInput[]
    OR?: LessonPlanWhereInput[]
    NOT?: LessonPlanWhereInput | LessonPlanWhereInput[]
    classroomId?: StringFilter<"LessonPlan"> | string
    date?: DateTimeFilter<"LessonPlan"> | Date | string
    topic?: StringFilter<"LessonPlan"> | string
    aiSuggestions?: JsonNullableFilter<"LessonPlan">
    createdById?: StringNullableFilter<"LessonPlan"> | string | null
    createdAt?: DateTimeFilter<"LessonPlan"> | Date | string
    classroom?: XOR<VirtualClassroomScalarRelationFilter, VirtualClassroomWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LessonPlanOrderByWithAggregationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    topic?: SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LessonPlanCountOrderByAggregateInput
    _max?: LessonPlanMaxOrderByAggregateInput
    _min?: LessonPlanMinOrderByAggregateInput
  }

  export type LessonPlanScalarWhereWithAggregatesInput = {
    AND?: LessonPlanScalarWhereWithAggregatesInput | LessonPlanScalarWhereWithAggregatesInput[]
    OR?: LessonPlanScalarWhereWithAggregatesInput[]
    NOT?: LessonPlanScalarWhereWithAggregatesInput | LessonPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonPlan"> | string
    classroomId?: StringWithAggregatesFilter<"LessonPlan"> | string
    date?: DateTimeWithAggregatesFilter<"LessonPlan"> | Date | string
    topic?: StringWithAggregatesFilter<"LessonPlan"> | string
    aiSuggestions?: JsonNullableWithAggregatesFilter<"LessonPlan">
    createdById?: StringNullableWithAggregatesFilter<"LessonPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LessonPlan"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    studentNumber?: StringNullableFilter<"Student"> | string | null
    institutionId?: StringFilter<"Student"> | string
    careerId?: StringNullableFilter<"Student"> | string | null
    enrollmentDate?: DateTimeFilter<"Student"> | Date | string
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    metadata?: JsonNullableFilter<"Student">
    createdAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    career?: XOR<CareerNullableScalarRelationFilter, CareerWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    subjects?: StudentSubjectListRelationFilter
    attendances?: AttendanceListRelationFilter
    tutorAssignments?: TutorStudentListRelationFilter
    payments?: StudentPaymentListRelationFilter
    certificates?: CertificateListRelationFilter
    disciplinaryRecord?: DisciplinaryRecordListRelationFilter
    paymentPlan?: PaymentPlanListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentNumber?: SortOrderInput | SortOrder
    institutionId?: SortOrder
    careerId?: SortOrderInput | SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    career?: CareerOrderByWithRelationInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    subjects?: StudentSubjectOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    tutorAssignments?: TutorStudentOrderByRelationAggregateInput
    payments?: StudentPaymentOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    disciplinaryRecord?: DisciplinaryRecordOrderByRelationAggregateInput
    paymentPlan?: PaymentPlanOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    unique_institution_student_number?: StudentUnique_institution_student_numberCompoundUniqueInput
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    studentNumber?: StringNullableFilter<"Student"> | string | null
    institutionId?: StringFilter<"Student"> | string
    careerId?: StringNullableFilter<"Student"> | string | null
    enrollmentDate?: DateTimeFilter<"Student"> | Date | string
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    metadata?: JsonNullableFilter<"Student">
    createdAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    career?: XOR<CareerNullableScalarRelationFilter, CareerWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    subjects?: StudentSubjectListRelationFilter
    attendances?: AttendanceListRelationFilter
    tutorAssignments?: TutorStudentListRelationFilter
    payments?: StudentPaymentListRelationFilter
    certificates?: CertificateListRelationFilter
    disciplinaryRecord?: DisciplinaryRecordListRelationFilter
    paymentPlan?: PaymentPlanListRelationFilter
  }, "id" | "userId" | "unique_institution_student_number">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentNumber?: SortOrderInput | SortOrder
    institutionId?: SortOrder
    careerId?: SortOrderInput | SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    studentNumber?: StringNullableWithAggregatesFilter<"Student"> | string | null
    institutionId?: StringWithAggregatesFilter<"Student"> | string
    careerId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    enrollmentDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    status?: EnumStudentStatusWithAggregatesFilter<"Student"> | $Enums.StudentStatus
    metadata?: JsonNullableWithAggregatesFilter<"Student">
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    academicPeriodId?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    status?: StringNullableFilter<"Enrollment"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    academicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    status?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    studentId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    academicPeriodId?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    status?: StringNullableFilter<"Enrollment"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    academicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
  }, "id">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    studentId?: StringWithAggregatesFilter<"Enrollment"> | string
    courseId?: StringWithAggregatesFilter<"Enrollment"> | string
    academicPeriodId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    status?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
  }

  export type StudentSubjectWhereInput = {
    AND?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    OR?: StudentSubjectWhereInput[]
    NOT?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    id?: StringFilter<"StudentSubject"> | string
    studentId?: StringFilter<"StudentSubject"> | string
    subjectId?: StringFilter<"StudentSubject"> | string
    classroomId?: StringNullableFilter<"StudentSubject"> | string | null
    semester?: IntNullableFilter<"StudentSubject"> | number | null
    year?: IntNullableFilter<"StudentSubject"> | number | null
    finalGrade?: DecimalNullableFilter<"StudentSubject"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"StudentSubject"> | string | null
    createdAt?: DateTimeFilter<"StudentSubject"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    classroom?: XOR<VirtualClassroomNullableScalarRelationFilter, VirtualClassroomWhereInput> | null
    grades?: GradeListRelationFilter
  }

  export type StudentSubjectOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    finalGrade?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    classroom?: VirtualClassroomOrderByWithRelationInput
    grades?: GradeOrderByRelationAggregateInput
  }

  export type StudentSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_student_subject?: StudentSubjectUnique_student_subjectCompoundUniqueInput
    AND?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    OR?: StudentSubjectWhereInput[]
    NOT?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    studentId?: StringFilter<"StudentSubject"> | string
    subjectId?: StringFilter<"StudentSubject"> | string
    classroomId?: StringNullableFilter<"StudentSubject"> | string | null
    semester?: IntNullableFilter<"StudentSubject"> | number | null
    year?: IntNullableFilter<"StudentSubject"> | number | null
    finalGrade?: DecimalNullableFilter<"StudentSubject"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"StudentSubject"> | string | null
    createdAt?: DateTimeFilter<"StudentSubject"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    classroom?: XOR<VirtualClassroomNullableScalarRelationFilter, VirtualClassroomWhereInput> | null
    grades?: GradeListRelationFilter
  }, "id" | "unique_student_subject">

  export type StudentSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    finalGrade?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StudentSubjectCountOrderByAggregateInput
    _avg?: StudentSubjectAvgOrderByAggregateInput
    _max?: StudentSubjectMaxOrderByAggregateInput
    _min?: StudentSubjectMinOrderByAggregateInput
    _sum?: StudentSubjectSumOrderByAggregateInput
  }

  export type StudentSubjectScalarWhereWithAggregatesInput = {
    AND?: StudentSubjectScalarWhereWithAggregatesInput | StudentSubjectScalarWhereWithAggregatesInput[]
    OR?: StudentSubjectScalarWhereWithAggregatesInput[]
    NOT?: StudentSubjectScalarWhereWithAggregatesInput | StudentSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSubject"> | string
    studentId?: StringWithAggregatesFilter<"StudentSubject"> | string
    subjectId?: StringWithAggregatesFilter<"StudentSubject"> | string
    classroomId?: StringNullableWithAggregatesFilter<"StudentSubject"> | string | null
    semester?: IntNullableWithAggregatesFilter<"StudentSubject"> | number | null
    year?: IntNullableWithAggregatesFilter<"StudentSubject"> | number | null
    finalGrade?: DecimalNullableWithAggregatesFilter<"StudentSubject"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableWithAggregatesFilter<"StudentSubject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentSubject"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    studentSubjectId?: StringFilter<"Grade"> | string
    type?: EnumGradeTypeFilter<"Grade"> | $Enums.GradeType
    weight?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFilter<"Grade"> | Decimal | DecimalJsLike | number | string
    comments?: StringNullableFilter<"Grade"> | string | null
    createdById?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    studentSubject?: XOR<StudentSubjectScalarRelationFilter, StudentSubjectWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    studentSubjectId?: SortOrder
    type?: SortOrder
    weight?: SortOrderInput | SortOrder
    value?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    studentSubject?: StudentSubjectOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    studentSubjectId?: StringFilter<"Grade"> | string
    type?: EnumGradeTypeFilter<"Grade"> | $Enums.GradeType
    weight?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFilter<"Grade"> | Decimal | DecimalJsLike | number | string
    comments?: StringNullableFilter<"Grade"> | string | null
    createdById?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    studentSubject?: XOR<StudentSubjectScalarRelationFilter, StudentSubjectWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    studentSubjectId?: SortOrder
    type?: SortOrder
    weight?: SortOrderInput | SortOrder
    value?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    studentSubjectId?: StringWithAggregatesFilter<"Grade"> | string
    type?: EnumGradeTypeWithAggregatesFilter<"Grade"> | $Enums.GradeType
    weight?: DecimalNullableWithAggregatesFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    value?: DecimalWithAggregatesFilter<"Grade"> | Decimal | DecimalJsLike | number | string
    comments?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    classroomId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    notedById?: StringNullableFilter<"Attendance"> | string | null
    note?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    classroom?: XOR<VirtualClassroomScalarRelationFilter, VirtualClassroomWhereInput>
    notedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notedById?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    classroom?: VirtualClassroomOrderByWithRelationInput
    notedBy?: UserOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    studentId?: StringFilter<"Attendance"> | string
    classroomId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    notedById?: StringNullableFilter<"Attendance"> | string | null
    note?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    classroom?: XOR<VirtualClassroomScalarRelationFilter, VirtualClassroomWhereInput>
    notedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notedById?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    studentId?: StringWithAggregatesFilter<"Attendance"> | string
    classroomId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    notedById?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    note?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type DisciplinaryRecordWhereInput = {
    AND?: DisciplinaryRecordWhereInput | DisciplinaryRecordWhereInput[]
    OR?: DisciplinaryRecordWhereInput[]
    NOT?: DisciplinaryRecordWhereInput | DisciplinaryRecordWhereInput[]
    id?: StringFilter<"DisciplinaryRecord"> | string
    studentId?: StringFilter<"DisciplinaryRecord"> | string
    subjectId?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    recordedById?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    type?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    description?: StringFilter<"DisciplinaryRecord"> | string
    actionTaken?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    date?: DateTimeFilter<"DisciplinaryRecord"> | Date | string
    seenByTutor?: BoolFilter<"DisciplinaryRecord"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DisciplinaryRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrder
    actionTaken?: SortOrderInput | SortOrder
    date?: SortOrder
    seenByTutor?: SortOrder
    student?: StudentOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
  }

  export type DisciplinaryRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisciplinaryRecordWhereInput | DisciplinaryRecordWhereInput[]
    OR?: DisciplinaryRecordWhereInput[]
    NOT?: DisciplinaryRecordWhereInput | DisciplinaryRecordWhereInput[]
    studentId?: StringFilter<"DisciplinaryRecord"> | string
    subjectId?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    recordedById?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    type?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    description?: StringFilter<"DisciplinaryRecord"> | string
    actionTaken?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    date?: DateTimeFilter<"DisciplinaryRecord"> | Date | string
    seenByTutor?: BoolFilter<"DisciplinaryRecord"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DisciplinaryRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    recordedById?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrder
    actionTaken?: SortOrderInput | SortOrder
    date?: SortOrder
    seenByTutor?: SortOrder
    _count?: DisciplinaryRecordCountOrderByAggregateInput
    _max?: DisciplinaryRecordMaxOrderByAggregateInput
    _min?: DisciplinaryRecordMinOrderByAggregateInput
  }

  export type DisciplinaryRecordScalarWhereWithAggregatesInput = {
    AND?: DisciplinaryRecordScalarWhereWithAggregatesInput | DisciplinaryRecordScalarWhereWithAggregatesInput[]
    OR?: DisciplinaryRecordScalarWhereWithAggregatesInput[]
    NOT?: DisciplinaryRecordScalarWhereWithAggregatesInput | DisciplinaryRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisciplinaryRecord"> | string
    studentId?: StringWithAggregatesFilter<"DisciplinaryRecord"> | string
    subjectId?: StringNullableWithAggregatesFilter<"DisciplinaryRecord"> | string | null
    recordedById?: StringNullableWithAggregatesFilter<"DisciplinaryRecord"> | string | null
    type?: StringNullableWithAggregatesFilter<"DisciplinaryRecord"> | string | null
    description?: StringWithAggregatesFilter<"DisciplinaryRecord"> | string
    actionTaken?: StringNullableWithAggregatesFilter<"DisciplinaryRecord"> | string | null
    date?: DateTimeWithAggregatesFilter<"DisciplinaryRecord"> | Date | string
    seenByTutor?: BoolWithAggregatesFilter<"DisciplinaryRecord"> | boolean
  }

  export type TutorProfileWhereInput = {
    AND?: TutorProfileWhereInput | TutorProfileWhereInput[]
    OR?: TutorProfileWhereInput[]
    NOT?: TutorProfileWhereInput | TutorProfileWhereInput[]
    id?: StringFilter<"TutorProfile"> | string
    userId?: StringFilter<"TutorProfile"> | string
    institutionId?: StringFilter<"TutorProfile"> | string
    relationship?: StringNullableFilter<"TutorProfile"> | string | null
    phone?: StringNullableFilter<"TutorProfile"> | string | null
    address?: StringNullableFilter<"TutorProfile"> | string | null
    metadata?: JsonNullableFilter<"TutorProfile">
    createdAt?: DateTimeFilter<"TutorProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    tutorAssignments?: TutorStudentListRelationFilter
  }

  export type TutorProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    relationship?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    tutorAssignments?: TutorStudentOrderByRelationAggregateInput
  }

  export type TutorProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TutorProfileWhereInput | TutorProfileWhereInput[]
    OR?: TutorProfileWhereInput[]
    NOT?: TutorProfileWhereInput | TutorProfileWhereInput[]
    institutionId?: StringFilter<"TutorProfile"> | string
    relationship?: StringNullableFilter<"TutorProfile"> | string | null
    phone?: StringNullableFilter<"TutorProfile"> | string | null
    address?: StringNullableFilter<"TutorProfile"> | string | null
    metadata?: JsonNullableFilter<"TutorProfile">
    createdAt?: DateTimeFilter<"TutorProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    tutorAssignments?: TutorStudentListRelationFilter
  }, "id" | "userId">

  export type TutorProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    relationship?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TutorProfileCountOrderByAggregateInput
    _max?: TutorProfileMaxOrderByAggregateInput
    _min?: TutorProfileMinOrderByAggregateInput
  }

  export type TutorProfileScalarWhereWithAggregatesInput = {
    AND?: TutorProfileScalarWhereWithAggregatesInput | TutorProfileScalarWhereWithAggregatesInput[]
    OR?: TutorProfileScalarWhereWithAggregatesInput[]
    NOT?: TutorProfileScalarWhereWithAggregatesInput | TutorProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutorProfile"> | string
    userId?: StringWithAggregatesFilter<"TutorProfile"> | string
    institutionId?: StringWithAggregatesFilter<"TutorProfile"> | string
    relationship?: StringNullableWithAggregatesFilter<"TutorProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"TutorProfile"> | string | null
    address?: StringNullableWithAggregatesFilter<"TutorProfile"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"TutorProfile">
    createdAt?: DateTimeWithAggregatesFilter<"TutorProfile"> | Date | string
  }

  export type TutorStudentWhereInput = {
    AND?: TutorStudentWhereInput | TutorStudentWhereInput[]
    OR?: TutorStudentWhereInput[]
    NOT?: TutorStudentWhereInput | TutorStudentWhereInput[]
    id?: StringFilter<"TutorStudent"> | string
    tutorId?: StringFilter<"TutorStudent"> | string
    studentId?: StringFilter<"TutorStudent"> | string
    isPrimary?: BoolFilter<"TutorStudent"> | boolean
    assignedAt?: DateTimeFilter<"TutorStudent"> | Date | string
    tutor?: XOR<TutorProfileScalarRelationFilter, TutorProfileWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type TutorStudentOrderByWithRelationInput = {
    id?: SortOrder
    tutorId?: SortOrder
    studentId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    tutor?: TutorProfileOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type TutorStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tutorId_studentId?: TutorStudentTutorIdStudentIdCompoundUniqueInput
    AND?: TutorStudentWhereInput | TutorStudentWhereInput[]
    OR?: TutorStudentWhereInput[]
    NOT?: TutorStudentWhereInput | TutorStudentWhereInput[]
    tutorId?: StringFilter<"TutorStudent"> | string
    studentId?: StringFilter<"TutorStudent"> | string
    isPrimary?: BoolFilter<"TutorStudent"> | boolean
    assignedAt?: DateTimeFilter<"TutorStudent"> | Date | string
    tutor?: XOR<TutorProfileScalarRelationFilter, TutorProfileWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "tutorId_studentId">

  export type TutorStudentOrderByWithAggregationInput = {
    id?: SortOrder
    tutorId?: SortOrder
    studentId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    _count?: TutorStudentCountOrderByAggregateInput
    _max?: TutorStudentMaxOrderByAggregateInput
    _min?: TutorStudentMinOrderByAggregateInput
  }

  export type TutorStudentScalarWhereWithAggregatesInput = {
    AND?: TutorStudentScalarWhereWithAggregatesInput | TutorStudentScalarWhereWithAggregatesInput[]
    OR?: TutorStudentScalarWhereWithAggregatesInput[]
    NOT?: TutorStudentScalarWhereWithAggregatesInput | TutorStudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutorStudent"> | string
    tutorId?: StringWithAggregatesFilter<"TutorStudent"> | string
    studentId?: StringWithAggregatesFilter<"TutorStudent"> | string
    isPrimary?: BoolWithAggregatesFilter<"TutorStudent"> | boolean
    assignedAt?: DateTimeWithAggregatesFilter<"TutorStudent"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    studentId?: StringFilter<"Certificate"> | string
    courseId?: StringNullableFilter<"Certificate"> | string | null
    subjectId?: StringNullableFilter<"Certificate"> | string | null
    type?: EnumCertificateTypeFilter<"Certificate"> | $Enums.CertificateType
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    fileUrl?: StringNullableFilter<"Certificate"> | string | null
    issuedById?: StringNullableFilter<"Certificate"> | string | null
    metadata?: JsonNullableFilter<"Certificate">
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    issuedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    type?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    issuedById?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    issuedBy?: UserOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    studentId?: StringFilter<"Certificate"> | string
    courseId?: StringNullableFilter<"Certificate"> | string | null
    subjectId?: StringNullableFilter<"Certificate"> | string | null
    type?: EnumCertificateTypeFilter<"Certificate"> | $Enums.CertificateType
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    fileUrl?: StringNullableFilter<"Certificate"> | string | null
    issuedById?: StringNullableFilter<"Certificate"> | string | null
    metadata?: JsonNullableFilter<"Certificate">
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    issuedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    type?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    issuedById?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    studentId?: StringWithAggregatesFilter<"Certificate"> | string
    courseId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    subjectId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    type?: EnumCertificateTypeWithAggregatesFilter<"Certificate"> | $Enums.CertificateType
    issuedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    fileUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    issuedById?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Certificate">
  }

  export type FeeScheduleWhereInput = {
    AND?: FeeScheduleWhereInput | FeeScheduleWhereInput[]
    OR?: FeeScheduleWhereInput[]
    NOT?: FeeScheduleWhereInput | FeeScheduleWhereInput[]
    id?: StringFilter<"FeeSchedule"> | string
    institutionId?: StringFilter<"FeeSchedule"> | string
    careerId?: StringNullableFilter<"FeeSchedule"> | string | null
    name?: StringFilter<"FeeSchedule"> | string
    totalAmount?: DecimalFilter<"FeeSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"FeeSchedule"> | string
    installments?: IntFilter<"FeeSchedule"> | number
    frequency?: StringNullableFilter<"FeeSchedule"> | string | null
    metadata?: JsonNullableFilter<"FeeSchedule">
    createdAt?: DateTimeFilter<"FeeSchedule"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    career?: XOR<CareerNullableScalarRelationFilter, CareerWhereInput> | null
    installmentsList?: FeeInstallmentListRelationFilter
    paymentPlan?: PaymentPlanListRelationFilter
  }

  export type FeeScheduleOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrderInput | SortOrder
    name?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    frequency?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    career?: CareerOrderByWithRelationInput
    installmentsList?: FeeInstallmentOrderByRelationAggregateInput
    paymentPlan?: PaymentPlanOrderByRelationAggregateInput
  }

  export type FeeScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeScheduleWhereInput | FeeScheduleWhereInput[]
    OR?: FeeScheduleWhereInput[]
    NOT?: FeeScheduleWhereInput | FeeScheduleWhereInput[]
    institutionId?: StringFilter<"FeeSchedule"> | string
    careerId?: StringNullableFilter<"FeeSchedule"> | string | null
    name?: StringFilter<"FeeSchedule"> | string
    totalAmount?: DecimalFilter<"FeeSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"FeeSchedule"> | string
    installments?: IntFilter<"FeeSchedule"> | number
    frequency?: StringNullableFilter<"FeeSchedule"> | string | null
    metadata?: JsonNullableFilter<"FeeSchedule">
    createdAt?: DateTimeFilter<"FeeSchedule"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    career?: XOR<CareerNullableScalarRelationFilter, CareerWhereInput> | null
    installmentsList?: FeeInstallmentListRelationFilter
    paymentPlan?: PaymentPlanListRelationFilter
  }, "id">

  export type FeeScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrderInput | SortOrder
    name?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    frequency?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeeScheduleCountOrderByAggregateInput
    _avg?: FeeScheduleAvgOrderByAggregateInput
    _max?: FeeScheduleMaxOrderByAggregateInput
    _min?: FeeScheduleMinOrderByAggregateInput
    _sum?: FeeScheduleSumOrderByAggregateInput
  }

  export type FeeScheduleScalarWhereWithAggregatesInput = {
    AND?: FeeScheduleScalarWhereWithAggregatesInput | FeeScheduleScalarWhereWithAggregatesInput[]
    OR?: FeeScheduleScalarWhereWithAggregatesInput[]
    NOT?: FeeScheduleScalarWhereWithAggregatesInput | FeeScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeSchedule"> | string
    institutionId?: StringWithAggregatesFilter<"FeeSchedule"> | string
    careerId?: StringNullableWithAggregatesFilter<"FeeSchedule"> | string | null
    name?: StringWithAggregatesFilter<"FeeSchedule"> | string
    totalAmount?: DecimalWithAggregatesFilter<"FeeSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"FeeSchedule"> | string
    installments?: IntWithAggregatesFilter<"FeeSchedule"> | number
    frequency?: StringNullableWithAggregatesFilter<"FeeSchedule"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"FeeSchedule">
    createdAt?: DateTimeWithAggregatesFilter<"FeeSchedule"> | Date | string
  }

  export type FeeInstallmentWhereInput = {
    AND?: FeeInstallmentWhereInput | FeeInstallmentWhereInput[]
    OR?: FeeInstallmentWhereInput[]
    NOT?: FeeInstallmentWhereInput | FeeInstallmentWhereInput[]
    id?: StringFilter<"FeeInstallment"> | string
    feeScheduleId?: StringFilter<"FeeInstallment"> | string
    sequence?: IntFilter<"FeeInstallment"> | number
    dueDate?: DateTimeFilter<"FeeInstallment"> | Date | string
    amount?: DecimalFilter<"FeeInstallment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"FeeInstallment"> | Date | string
    feeSchedule?: XOR<FeeScheduleScalarRelationFilter, FeeScheduleWhereInput>
    studentPayments?: StudentPaymentListRelationFilter
  }

  export type FeeInstallmentOrderByWithRelationInput = {
    id?: SortOrder
    feeScheduleId?: SortOrder
    sequence?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    feeSchedule?: FeeScheduleOrderByWithRelationInput
    studentPayments?: StudentPaymentOrderByRelationAggregateInput
  }

  export type FeeInstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeInstallmentWhereInput | FeeInstallmentWhereInput[]
    OR?: FeeInstallmentWhereInput[]
    NOT?: FeeInstallmentWhereInput | FeeInstallmentWhereInput[]
    feeScheduleId?: StringFilter<"FeeInstallment"> | string
    sequence?: IntFilter<"FeeInstallment"> | number
    dueDate?: DateTimeFilter<"FeeInstallment"> | Date | string
    amount?: DecimalFilter<"FeeInstallment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"FeeInstallment"> | Date | string
    feeSchedule?: XOR<FeeScheduleScalarRelationFilter, FeeScheduleWhereInput>
    studentPayments?: StudentPaymentListRelationFilter
  }, "id">

  export type FeeInstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    feeScheduleId?: SortOrder
    sequence?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    _count?: FeeInstallmentCountOrderByAggregateInput
    _avg?: FeeInstallmentAvgOrderByAggregateInput
    _max?: FeeInstallmentMaxOrderByAggregateInput
    _min?: FeeInstallmentMinOrderByAggregateInput
    _sum?: FeeInstallmentSumOrderByAggregateInput
  }

  export type FeeInstallmentScalarWhereWithAggregatesInput = {
    AND?: FeeInstallmentScalarWhereWithAggregatesInput | FeeInstallmentScalarWhereWithAggregatesInput[]
    OR?: FeeInstallmentScalarWhereWithAggregatesInput[]
    NOT?: FeeInstallmentScalarWhereWithAggregatesInput | FeeInstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeInstallment"> | string
    feeScheduleId?: StringWithAggregatesFilter<"FeeInstallment"> | string
    sequence?: IntWithAggregatesFilter<"FeeInstallment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"FeeInstallment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"FeeInstallment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"FeeInstallment"> | Date | string
  }

  export type StudentPaymentWhereInput = {
    AND?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    OR?: StudentPaymentWhereInput[]
    NOT?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    id?: StringFilter<"StudentPayment"> | string
    studentId?: StringFilter<"StudentPayment"> | string
    institutionId?: StringFilter<"StudentPayment"> | string
    feeInstallmentId?: StringNullableFilter<"StudentPayment"> | string | null
    amount?: DecimalFilter<"StudentPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"StudentPayment"> | string
    method?: EnumPaymentMethodFilter<"StudentPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"StudentPayment"> | $Enums.PaymentStatus
    reference?: StringNullableFilter<"StudentPayment"> | string | null
    gatewayData?: JsonNullableFilter<"StudentPayment">
    paidAt?: DateTimeNullableFilter<"StudentPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentPayment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    feeInstallment?: XOR<FeeInstallmentNullableScalarRelationFilter, FeeInstallmentWhereInput> | null
  }

  export type StudentPaymentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    feeInstallmentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    gatewayData?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    feeInstallment?: FeeInstallmentOrderByWithRelationInput
  }

  export type StudentPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    OR?: StudentPaymentWhereInput[]
    NOT?: StudentPaymentWhereInput | StudentPaymentWhereInput[]
    studentId?: StringFilter<"StudentPayment"> | string
    institutionId?: StringFilter<"StudentPayment"> | string
    feeInstallmentId?: StringNullableFilter<"StudentPayment"> | string | null
    amount?: DecimalFilter<"StudentPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"StudentPayment"> | string
    method?: EnumPaymentMethodFilter<"StudentPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"StudentPayment"> | $Enums.PaymentStatus
    gatewayData?: JsonNullableFilter<"StudentPayment">
    paidAt?: DateTimeNullableFilter<"StudentPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentPayment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    feeInstallment?: XOR<FeeInstallmentNullableScalarRelationFilter, FeeInstallmentWhereInput> | null
  }, "id" | "reference">

  export type StudentPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    feeInstallmentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    gatewayData?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StudentPaymentCountOrderByAggregateInput
    _avg?: StudentPaymentAvgOrderByAggregateInput
    _max?: StudentPaymentMaxOrderByAggregateInput
    _min?: StudentPaymentMinOrderByAggregateInput
    _sum?: StudentPaymentSumOrderByAggregateInput
  }

  export type StudentPaymentScalarWhereWithAggregatesInput = {
    AND?: StudentPaymentScalarWhereWithAggregatesInput | StudentPaymentScalarWhereWithAggregatesInput[]
    OR?: StudentPaymentScalarWhereWithAggregatesInput[]
    NOT?: StudentPaymentScalarWhereWithAggregatesInput | StudentPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentPayment"> | string
    studentId?: StringWithAggregatesFilter<"StudentPayment"> | string
    institutionId?: StringWithAggregatesFilter<"StudentPayment"> | string
    feeInstallmentId?: StringNullableWithAggregatesFilter<"StudentPayment"> | string | null
    amount?: DecimalWithAggregatesFilter<"StudentPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"StudentPayment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"StudentPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"StudentPayment"> | $Enums.PaymentStatus
    reference?: StringNullableWithAggregatesFilter<"StudentPayment"> | string | null
    gatewayData?: JsonNullableWithAggregatesFilter<"StudentPayment">
    paidAt?: DateTimeNullableWithAggregatesFilter<"StudentPayment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentPayment"> | Date | string
  }

  export type PaymentPlanWhereInput = {
    AND?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    OR?: PaymentPlanWhereInput[]
    NOT?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    id?: StringFilter<"PaymentPlan"> | string
    studentId?: StringFilter<"PaymentPlan"> | string
    feeScheduleId?: StringFilter<"PaymentPlan"> | string
    totalAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PaymentPlan"> | string
    createdAt?: DateTimeFilter<"PaymentPlan"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    feeSchedule?: XOR<FeeScheduleScalarRelationFilter, FeeScheduleWhereInput>
  }

  export type PaymentPlanOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    feeScheduleId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    feeSchedule?: FeeScheduleOrderByWithRelationInput
  }

  export type PaymentPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    OR?: PaymentPlanWhereInput[]
    NOT?: PaymentPlanWhereInput | PaymentPlanWhereInput[]
    studentId?: StringFilter<"PaymentPlan"> | string
    feeScheduleId?: StringFilter<"PaymentPlan"> | string
    totalAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PaymentPlan"> | string
    createdAt?: DateTimeFilter<"PaymentPlan"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    feeSchedule?: XOR<FeeScheduleScalarRelationFilter, FeeScheduleWhereInput>
  }, "id">

  export type PaymentPlanOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    feeScheduleId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentPlanCountOrderByAggregateInput
    _avg?: PaymentPlanAvgOrderByAggregateInput
    _max?: PaymentPlanMaxOrderByAggregateInput
    _min?: PaymentPlanMinOrderByAggregateInput
    _sum?: PaymentPlanSumOrderByAggregateInput
  }

  export type PaymentPlanScalarWhereWithAggregatesInput = {
    AND?: PaymentPlanScalarWhereWithAggregatesInput | PaymentPlanScalarWhereWithAggregatesInput[]
    OR?: PaymentPlanScalarWhereWithAggregatesInput[]
    NOT?: PaymentPlanScalarWhereWithAggregatesInput | PaymentPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentPlan"> | string
    studentId?: StringWithAggregatesFilter<"PaymentPlan"> | string
    feeScheduleId?: StringWithAggregatesFilter<"PaymentPlan"> | string
    totalAmount?: DecimalWithAggregatesFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalWithAggregatesFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"PaymentPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentPlan"> | Date | string
  }

  export type AIAgentWhereInput = {
    AND?: AIAgentWhereInput | AIAgentWhereInput[]
    OR?: AIAgentWhereInput[]
    NOT?: AIAgentWhereInput | AIAgentWhereInput[]
    id?: StringFilter<"AIAgent"> | string
    institutionId?: StringFilter<"AIAgent"> | string
    type?: StringFilter<"AIAgent"> | string
    name?: StringFilter<"AIAgent"> | string
    personality?: StringFilter<"AIAgent"> | string
    specialization?: StringNullableFilter<"AIAgent"> | string | null
    maxTokensPerCall?: IntFilter<"AIAgent"> | number
    temperature?: FloatFilter<"AIAgent"> | number
    systemPrompt?: StringFilter<"AIAgent"> | string
    isActive?: BoolFilter<"AIAgent"> | boolean
    createdAt?: DateTimeFilter<"AIAgent"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    conversations?: AIConversationListRelationFilter
    classrooms?: VirtualClassroomListRelationFilter
  }

  export type AIAgentOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    specialization?: SortOrderInput | SortOrder
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    conversations?: AIConversationOrderByRelationAggregateInput
    classrooms?: VirtualClassroomOrderByRelationAggregateInput
  }

  export type AIAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIAgentWhereInput | AIAgentWhereInput[]
    OR?: AIAgentWhereInput[]
    NOT?: AIAgentWhereInput | AIAgentWhereInput[]
    institutionId?: StringFilter<"AIAgent"> | string
    type?: StringFilter<"AIAgent"> | string
    name?: StringFilter<"AIAgent"> | string
    personality?: StringFilter<"AIAgent"> | string
    specialization?: StringNullableFilter<"AIAgent"> | string | null
    maxTokensPerCall?: IntFilter<"AIAgent"> | number
    temperature?: FloatFilter<"AIAgent"> | number
    systemPrompt?: StringFilter<"AIAgent"> | string
    isActive?: BoolFilter<"AIAgent"> | boolean
    createdAt?: DateTimeFilter<"AIAgent"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    conversations?: AIConversationListRelationFilter
    classrooms?: VirtualClassroomListRelationFilter
  }, "id">

  export type AIAgentOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    specialization?: SortOrderInput | SortOrder
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AIAgentCountOrderByAggregateInput
    _avg?: AIAgentAvgOrderByAggregateInput
    _max?: AIAgentMaxOrderByAggregateInput
    _min?: AIAgentMinOrderByAggregateInput
    _sum?: AIAgentSumOrderByAggregateInput
  }

  export type AIAgentScalarWhereWithAggregatesInput = {
    AND?: AIAgentScalarWhereWithAggregatesInput | AIAgentScalarWhereWithAggregatesInput[]
    OR?: AIAgentScalarWhereWithAggregatesInput[]
    NOT?: AIAgentScalarWhereWithAggregatesInput | AIAgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIAgent"> | string
    institutionId?: StringWithAggregatesFilter<"AIAgent"> | string
    type?: StringWithAggregatesFilter<"AIAgent"> | string
    name?: StringWithAggregatesFilter<"AIAgent"> | string
    personality?: StringWithAggregatesFilter<"AIAgent"> | string
    specialization?: StringNullableWithAggregatesFilter<"AIAgent"> | string | null
    maxTokensPerCall?: IntWithAggregatesFilter<"AIAgent"> | number
    temperature?: FloatWithAggregatesFilter<"AIAgent"> | number
    systemPrompt?: StringWithAggregatesFilter<"AIAgent"> | string
    isActive?: BoolWithAggregatesFilter<"AIAgent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIAgent"> | Date | string
  }

  export type AIConversationWhereInput = {
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    userId?: StringFilter<"AIConversation"> | string
    agentId?: StringFilter<"AIConversation"> | string
    sessionId?: StringFilter<"AIConversation"> | string
    startedAt?: DateTimeFilter<"AIConversation"> | Date | string
    endedAt?: DateTimeNullableFilter<"AIConversation"> | Date | string | null
    totalTokens?: IntFilter<"AIConversation"> | number
    totalCost?: DecimalNullableFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agent?: XOR<AIAgentScalarRelationFilter, AIAgentWhereInput>
    messages?: AIMessageListRelationFilter
  }

  export type AIConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    agent?: AIAgentOrderByWithRelationInput
    messages?: AIMessageOrderByRelationAggregateInput
  }

  export type AIConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIConversationWhereInput | AIConversationWhereInput[]
    OR?: AIConversationWhereInput[]
    NOT?: AIConversationWhereInput | AIConversationWhereInput[]
    userId?: StringFilter<"AIConversation"> | string
    agentId?: StringFilter<"AIConversation"> | string
    sessionId?: StringFilter<"AIConversation"> | string
    startedAt?: DateTimeFilter<"AIConversation"> | Date | string
    endedAt?: DateTimeNullableFilter<"AIConversation"> | Date | string | null
    totalTokens?: IntFilter<"AIConversation"> | number
    totalCost?: DecimalNullableFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agent?: XOR<AIAgentScalarRelationFilter, AIAgentWhereInput>
    messages?: AIMessageListRelationFilter
  }, "id">

  export type AIConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrderInput | SortOrder
    _count?: AIConversationCountOrderByAggregateInput
    _avg?: AIConversationAvgOrderByAggregateInput
    _max?: AIConversationMaxOrderByAggregateInput
    _min?: AIConversationMinOrderByAggregateInput
    _sum?: AIConversationSumOrderByAggregateInput
  }

  export type AIConversationScalarWhereWithAggregatesInput = {
    AND?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    OR?: AIConversationScalarWhereWithAggregatesInput[]
    NOT?: AIConversationScalarWhereWithAggregatesInput | AIConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIConversation"> | string
    userId?: StringWithAggregatesFilter<"AIConversation"> | string
    agentId?: StringWithAggregatesFilter<"AIConversation"> | string
    sessionId?: StringWithAggregatesFilter<"AIConversation"> | string
    startedAt?: DateTimeWithAggregatesFilter<"AIConversation"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"AIConversation"> | Date | string | null
    totalTokens?: IntWithAggregatesFilter<"AIConversation"> | number
    totalCost?: DecimalNullableWithAggregatesFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string | null
  }

  export type AIMessageWhereInput = {
    AND?: AIMessageWhereInput | AIMessageWhereInput[]
    OR?: AIMessageWhereInput[]
    NOT?: AIMessageWhereInput | AIMessageWhereInput[]
    id?: StringFilter<"AIMessage"> | string
    conversationId?: StringFilter<"AIMessage"> | string
    role?: StringFilter<"AIMessage"> | string
    content?: StringFilter<"AIMessage"> | string
    tokens?: IntNullableFilter<"AIMessage"> | number | null
    createdAt?: DateTimeFilter<"AIMessage"> | Date | string
    conversation?: XOR<AIConversationScalarRelationFilter, AIConversationWhereInput>
  }

  export type AIMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokens?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: AIConversationOrderByWithRelationInput
  }

  export type AIMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIMessageWhereInput | AIMessageWhereInput[]
    OR?: AIMessageWhereInput[]
    NOT?: AIMessageWhereInput | AIMessageWhereInput[]
    conversationId?: StringFilter<"AIMessage"> | string
    role?: StringFilter<"AIMessage"> | string
    content?: StringFilter<"AIMessage"> | string
    tokens?: IntNullableFilter<"AIMessage"> | number | null
    createdAt?: DateTimeFilter<"AIMessage"> | Date | string
    conversation?: XOR<AIConversationScalarRelationFilter, AIConversationWhereInput>
  }, "id">

  export type AIMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokens?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIMessageCountOrderByAggregateInput
    _avg?: AIMessageAvgOrderByAggregateInput
    _max?: AIMessageMaxOrderByAggregateInput
    _min?: AIMessageMinOrderByAggregateInput
    _sum?: AIMessageSumOrderByAggregateInput
  }

  export type AIMessageScalarWhereWithAggregatesInput = {
    AND?: AIMessageScalarWhereWithAggregatesInput | AIMessageScalarWhereWithAggregatesInput[]
    OR?: AIMessageScalarWhereWithAggregatesInput[]
    NOT?: AIMessageScalarWhereWithAggregatesInput | AIMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIMessage"> | string
    conversationId?: StringWithAggregatesFilter<"AIMessage"> | string
    role?: StringWithAggregatesFilter<"AIMessage"> | string
    content?: StringWithAggregatesFilter<"AIMessage"> | string
    tokens?: IntNullableWithAggregatesFilter<"AIMessage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AIMessage"> | Date | string
  }

  export type AIUsageLogWhereInput = {
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    id?: StringFilter<"AIUsageLog"> | string
    userId?: StringFilter<"AIUsageLog"> | string
    institutionId?: StringFilter<"AIUsageLog"> | string
    classroomId?: StringNullableFilter<"AIUsageLog"> | string | null
    promptSummary?: StringNullableFilter<"AIUsageLog"> | string | null
    responseSummary?: StringNullableFilter<"AIUsageLog"> | string | null
    tokensUsed?: IntNullableFilter<"AIUsageLog"> | number | null
    cost?: DecimalNullableFilter<"AIUsageLog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    classroom?: XOR<VirtualClassroomNullableScalarRelationFilter, VirtualClassroomWhereInput> | null
  }

  export type AIUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    promptSummary?: SortOrderInput | SortOrder
    responseSummary?: SortOrderInput | SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    classroom?: VirtualClassroomOrderByWithRelationInput
  }

  export type AIUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    userId?: StringFilter<"AIUsageLog"> | string
    institutionId?: StringFilter<"AIUsageLog"> | string
    classroomId?: StringNullableFilter<"AIUsageLog"> | string | null
    promptSummary?: StringNullableFilter<"AIUsageLog"> | string | null
    responseSummary?: StringNullableFilter<"AIUsageLog"> | string | null
    tokensUsed?: IntNullableFilter<"AIUsageLog"> | number | null
    cost?: DecimalNullableFilter<"AIUsageLog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    classroom?: XOR<VirtualClassroomNullableScalarRelationFilter, VirtualClassroomWhereInput> | null
  }, "id">

  export type AIUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    promptSummary?: SortOrderInput | SortOrder
    responseSummary?: SortOrderInput | SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIUsageLogCountOrderByAggregateInput
    _avg?: AIUsageLogAvgOrderByAggregateInput
    _max?: AIUsageLogMaxOrderByAggregateInput
    _min?: AIUsageLogMinOrderByAggregateInput
    _sum?: AIUsageLogSumOrderByAggregateInput
  }

  export type AIUsageLogScalarWhereWithAggregatesInput = {
    AND?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    OR?: AIUsageLogScalarWhereWithAggregatesInput[]
    NOT?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsageLog"> | string
    userId?: StringWithAggregatesFilter<"AIUsageLog"> | string
    institutionId?: StringWithAggregatesFilter<"AIUsageLog"> | string
    classroomId?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    promptSummary?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    responseSummary?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    tokensUsed?: IntNullableWithAggregatesFilter<"AIUsageLog"> | number | null
    cost?: DecimalNullableWithAggregatesFilter<"AIUsageLog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIUsageLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    meta?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pushSent?: BoolFilter<"Notification"> | boolean
    emailSent?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    meta?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    pushSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    meta?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pushSent?: BoolFilter<"Notification"> | boolean
    emailSent?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    meta?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    pushSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    meta?: JsonNullableWithAggregatesFilter<"Notification">
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    pushSent?: BoolWithAggregatesFilter<"Notification"> | boolean
    emailSent?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    preferences?: JsonNullableFilter<"NotificationPreference">
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    preferences?: JsonNullableFilter<"NotificationPreference">
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    preferences?: JsonNullableWithAggregatesFilter<"NotificationPreference">
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    subject?: StringNullableFilter<"Message"> | string | null
    body?: StringFilter<"Message"> | string
    attachments?: JsonNullableFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrder
    attachments?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    subject?: StringNullableFilter<"Message"> | string | null
    body?: StringFilter<"Message"> | string
    attachments?: JsonNullableFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrder
    attachments?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientId?: StringWithAggregatesFilter<"Message"> | string
    subject?: StringNullableWithAggregatesFilter<"Message"> | string | null
    body?: StringWithAggregatesFilter<"Message"> | string
    attachments?: JsonNullableWithAggregatesFilter<"Message">
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    institutionId?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    body?: StringFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    startsAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    createdById?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    targetRoles?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    institutionId?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    body?: StringFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    startsAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    createdById?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    targetRoles?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    institutionId?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    body?: StringWithAggregatesFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    startsAt?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type DataBackupWhereInput = {
    AND?: DataBackupWhereInput | DataBackupWhereInput[]
    OR?: DataBackupWhereInput[]
    NOT?: DataBackupWhereInput | DataBackupWhereInput[]
    id?: StringFilter<"DataBackup"> | string
    institutionId?: StringFilter<"DataBackup"> | string
    name?: StringFilter<"DataBackup"> | string
    description?: StringNullableFilter<"DataBackup"> | string | null
    storageUrl?: StringFilter<"DataBackup"> | string
    sizeBytes?: IntNullableFilter<"DataBackup"> | number | null
    createdById?: StringNullableFilter<"DataBackup"> | string | null
    createdAt?: DateTimeFilter<"DataBackup"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DataBackupOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    storageUrl?: SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type DataBackupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataBackupWhereInput | DataBackupWhereInput[]
    OR?: DataBackupWhereInput[]
    NOT?: DataBackupWhereInput | DataBackupWhereInput[]
    institutionId?: StringFilter<"DataBackup"> | string
    name?: StringFilter<"DataBackup"> | string
    description?: StringNullableFilter<"DataBackup"> | string | null
    storageUrl?: StringFilter<"DataBackup"> | string
    sizeBytes?: IntNullableFilter<"DataBackup"> | number | null
    createdById?: StringNullableFilter<"DataBackup"> | string | null
    createdAt?: DateTimeFilter<"DataBackup"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DataBackupOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    storageUrl?: SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DataBackupCountOrderByAggregateInput
    _avg?: DataBackupAvgOrderByAggregateInput
    _max?: DataBackupMaxOrderByAggregateInput
    _min?: DataBackupMinOrderByAggregateInput
    _sum?: DataBackupSumOrderByAggregateInput
  }

  export type DataBackupScalarWhereWithAggregatesInput = {
    AND?: DataBackupScalarWhereWithAggregatesInput | DataBackupScalarWhereWithAggregatesInput[]
    OR?: DataBackupScalarWhereWithAggregatesInput[]
    NOT?: DataBackupScalarWhereWithAggregatesInput | DataBackupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataBackup"> | string
    institutionId?: StringWithAggregatesFilter<"DataBackup"> | string
    name?: StringWithAggregatesFilter<"DataBackup"> | string
    description?: StringNullableWithAggregatesFilter<"DataBackup"> | string | null
    storageUrl?: StringWithAggregatesFilter<"DataBackup"> | string
    sizeBytes?: IntNullableWithAggregatesFilter<"DataBackup"> | number | null
    createdById?: StringNullableWithAggregatesFilter<"DataBackup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DataBackup"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    institutionId?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    type?: StringFilter<"Template"> | string
    body?: StringFilter<"Template"> | string
    metadata?: JsonNullableFilter<"Template">
    createdById?: StringNullableFilter<"Template"> | string | null
    createdAt?: DateTimeFilter<"Template"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    body?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    institutionId?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    type?: StringFilter<"Template"> | string
    body?: StringFilter<"Template"> | string
    metadata?: JsonNullableFilter<"Template">
    createdById?: StringNullableFilter<"Template"> | string | null
    createdAt?: DateTimeFilter<"Template"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    body?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    institutionId?: StringWithAggregatesFilter<"Template"> | string
    name?: StringWithAggregatesFilter<"Template"> | string
    type?: StringWithAggregatesFilter<"Template"> | string
    body?: StringWithAggregatesFilter<"Template"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Template">
    createdById?: StringNullableWithAggregatesFilter<"Template"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    institutionId?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonNullableFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    institutionId?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonNullableFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }, "id">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    institutionId?: StringWithAggregatesFilter<"Integration"> | string
    name?: StringWithAggregatesFilter<"Integration"> | string
    config?: JsonNullableWithAggregatesFilter<"Integration">
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type ApiClientWhereInput = {
    AND?: ApiClientWhereInput | ApiClientWhereInput[]
    OR?: ApiClientWhereInput[]
    NOT?: ApiClientWhereInput | ApiClientWhereInput[]
    id?: StringFilter<"ApiClient"> | string
    institutionId?: StringNullableFilter<"ApiClient"> | string | null
    clientId?: StringFilter<"ApiClient"> | string
    clientName?: StringFilter<"ApiClient"> | string
    clientType?: StringFilter<"ApiClient"> | string
    apiKeyHash?: StringFilter<"ApiClient"> | string
    scopes?: StringNullableListFilter<"ApiClient">
    isActive?: BoolFilter<"ApiClient"> | boolean
    createdAt?: DateTimeFilter<"ApiClient"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    usageLogs?: ApiUsageLogListRelationFilter
    rotations?: ApiKeyRotationListRelationFilter
  }

  export type ApiClientOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientType?: SortOrder
    apiKeyHash?: SortOrder
    scopes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    usageLogs?: ApiUsageLogOrderByRelationAggregateInput
    rotations?: ApiKeyRotationOrderByRelationAggregateInput
  }

  export type ApiClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    AND?: ApiClientWhereInput | ApiClientWhereInput[]
    OR?: ApiClientWhereInput[]
    NOT?: ApiClientWhereInput | ApiClientWhereInput[]
    institutionId?: StringNullableFilter<"ApiClient"> | string | null
    clientName?: StringFilter<"ApiClient"> | string
    clientType?: StringFilter<"ApiClient"> | string
    apiKeyHash?: StringFilter<"ApiClient"> | string
    scopes?: StringNullableListFilter<"ApiClient">
    isActive?: BoolFilter<"ApiClient"> | boolean
    createdAt?: DateTimeFilter<"ApiClient"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    usageLogs?: ApiUsageLogListRelationFilter
    rotations?: ApiKeyRotationListRelationFilter
  }, "id" | "clientId">

  export type ApiClientOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientType?: SortOrder
    apiKeyHash?: SortOrder
    scopes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ApiClientCountOrderByAggregateInput
    _max?: ApiClientMaxOrderByAggregateInput
    _min?: ApiClientMinOrderByAggregateInput
  }

  export type ApiClientScalarWhereWithAggregatesInput = {
    AND?: ApiClientScalarWhereWithAggregatesInput | ApiClientScalarWhereWithAggregatesInput[]
    OR?: ApiClientScalarWhereWithAggregatesInput[]
    NOT?: ApiClientScalarWhereWithAggregatesInput | ApiClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiClient"> | string
    institutionId?: StringNullableWithAggregatesFilter<"ApiClient"> | string | null
    clientId?: StringWithAggregatesFilter<"ApiClient"> | string
    clientName?: StringWithAggregatesFilter<"ApiClient"> | string
    clientType?: StringWithAggregatesFilter<"ApiClient"> | string
    apiKeyHash?: StringWithAggregatesFilter<"ApiClient"> | string
    scopes?: StringNullableListFilter<"ApiClient">
    isActive?: BoolWithAggregatesFilter<"ApiClient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApiClient"> | Date | string
  }

  export type ApiUsageLogWhereInput = {
    AND?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    OR?: ApiUsageLogWhereInput[]
    NOT?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    id?: StringFilter<"ApiUsageLog"> | string
    apiClientId?: StringFilter<"ApiUsageLog"> | string
    endpoint?: StringFilter<"ApiUsageLog"> | string
    method?: StringFilter<"ApiUsageLog"> | string
    statusCode?: IntFilter<"ApiUsageLog"> | number
    latencyMs?: IntNullableFilter<"ApiUsageLog"> | number | null
    createdAt?: DateTimeFilter<"ApiUsageLog"> | Date | string
    apiClient?: XOR<ApiClientScalarRelationFilter, ApiClientWhereInput>
  }

  export type ApiUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    latencyMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    apiClient?: ApiClientOrderByWithRelationInput
  }

  export type ApiUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    OR?: ApiUsageLogWhereInput[]
    NOT?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    apiClientId?: StringFilter<"ApiUsageLog"> | string
    endpoint?: StringFilter<"ApiUsageLog"> | string
    method?: StringFilter<"ApiUsageLog"> | string
    statusCode?: IntFilter<"ApiUsageLog"> | number
    latencyMs?: IntNullableFilter<"ApiUsageLog"> | number | null
    createdAt?: DateTimeFilter<"ApiUsageLog"> | Date | string
    apiClient?: XOR<ApiClientScalarRelationFilter, ApiClientWhereInput>
  }, "id">

  export type ApiUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    latencyMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiUsageLogCountOrderByAggregateInput
    _avg?: ApiUsageLogAvgOrderByAggregateInput
    _max?: ApiUsageLogMaxOrderByAggregateInput
    _min?: ApiUsageLogMinOrderByAggregateInput
    _sum?: ApiUsageLogSumOrderByAggregateInput
  }

  export type ApiUsageLogScalarWhereWithAggregatesInput = {
    AND?: ApiUsageLogScalarWhereWithAggregatesInput | ApiUsageLogScalarWhereWithAggregatesInput[]
    OR?: ApiUsageLogScalarWhereWithAggregatesInput[]
    NOT?: ApiUsageLogScalarWhereWithAggregatesInput | ApiUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiUsageLog"> | string
    apiClientId?: StringWithAggregatesFilter<"ApiUsageLog"> | string
    endpoint?: StringWithAggregatesFilter<"ApiUsageLog"> | string
    method?: StringWithAggregatesFilter<"ApiUsageLog"> | string
    statusCode?: IntWithAggregatesFilter<"ApiUsageLog"> | number
    latencyMs?: IntNullableWithAggregatesFilter<"ApiUsageLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiUsageLog"> | Date | string
  }

  export type ApiScopeWhereInput = {
    AND?: ApiScopeWhereInput | ApiScopeWhereInput[]
    OR?: ApiScopeWhereInput[]
    NOT?: ApiScopeWhereInput | ApiScopeWhereInput[]
    id?: StringFilter<"ApiScope"> | string
    name?: StringFilter<"ApiScope"> | string
    description?: StringNullableFilter<"ApiScope"> | string | null
  }

  export type ApiScopeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type ApiScopeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ApiScopeWhereInput | ApiScopeWhereInput[]
    OR?: ApiScopeWhereInput[]
    NOT?: ApiScopeWhereInput | ApiScopeWhereInput[]
    description?: StringNullableFilter<"ApiScope"> | string | null
  }, "id" | "name">

  export type ApiScopeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ApiScopeCountOrderByAggregateInput
    _max?: ApiScopeMaxOrderByAggregateInput
    _min?: ApiScopeMinOrderByAggregateInput
  }

  export type ApiScopeScalarWhereWithAggregatesInput = {
    AND?: ApiScopeScalarWhereWithAggregatesInput | ApiScopeScalarWhereWithAggregatesInput[]
    OR?: ApiScopeScalarWhereWithAggregatesInput[]
    NOT?: ApiScopeScalarWhereWithAggregatesInput | ApiScopeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiScope"> | string
    name?: StringWithAggregatesFilter<"ApiScope"> | string
    description?: StringNullableWithAggregatesFilter<"ApiScope"> | string | null
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    institutionId?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    institutionId?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    institutionId?: StringWithAggregatesFilter<"Webhook"> | string
    name?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    status?: StringFilter<"WebhookDelivery"> | string
    response?: JsonNullableFilter<"WebhookDelivery">
    attempt?: IntFilter<"WebhookDelivery"> | number
    sentAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    attempt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    webhookId?: StringFilter<"WebhookDelivery"> | string
    status?: StringFilter<"WebhookDelivery"> | string
    response?: JsonNullableFilter<"WebhookDelivery">
    attempt?: IntFilter<"WebhookDelivery"> | number
    sentAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    attempt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    webhookId?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    status?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    response?: JsonNullableWithAggregatesFilter<"WebhookDelivery">
    attempt?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    sentAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type ApiKeyRotationWhereInput = {
    AND?: ApiKeyRotationWhereInput | ApiKeyRotationWhereInput[]
    OR?: ApiKeyRotationWhereInput[]
    NOT?: ApiKeyRotationWhereInput | ApiKeyRotationWhereInput[]
    id?: StringFilter<"ApiKeyRotation"> | string
    apiClientId?: StringFilter<"ApiKeyRotation"> | string
    keyHash?: StringFilter<"ApiKeyRotation"> | string
    createdAt?: DateTimeFilter<"ApiKeyRotation"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKeyRotation"> | Date | string | null
    apiClient?: XOR<ApiClientScalarRelationFilter, ApiClientWhereInput>
  }

  export type ApiKeyRotationOrderByWithRelationInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    keyHash?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    apiClient?: ApiClientOrderByWithRelationInput
  }

  export type ApiKeyRotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiKeyRotationWhereInput | ApiKeyRotationWhereInput[]
    OR?: ApiKeyRotationWhereInput[]
    NOT?: ApiKeyRotationWhereInput | ApiKeyRotationWhereInput[]
    apiClientId?: StringFilter<"ApiKeyRotation"> | string
    keyHash?: StringFilter<"ApiKeyRotation"> | string
    createdAt?: DateTimeFilter<"ApiKeyRotation"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKeyRotation"> | Date | string | null
    apiClient?: XOR<ApiClientScalarRelationFilter, ApiClientWhereInput>
  }, "id">

  export type ApiKeyRotationOrderByWithAggregationInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    keyHash?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: ApiKeyRotationCountOrderByAggregateInput
    _max?: ApiKeyRotationMaxOrderByAggregateInput
    _min?: ApiKeyRotationMinOrderByAggregateInput
  }

  export type ApiKeyRotationScalarWhereWithAggregatesInput = {
    AND?: ApiKeyRotationScalarWhereWithAggregatesInput | ApiKeyRotationScalarWhereWithAggregatesInput[]
    OR?: ApiKeyRotationScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyRotationScalarWhereWithAggregatesInput | ApiKeyRotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKeyRotation"> | string
    apiClientId?: StringWithAggregatesFilter<"ApiKeyRotation"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKeyRotation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKeyRotation"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ApiKeyRotation"> | Date | string | null
  }

  export type DashboardConfigWhereInput = {
    AND?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    OR?: DashboardConfigWhereInput[]
    NOT?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    id?: StringFilter<"DashboardConfig"> | string
    userId?: StringFilter<"DashboardConfig"> | string
    type?: StringFilter<"DashboardConfig"> | string
    config?: JsonFilter<"DashboardConfig">
    updatedAt?: DateTimeFilter<"DashboardConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DashboardConfigOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DashboardConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    OR?: DashboardConfigWhereInput[]
    NOT?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    userId?: StringFilter<"DashboardConfig"> | string
    type?: StringFilter<"DashboardConfig"> | string
    config?: JsonFilter<"DashboardConfig">
    updatedAt?: DateTimeFilter<"DashboardConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DashboardConfigOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardConfigCountOrderByAggregateInput
    _max?: DashboardConfigMaxOrderByAggregateInput
    _min?: DashboardConfigMinOrderByAggregateInput
  }

  export type DashboardConfigScalarWhereWithAggregatesInput = {
    AND?: DashboardConfigScalarWhereWithAggregatesInput | DashboardConfigScalarWhereWithAggregatesInput[]
    OR?: DashboardConfigScalarWhereWithAggregatesInput[]
    NOT?: DashboardConfigScalarWhereWithAggregatesInput | DashboardConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DashboardConfig"> | string
    userId?: StringWithAggregatesFilter<"DashboardConfig"> | string
    type?: StringWithAggregatesFilter<"DashboardConfig"> | string
    config?: JsonWithAggregatesFilter<"DashboardConfig">
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardConfig"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    bio?: StringNullableFilter<"Teacher"> | string | null
    specialties?: StringNullableListFilter<"Teacher">
    hireDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    specialties?: SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    bio?: StringNullableFilter<"Teacher"> | string | null
    specialties?: StringNullableListFilter<"Teacher">
    hireDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    specialties?: SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    bio?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    specialties?: StringNullableListFilter<"Teacher">
    hireDate?: DateTimeNullableWithAggregatesFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type InstitutionLogWhereInput = {
    AND?: InstitutionLogWhereInput | InstitutionLogWhereInput[]
    OR?: InstitutionLogWhereInput[]
    NOT?: InstitutionLogWhereInput | InstitutionLogWhereInput[]
    id?: StringFilter<"InstitutionLog"> | string
    institutionId?: StringFilter<"InstitutionLog"> | string
    userId?: StringNullableFilter<"InstitutionLog"> | string | null
    module?: StringNullableFilter<"InstitutionLog"> | string | null
    action?: StringFilter<"InstitutionLog"> | string
    data?: JsonNullableFilter<"InstitutionLog">
    ip?: StringNullableFilter<"InstitutionLog"> | string | null
    userAgent?: StringNullableFilter<"InstitutionLog"> | string | null
    createdAt?: DateTimeFilter<"InstitutionLog"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InstitutionLogOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    action?: SortOrder
    data?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InstitutionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstitutionLogWhereInput | InstitutionLogWhereInput[]
    OR?: InstitutionLogWhereInput[]
    NOT?: InstitutionLogWhereInput | InstitutionLogWhereInput[]
    institutionId?: StringFilter<"InstitutionLog"> | string
    userId?: StringNullableFilter<"InstitutionLog"> | string | null
    module?: StringNullableFilter<"InstitutionLog"> | string | null
    action?: StringFilter<"InstitutionLog"> | string
    data?: JsonNullableFilter<"InstitutionLog">
    ip?: StringNullableFilter<"InstitutionLog"> | string | null
    userAgent?: StringNullableFilter<"InstitutionLog"> | string | null
    createdAt?: DateTimeFilter<"InstitutionLog"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InstitutionLogOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    action?: SortOrder
    data?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InstitutionLogCountOrderByAggregateInput
    _max?: InstitutionLogMaxOrderByAggregateInput
    _min?: InstitutionLogMinOrderByAggregateInput
  }

  export type InstitutionLogScalarWhereWithAggregatesInput = {
    AND?: InstitutionLogScalarWhereWithAggregatesInput | InstitutionLogScalarWhereWithAggregatesInput[]
    OR?: InstitutionLogScalarWhereWithAggregatesInput[]
    NOT?: InstitutionLogScalarWhereWithAggregatesInput | InstitutionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstitutionLog"> | string
    institutionId?: StringWithAggregatesFilter<"InstitutionLog"> | string
    userId?: StringNullableWithAggregatesFilter<"InstitutionLog"> | string | null
    module?: StringNullableWithAggregatesFilter<"InstitutionLog"> | string | null
    action?: StringWithAggregatesFilter<"InstitutionLog"> | string
    data?: JsonNullableWithAggregatesFilter<"InstitutionLog">
    ip?: StringNullableWithAggregatesFilter<"InstitutionLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"InstitutionLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InstitutionLog"> | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    institutions?: InstitutionCreateNestedManyWithoutPlanInput
    InstitutionSubscription?: InstitutionSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    institutions?: InstitutionUncheckedCreateNestedManyWithoutPlanInput
    InstitutionSubscription?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUpdateManyWithoutPlanNestedInput
    InstitutionSubscription?: InstitutionSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUncheckedUpdateManyWithoutPlanNestedInput
    InstitutionSubscription?: InstitutionSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateManyInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
  }

  export type InstitutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionSubscriptionCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutInstitutionSubscriptionInput
    payments?: InstitutionPaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type InstitutionSubscriptionUncheckedCreateInput = {
    id?: string
    institutionId: string
    planId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    payments?: InstitutionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type InstitutionSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutInstitutionSubscriptionNestedInput
    payments?: InstitutionPaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type InstitutionSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstitutionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type InstitutionSubscriptionCreateManyInput = {
    id?: string
    institutionId: string
    planId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
  }

  export type InstitutionSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutInstitutionPaymentsInput
    subscription?: InstitutionSubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type InstitutionPaymentUncheckedCreateInput = {
    id?: string
    institutionId: string
    subscriptionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
  }

  export type InstitutionPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutInstitutionPaymentsNestedInput
    subscription?: InstitutionSubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type InstitutionPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentCreateManyInput = {
    id?: string
    institutionId: string
    subscriptionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
  }

  export type InstitutionPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutRolesInput
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    institutionId?: string | null
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutRolesNestedInput
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    institutionId?: string | null
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABACPolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: $Enums.PolicyEffect
    isActive?: boolean
    createdAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutABACPolicyInput
  }

  export type ABACPolicyUncheckedCreateInput = {
    id?: string
    institutionId?: string | null
    name: string
    description?: string | null
    resource: string
    action: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: $Enums.PolicyEffect
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ABACPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutABACPolicyNestedInput
  }

  export type ABACPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABACPolicyCreateManyInput = {
    id?: string
    institutionId?: string | null
    name: string
    description?: string | null
    resource: string
    action: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: $Enums.PolicyEffect
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ABACPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABACPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerCreateInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutCareersInput
    createdBy?: UserCreateNestedOneWithoutCareersInput
    courses?: CourseCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodCreateNestedManyWithoutCareerInput
    students?: StudentCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput
    students?: StudentUncheckedCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutCareersNestedInput
    createdBy?: UserUpdateOneWithoutCareersNestedInput
    courses?: CourseUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUpdateManyWithoutCareerNestedInput
    students?: StudentUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput
    students?: StudentUncheckedUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type CareerCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type CareerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutPeriodsInput
    courses?: CourseCreateNestedManyWithoutAcademicPeriodInput
    enrollments?: EnrollmentCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateInput = {
    id?: string
    careerId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicPeriodInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutPeriodsNestedInput
    courses?: CourseUpdateManyWithoutAcademicPeriodNestedInput
    enrollments?: EnrollmentUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodCreateManyInput = {
    id?: string
    careerId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AcademicPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutCoursesInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCoursesInput
    createdBy?: UserCreateNestedOneWithoutCoursesInput
    subjects?: SubjectCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    certificate?: CertificateCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutCoursesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCoursesNestedInput
    createdBy?: UserUpdateOneWithoutCoursesNestedInput
    subjects?: SubjectUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSubjectsInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutSubjectInput
    certificate?: CertificateCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    courseId: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutSubjectInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSubjectsNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    courseId: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassroomCreateInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomCreateManyInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
  }

  export type VirtualClassroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonPlanCreateInput = {
    id?: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    classroom: VirtualClassroomCreateNestedOneWithoutLessonPlansInput
    createdBy?: UserCreateNestedOneWithoutLessonPlansInput
  }

  export type LessonPlanUncheckedCreateInput = {
    id?: string
    classroomId: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type LessonPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: VirtualClassroomUpdateOneRequiredWithoutLessonPlansNestedInput
    createdBy?: UserUpdateOneWithoutLessonPlansNestedInput
  }

  export type LessonPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanCreateManyInput = {
    id?: string
    classroomId: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type LessonPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    status?: string | null
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    courseId: string
    academicPeriodId?: string | null
    enrolledAt?: Date | string
    status?: string | null
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    studentId: string
    courseId: string
    academicPeriodId?: string | null
    enrolledAt?: Date | string
    status?: string | null
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentSubjectCreateInput = {
    id?: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutStudentSubjectsInput
    classroom?: VirtualClassroomCreateNestedOneWithoutStudentSubjectInput
    grades?: GradeCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutStudentSubjectsNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutStudentSubjectNestedInput
    grades?: GradeUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type StudentSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdAt?: Date | string
    studentSubject: StudentSubjectCreateNestedOneWithoutGradesInput
    createdBy?: UserCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    studentSubjectId: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSubject?: StudentSubjectUpdateOneRequiredWithoutGradesNestedInput
    createdBy?: UserUpdateOneWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentSubjectId?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyInput = {
    id?: string
    studentSubjectId: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentSubjectId?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
    classroom: VirtualClassroomCreateNestedOneWithoutAttendancesInput
    notedBy?: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    studentId: string
    classroomId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notedById?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
    classroom?: VirtualClassroomUpdateOneRequiredWithoutAttendancesNestedInput
    notedBy?: UserUpdateOneWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notedById?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    studentId: string
    classroomId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notedById?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notedById?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisciplinaryRecordCreateInput = {
    id?: string
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
    student: StudentCreateNestedOneWithoutDisciplinaryRecordInput
    subject?: SubjectCreateNestedOneWithoutDisciplinaryRecordInput
    recordedBy?: UserCreateNestedOneWithoutDisciplinaryRecordInput
  }

  export type DisciplinaryRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    recordedById?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type DisciplinaryRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutDisciplinaryRecordNestedInput
    subject?: SubjectUpdateOneWithoutDisciplinaryRecordNestedInput
    recordedBy?: UserUpdateOneWithoutDisciplinaryRecordNestedInput
  }

  export type DisciplinaryRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisciplinaryRecordCreateManyInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    recordedById?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type DisciplinaryRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisciplinaryRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TutorProfileCreateInput = {
    id?: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTutorProfileInput
    institution: InstitutionCreateNestedOneWithoutTutorProfileInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutTutorInput
  }

  export type TutorProfileUncheckedCreateInput = {
    id?: string
    userId: string
    institutionId: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTutorProfileNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutTutorProfileNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutTutorNestedInput
  }

  export type TutorProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type TutorProfileCreateManyInput = {
    id?: string
    userId: string
    institutionId: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TutorProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentCreateInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    tutor: TutorProfileCreateNestedOneWithoutTutorAssignmentsInput
    student: StudentCreateNestedOneWithoutTutorAssignmentsInput
  }

  export type TutorStudentUncheckedCreateInput = {
    id?: string
    tutorId: string
    studentId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type TutorStudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutorProfileUpdateOneRequiredWithoutTutorAssignmentsNestedInput
    student?: StudentUpdateOneRequiredWithoutTutorAssignmentsNestedInput
  }

  export type TutorStudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tutorId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentCreateManyInput = {
    id?: string
    tutorId: string
    studentId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type TutorStudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tutorId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student: StudentCreateNestedOneWithoutCertificatesInput
    course?: CourseCreateNestedOneWithoutCertificateInput
    subject?: SubjectCreateNestedOneWithoutCertificateInput
    issuedBy?: UserCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    studentId: string
    courseId?: string | null
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneWithoutCertificateNestedInput
    subject?: SubjectUpdateOneWithoutCertificateNestedInput
    issuedBy?: UserUpdateOneWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateCreateManyInput = {
    id?: string
    studentId: string
    courseId?: string | null
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FeeScheduleCreateInput = {
    id?: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutFeeSchedulesInput
    career?: CareerCreateNestedOneWithoutFeeScheduleInput
    installmentsList?: FeeInstallmentCreateNestedManyWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleUncheckedCreateInput = {
    id?: string
    institutionId: string
    careerId?: string | null
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    installmentsList?: FeeInstallmentUncheckedCreateNestedManyWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutFeeSchedulesNestedInput
    career?: CareerUpdateOneWithoutFeeScheduleNestedInput
    installmentsList?: FeeInstallmentUpdateManyWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentsList?: FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleCreateManyInput = {
    id?: string
    institutionId: string
    careerId?: string | null
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeeScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeInstallmentCreateInput = {
    id?: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    feeSchedule: FeeScheduleCreateNestedOneWithoutInstallmentsListInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutFeeInstallmentInput
  }

  export type FeeInstallmentUncheckedCreateInput = {
    id?: string
    feeScheduleId: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutFeeInstallmentInput
  }

  export type FeeInstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeSchedule?: FeeScheduleUpdateOneRequiredWithoutInstallmentsListNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutFeeInstallmentNestedInput
  }

  export type FeeInstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutFeeInstallmentNestedInput
  }

  export type FeeInstallmentCreateManyInput = {
    id?: string
    feeScheduleId: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type FeeInstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeInstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutPaymentsInput
    institution: InstitutionCreateNestedOneWithoutStudentPaymentsInput
    feeInstallment?: FeeInstallmentCreateNestedOneWithoutStudentPaymentsInput
  }

  export type StudentPaymentUncheckedCreateInput = {
    id?: string
    studentId: string
    institutionId: string
    feeInstallmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudentPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPaymentsNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentPaymentsNestedInput
    feeInstallment?: FeeInstallmentUpdateOneWithoutStudentPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    feeInstallmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentCreateManyInput = {
    id?: string
    studentId: string
    institutionId: string
    feeInstallmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudentPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    feeInstallmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanCreateInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutPaymentPlanInput
    feeSchedule: FeeScheduleCreateNestedOneWithoutPaymentPlanInput
  }

  export type PaymentPlanUncheckedCreateInput = {
    id?: string
    studentId: string
    feeScheduleId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type PaymentPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPaymentPlanNestedInput
    feeSchedule?: FeeScheduleUpdateOneRequiredWithoutPaymentPlanNestedInput
  }

  export type PaymentPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanCreateManyInput = {
    id?: string
    studentId: string
    feeScheduleId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type PaymentPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentCreateInput = {
    id?: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutAiAgentsInput
    conversations?: AIConversationCreateNestedManyWithoutAgentInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutAiagentInput
  }

  export type AIAgentUncheckedCreateInput = {
    id?: string
    institutionId: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    conversations?: AIConversationUncheckedCreateNestedManyWithoutAgentInput
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutAiagentInput
  }

  export type AIAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutAiAgentsNestedInput
    conversations?: AIConversationUpdateManyWithoutAgentNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutAiagentNestedInput
  }

  export type AIAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUncheckedUpdateManyWithoutAgentNestedInput
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutAiagentNestedInput
  }

  export type AIAgentCreateManyInput = {
    id?: string
    institutionId: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AIAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateInput = {
    id?: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutAIConversationInput
    agent: AIAgentCreateNestedOneWithoutConversationsInput
    messages?: AIMessageCreateNestedManyWithoutConversationInput
  }

  export type AIConversationUncheckedCreateInput = {
    id?: string
    userId: string
    agentId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    messages?: AIMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AIConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutAIConversationNestedInput
    agent?: AIAgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: AIMessageUpdateManyWithoutConversationNestedInput
  }

  export type AIConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    messages?: AIMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AIConversationCreateManyInput = {
    id?: string
    userId: string
    agentId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type AIConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AIConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AIMessageCreateInput = {
    id?: string
    role: string
    content: string
    tokens?: number | null
    createdAt?: Date | string
    conversation: AIConversationCreateNestedOneWithoutMessagesInput
  }

  export type AIMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    tokens?: number | null
    createdAt?: Date | string
  }

  export type AIMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: AIConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AIMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIMessageCreateManyInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    tokens?: number | null
    createdAt?: Date | string
  }

  export type AIMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateInput = {
    id?: string
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiUsagesInput
    institution: InstitutionCreateNestedOneWithoutAiUsageLogsInput
    classroom?: VirtualClassroomCreateNestedOneWithoutAiUsagesInput
  }

  export type AIUsageLogUncheckedCreateInput = {
    id?: string
    userId: string
    institutionId: string
    classroomId?: string | null
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiUsagesNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutAiUsageLogsNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutAiUsagesNestedInput
  }

  export type AIUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateManyInput = {
    id?: string
    userId: string
    institutionId: string
    classroomId?: string | null
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    title: string
    body: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    title: string
    body: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferenceInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    recipientId: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    recipientId: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutAnnouncementsInput
    createdBy?: UserCreateNestedOneWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    institutionId: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutAnnouncementsNestedInput
    createdBy?: UserUpdateOneWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    institutionId: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupCreateInput = {
    id?: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutBackupsInput
    createdBy?: UserCreateNestedOneWithoutDataBackupsInput
  }

  export type DataBackupUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type DataBackupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutBackupsNestedInput
    createdBy?: UserUpdateOneWithoutDataBackupsNestedInput
  }

  export type DataBackupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type DataBackupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutTemplatesInput
    createdBy?: UserCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutTemplatesNestedInput
    createdBy?: UserUpdateOneWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    name: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiClientCreateInput = {
    id?: string
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutApiClientsInput
    usageLogs?: ApiUsageLogCreateNestedManyWithoutApiClientInput
    rotations?: ApiKeyRotationCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientUncheckedCreateInput = {
    id?: string
    institutionId?: string | null
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    usageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutApiClientInput
    rotations?: ApiKeyRotationUncheckedCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutApiClientsNestedInput
    usageLogs?: ApiUsageLogUpdateManyWithoutApiClientNestedInput
    rotations?: ApiKeyRotationUpdateManyWithoutApiClientNestedInput
  }

  export type ApiClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiUsageLogUncheckedUpdateManyWithoutApiClientNestedInput
    rotations?: ApiKeyRotationUncheckedUpdateManyWithoutApiClientNestedInput
  }

  export type ApiClientCreateManyInput = {
    id?: string
    institutionId?: string | null
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ApiClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs?: number | null
    createdAt?: Date | string
    apiClient: ApiClientCreateNestedOneWithoutUsageLogsInput
  }

  export type ApiUsageLogUncheckedCreateInput = {
    id?: string
    apiClientId: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type ApiUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiClient?: ApiClientUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type ApiUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiClientId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogCreateManyInput = {
    id?: string
    apiClientId: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type ApiUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiClientId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiScopeCreateInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type ApiScopeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type ApiScopeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiScopeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiScopeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type ApiScopeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiScopeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookCreateInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    status: string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: number
    sentAt?: Date | string | null
    createdAt?: Date | string
    webhook: WebhookCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    webhookId: string
    status: string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: number
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook?: WebhookUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    webhookId: string
    status: string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: number
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyRotationCreateInput = {
    id?: string
    keyHash: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    apiClient: ApiClientCreateNestedOneWithoutRotationsInput
  }

  export type ApiKeyRotationUncheckedCreateInput = {
    id?: string
    apiClientId: string
    keyHash: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyRotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiClient?: ApiClientUpdateOneRequiredWithoutRotationsNestedInput
  }

  export type ApiKeyRotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiClientId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyRotationCreateManyInput = {
    id?: string
    apiClientId: string
    keyHash: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyRotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyRotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiClientId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardConfigCreateInput = {
    id?: string
    type: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDashboardsInput
  }

  export type DashboardConfigUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DashboardConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDashboardsNestedInput
  }

  export type DashboardConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardConfigCreateManyInput = {
    id?: string
    userId: string
    type: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DashboardConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    bio?: string | null
    specialties?: TeacherCreatespecialtiesInput | string[]
    hireDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: TeacherCreatespecialtiesInput | string[]
    hireDate?: Date | string | null
    createdAt?: Date | string
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: TeacherUpdatespecialtiesInput | string[]
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: TeacherUpdatespecialtiesInput | string[]
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: TeacherCreatespecialtiesInput | string[]
    hireDate?: Date | string | null
    createdAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: TeacherUpdatespecialtiesInput | string[]
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: TeacherUpdatespecialtiesInput | string[]
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogCreateInput = {
    id?: string
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutInstitutionLogsInput
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type InstitutionLogUncheckedCreateInput = {
    id?: string
    institutionId: string
    userId?: string | null
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InstitutionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutInstitutionLogsNestedInput
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type InstitutionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogCreateManyInput = {
    id?: string
    institutionId: string
    userId?: string | null
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InstitutionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type InstitutionListRelationFilter = {
    every?: InstitutionWhereInput
    some?: InstitutionWhereInput
    none?: InstitutionWhereInput
  }

  export type InstitutionSubscriptionListRelationFilter = {
    every?: InstitutionSubscriptionWhereInput
    some?: InstitutionSubscriptionWhereInput
    none?: InstitutionSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
    studentLimit?: SortOrder
    teacherLimit?: SortOrder
    adminLimit?: SortOrder
    courseLimit?: SortOrder
    aiTeacherCallsMonthly?: SortOrder
    aiStudentMinutesMonthly?: SortOrder
    certificateMonthly?: SortOrder
    virtualClassroomLimit?: SortOrder
    storageMB?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PlanNullableScalarRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type CareerListRelationFilter = {
    every?: CareerWhereInput
    some?: CareerWhereInput
    none?: CareerWhereInput
  }

  export type InstitutionPaymentListRelationFilter = {
    every?: InstitutionPaymentWhereInput
    some?: InstitutionPaymentWhereInput
    none?: InstitutionPaymentWhereInput
  }

  export type InstitutionLogListRelationFilter = {
    every?: InstitutionLogWhereInput
    some?: InstitutionLogWhereInput
    none?: InstitutionLogWhereInput
  }

  export type AIUsageLogListRelationFilter = {
    every?: AIUsageLogWhereInput
    some?: AIUsageLogWhereInput
    none?: AIUsageLogWhereInput
  }

  export type TemplateListRelationFilter = {
    every?: TemplateWhereInput
    some?: TemplateWhereInput
    none?: TemplateWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type ApiClientListRelationFilter = {
    every?: ApiClientWhereInput
    some?: ApiClientWhereInput
    none?: ApiClientWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type DataBackupListRelationFilter = {
    every?: DataBackupWhereInput
    some?: DataBackupWhereInput
    none?: DataBackupWhereInput
  }

  export type FeeScheduleListRelationFilter = {
    every?: FeeScheduleWhereInput
    some?: FeeScheduleWhereInput
    none?: FeeScheduleWhereInput
  }

  export type ABACPolicyListRelationFilter = {
    every?: ABACPolicyWhereInput
    some?: ABACPolicyWhereInput
    none?: ABACPolicyWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type TutorProfileListRelationFilter = {
    every?: TutorProfileWhereInput
    some?: TutorProfileWhereInput
    none?: TutorProfileWhereInput
  }

  export type StudentPaymentListRelationFilter = {
    every?: StudentPaymentWhereInput
    some?: StudentPaymentWhereInput
    none?: StudentPaymentWhereInput
  }

  export type AIAgentListRelationFilter = {
    every?: AIAgentWhereInput
    some?: AIAgentWhereInput
    none?: AIAgentWhereInput
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataBackupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ABACPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutorProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    contactEmail?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    planId?: SortOrder
    settings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    contactEmail?: SortOrder
    phone?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    contactEmail?: SortOrder
    phone?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type InstitutionScalarRelationFilter = {
    is?: InstitutionWhereInput
    isNot?: InstitutionWhereInput
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type InstitutionSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    billingCycle?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    billingCycle?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    autoRenew?: SortOrder
    billingCycle?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type InstitutionSubscriptionNullableScalarRelationFilter = {
    is?: InstitutionSubscriptionWhereInput | null
    isNot?: InstitutionSubscriptionWhereInput | null
  }

  export type InstitutionPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayData?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InstitutionPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type InstitutionNullableScalarRelationFilter = {
    is?: InstitutionWhereInput | null
    isNot?: InstitutionWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type TutorProfileNullableScalarRelationFilter = {
    is?: TutorProfileWhereInput | null
    isNot?: TutorProfileWhereInput | null
  }

  export type DashboardConfigListRelationFilter = {
    every?: DashboardConfigWhereInput
    some?: DashboardConfigWhereInput
    none?: DashboardConfigWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LessonPlanListRelationFilter = {
    every?: LessonPlanWhereInput
    some?: LessonPlanWhereInput
    none?: LessonPlanWhereInput
  }

  export type VirtualClassroomListRelationFilter = {
    every?: VirtualClassroomWhereInput
    some?: VirtualClassroomWhereInput
    none?: VirtualClassroomWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type DisciplinaryRecordListRelationFilter = {
    every?: DisciplinaryRecordWhereInput
    some?: DisciplinaryRecordWhereInput
    none?: DisciplinaryRecordWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type AIConversationListRelationFilter = {
    every?: AIConversationWhereInput
    some?: AIConversationWhereInput
    none?: AIConversationWhereInput
  }

  export type NotificationPreferenceListRelationFilter = {
    every?: NotificationPreferenceWhereInput
    some?: NotificationPreferenceWhereInput
    none?: NotificationPreferenceWhereInput
  }

  export type DashboardConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VirtualClassroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisciplinaryRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    ci?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    attributes?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    ci?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    ci?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type EnumPolicyEffectFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyEffect | EnumPolicyEffectFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyEffectFilter<$PrismaModel> | $Enums.PolicyEffect
  }

  export type ABACPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    condition?: SortOrder
    effect?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ABACPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ABACPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPolicyEffectWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyEffect | EnumPolicyEffectFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyEffectWithAggregatesFilter<$PrismaModel> | $Enums.PolicyEffect
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPolicyEffectFilter<$PrismaModel>
    _max?: NestedEnumPolicyEffectFilter<$PrismaModel>
  }

  export type EnumLevelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelType | EnumLevelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelTypeFilter<$PrismaModel> | $Enums.LevelType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AcademicPeriodListRelationFilter = {
    every?: AcademicPeriodWhereInput
    some?: AcademicPeriodWhereInput
    none?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerUnique_institution_career_codeCompoundUniqueInput = {
    institutionId: string
    code: string
  }

  export type CareerCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CareerMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CareerMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLevelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelType | EnumLevelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelTypeWithAggregatesFilter<$PrismaModel> | $Enums.LevelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelTypeFilter<$PrismaModel>
    _max?: NestedEnumLevelTypeFilter<$PrismaModel>
  }

  export type CareerScalarRelationFilter = {
    is?: CareerWhereInput
    isNot?: CareerWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AcademicPeriodNullableScalarRelationFilter = {
    is?: AcademicPeriodWhereInput | null
    isNot?: AcademicPeriodWhereInput | null
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    careerId?: SortOrder
    academicPeriodId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    durationSemesters?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    credits?: SortOrder
    durationSemesters?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    careerId?: SortOrder
    academicPeriodId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    durationSemesters?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    careerId?: SortOrder
    academicPeriodId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    durationSemesters?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    credits?: SortOrder
    durationSemesters?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type StudentSubjectListRelationFilter = {
    every?: StudentSubjectWhereInput
    some?: StudentSubjectWhereInput
    none?: StudentSubjectWhereInput
  }

  export type StudentSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    semester?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    semester?: SortOrder
    credits?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    semester?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    semester?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    semester?: SortOrder
    credits?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type AIAgentNullableScalarRelationFilter = {
    is?: AIAgentWhereInput | null
    isNot?: AIAgentWhereInput | null
  }

  export type VirtualClassroomCountOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    teacherId?: SortOrder
    aiEnabled?: SortOrder
    aiConfig?: SortOrder
    createdAt?: SortOrder
    aiagentId?: SortOrder
  }

  export type VirtualClassroomMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    teacherId?: SortOrder
    aiEnabled?: SortOrder
    createdAt?: SortOrder
    aiagentId?: SortOrder
  }

  export type VirtualClassroomMinOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    teacherId?: SortOrder
    aiEnabled?: SortOrder
    createdAt?: SortOrder
    aiagentId?: SortOrder
  }

  export type VirtualClassroomScalarRelationFilter = {
    is?: VirtualClassroomWhereInput
    isNot?: VirtualClassroomWhereInput
  }

  export type LessonPlanCountOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    topic?: SortOrder
    aiSuggestions?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    topic?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonPlanMinOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    topic?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type CareerNullableScalarRelationFilter = {
    is?: CareerWhereInput | null
    isNot?: CareerWhereInput | null
  }

  export type TutorStudentListRelationFilter = {
    every?: TutorStudentWhereInput
    some?: TutorStudentWhereInput
    none?: TutorStudentWhereInput
  }

  export type PaymentPlanListRelationFilter = {
    every?: PaymentPlanWhereInput
    some?: PaymentPlanWhereInput
    none?: PaymentPlanWhereInput
  }

  export type TutorStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentUnique_institution_student_numberCompoundUniqueInput = {
    institutionId: string
    studentNumber: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentNumber?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentNumber?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentNumber?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    enrolledAt?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    enrolledAt?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    enrolledAt?: SortOrder
    status?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type VirtualClassroomNullableScalarRelationFilter = {
    is?: VirtualClassroomWhereInput | null
    isNot?: VirtualClassroomWhereInput | null
  }

  export type StudentSubjectUnique_student_subjectCompoundUniqueInput = {
    studentId: string
    subjectId: string
  }

  export type StudentSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    classroomId?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    finalGrade?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSubjectAvgOrderByAggregateInput = {
    semester?: SortOrder
    year?: SortOrder
    finalGrade?: SortOrder
  }

  export type StudentSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    classroomId?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    finalGrade?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    classroomId?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    finalGrade?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSubjectSumOrderByAggregateInput = {
    semester?: SortOrder
    year?: SortOrder
    finalGrade?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumGradeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeFilter<$PrismaModel> | $Enums.GradeType
  }

  export type StudentSubjectScalarRelationFilter = {
    is?: StudentSubjectWhereInput
    isNot?: StudentSubjectWhereInput
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    studentSubjectId?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    value?: SortOrder
    comments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    weight?: SortOrder
    value?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentSubjectId?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    value?: SortOrder
    comments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    studentSubjectId?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    value?: SortOrder
    comments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    weight?: SortOrder
    value?: SortOrder
  }

  export type EnumGradeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GradeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGradeTypeFilter<$PrismaModel>
    _max?: NestedEnumGradeTypeFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notedById?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notedById?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classroomId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notedById?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type DisciplinaryRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    recordedById?: SortOrder
    type?: SortOrder
    description?: SortOrder
    actionTaken?: SortOrder
    date?: SortOrder
    seenByTutor?: SortOrder
  }

  export type DisciplinaryRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    recordedById?: SortOrder
    type?: SortOrder
    description?: SortOrder
    actionTaken?: SortOrder
    date?: SortOrder
    seenByTutor?: SortOrder
  }

  export type DisciplinaryRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    recordedById?: SortOrder
    type?: SortOrder
    description?: SortOrder
    actionTaken?: SortOrder
    date?: SortOrder
    seenByTutor?: SortOrder
  }

  export type TutorProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TutorProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type TutorProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type TutorProfileScalarRelationFilter = {
    is?: TutorProfileWhereInput
    isNot?: TutorProfileWhereInput
  }

  export type TutorStudentTutorIdStudentIdCompoundUniqueInput = {
    tutorId: string
    studentId: string
  }

  export type TutorStudentCountOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    studentId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type TutorStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    studentId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type TutorStudentMinOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    studentId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type EnumCertificateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeFilter<$PrismaModel> | $Enums.CertificateType
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    subjectId?: SortOrder
    type?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
    issuedById?: SortOrder
    metadata?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    subjectId?: SortOrder
    type?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
    issuedById?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    subjectId?: SortOrder
    type?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
    issuedById?: SortOrder
  }

  export type EnumCertificateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificateTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificateTypeFilter<$PrismaModel>
  }

  export type FeeInstallmentListRelationFilter = {
    every?: FeeInstallmentWhereInput
    some?: FeeInstallmentWhereInput
    none?: FeeInstallmentWhereInput
  }

  export type FeeInstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    frequency?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeScheduleAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    installments?: SortOrder
  }

  export type FeeScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    careerId?: SortOrder
    name?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    installments?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeScheduleSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    installments?: SortOrder
  }

  export type FeeScheduleScalarRelationFilter = {
    is?: FeeScheduleWhereInput
    isNot?: FeeScheduleWhereInput
  }

  export type FeeInstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    feeScheduleId?: SortOrder
    sequence?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeInstallmentAvgOrderByAggregateInput = {
    sequence?: SortOrder
    amount?: SortOrder
  }

  export type FeeInstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    feeScheduleId?: SortOrder
    sequence?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeInstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    feeScheduleId?: SortOrder
    sequence?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeInstallmentSumOrderByAggregateInput = {
    sequence?: SortOrder
    amount?: SortOrder
  }

  export type FeeInstallmentNullableScalarRelationFilter = {
    is?: FeeInstallmentWhereInput | null
    isNot?: FeeInstallmentWhereInput | null
  }

  export type StudentPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    feeInstallmentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    gatewayData?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StudentPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    feeInstallmentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    feeInstallmentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentPlanCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    feeScheduleId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentPlanAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type PaymentPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    feeScheduleId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentPlanMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    feeScheduleId?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentPlanSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AIAgentCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    specialization?: SortOrder
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAgentAvgOrderByAggregateInput = {
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
  }

  export type AIAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    specialization?: SortOrder
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAgentMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    personality?: SortOrder
    specialization?: SortOrder
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAgentSumOrderByAggregateInput = {
    maxTokensPerCall?: SortOrder
    temperature?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AIAgentScalarRelationFilter = {
    is?: AIAgentWhereInput
    isNot?: AIAgentWhereInput
  }

  export type AIMessageListRelationFilter = {
    every?: AIMessageWhereInput
    some?: AIMessageWhereInput
    none?: AIMessageWhereInput
  }

  export type AIMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type AIConversationAvgOrderByAggregateInput = {
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type AIConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type AIConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    sessionId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type AIConversationSumOrderByAggregateInput = {
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type AIConversationScalarRelationFilter = {
    is?: AIConversationWhereInput
    isNot?: AIConversationWhereInput
  }

  export type AIMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokens?: SortOrder
    createdAt?: SortOrder
  }

  export type AIMessageAvgOrderByAggregateInput = {
    tokens?: SortOrder
  }

  export type AIMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokens?: SortOrder
    createdAt?: SortOrder
  }

  export type AIMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokens?: SortOrder
    createdAt?: SortOrder
  }

  export type AIMessageSumOrderByAggregateInput = {
    tokens?: SortOrder
  }

  export type AIUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    classroomId?: SortOrder
    promptSummary?: SortOrder
    responseSummary?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    cost?: SortOrder
  }

  export type AIUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    classroomId?: SortOrder
    promptSummary?: SortOrder
    responseSummary?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    classroomId?: SortOrder
    promptSummary?: SortOrder
    responseSummary?: SortOrder
    tokensUsed?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    cost?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    meta?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    pushSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    pushSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    pushSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    targetRoles?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type DataBackupCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    storageUrl?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type DataBackupAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type DataBackupMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    storageUrl?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type DataBackupMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    storageUrl?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type DataBackupSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    body?: SortOrder
    metadata?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    body?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    body?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogListRelationFilter = {
    every?: ApiUsageLogWhereInput
    some?: ApiUsageLogWhereInput
    none?: ApiUsageLogWhereInput
  }

  export type ApiKeyRotationListRelationFilter = {
    every?: ApiKeyRotationWhereInput
    some?: ApiKeyRotationWhereInput
    none?: ApiKeyRotationWhereInput
  }

  export type ApiUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyRotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiClientCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientType?: SortOrder
    apiKeyHash?: SortOrder
    scopes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiClientMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientType?: SortOrder
    apiKeyHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiClientMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientType?: SortOrder
    apiKeyHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiClientScalarRelationFilter = {
    is?: ApiClientWhereInput
    isNot?: ApiClientWhereInput
  }

  export type ApiUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    latencyMs?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    latencyMs?: SortOrder
  }

  export type ApiUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    latencyMs?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    latencyMs?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    latencyMs?: SortOrder
  }

  export type ApiScopeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ApiScopeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ApiScopeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookScalarRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    response?: SortOrder
    attempt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    attempt?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    attempt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    status?: SortOrder
    attempt?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    attempt?: SortOrder
  }

  export type ApiKeyRotationCountOrderByAggregateInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    keyHash?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeyRotationMaxOrderByAggregateInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    keyHash?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeyRotationMinOrderByAggregateInput = {
    id?: SortOrder
    apiClientId?: SortOrder
    keyHash?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DashboardConfigCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardConfigMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    specialties?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionLogCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    userId?: SortOrder
    module?: SortOrder
    action?: SortOrder
    data?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    userId?: SortOrder
    module?: SortOrder
    action?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionLogMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    userId?: SortOrder
    module?: SortOrder
    action?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionCreateNestedManyWithoutPlanInput = {
    create?: XOR<InstitutionCreateWithoutPlanInput, InstitutionUncheckedCreateWithoutPlanInput> | InstitutionCreateWithoutPlanInput[] | InstitutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutPlanInput | InstitutionCreateOrConnectWithoutPlanInput[]
    createMany?: InstitutionCreateManyPlanInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type InstitutionSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutPlanInput, InstitutionSubscriptionUncheckedCreateWithoutPlanInput> | InstitutionSubscriptionCreateWithoutPlanInput[] | InstitutionSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutPlanInput | InstitutionSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: InstitutionSubscriptionCreateManyPlanInputEnvelope
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
  }

  export type InstitutionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<InstitutionCreateWithoutPlanInput, InstitutionUncheckedCreateWithoutPlanInput> | InstitutionCreateWithoutPlanInput[] | InstitutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutPlanInput | InstitutionCreateOrConnectWithoutPlanInput[]
    createMany?: InstitutionCreateManyPlanInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type InstitutionSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutPlanInput, InstitutionSubscriptionUncheckedCreateWithoutPlanInput> | InstitutionSubscriptionCreateWithoutPlanInput[] | InstitutionSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutPlanInput | InstitutionSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: InstitutionSubscriptionCreateManyPlanInputEnvelope
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type InstitutionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<InstitutionCreateWithoutPlanInput, InstitutionUncheckedCreateWithoutPlanInput> | InstitutionCreateWithoutPlanInput[] | InstitutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutPlanInput | InstitutionCreateOrConnectWithoutPlanInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutPlanInput | InstitutionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: InstitutionCreateManyPlanInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutPlanInput | InstitutionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutPlanInput | InstitutionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type InstitutionSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutPlanInput, InstitutionSubscriptionUncheckedCreateWithoutPlanInput> | InstitutionSubscriptionCreateWithoutPlanInput[] | InstitutionSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutPlanInput | InstitutionSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: InstitutionSubscriptionUpsertWithWhereUniqueWithoutPlanInput | InstitutionSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: InstitutionSubscriptionCreateManyPlanInputEnvelope
    set?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    disconnect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    delete?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    update?: InstitutionSubscriptionUpdateWithWhereUniqueWithoutPlanInput | InstitutionSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: InstitutionSubscriptionUpdateManyWithWhereWithoutPlanInput | InstitutionSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: InstitutionSubscriptionScalarWhereInput | InstitutionSubscriptionScalarWhereInput[]
  }

  export type InstitutionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<InstitutionCreateWithoutPlanInput, InstitutionUncheckedCreateWithoutPlanInput> | InstitutionCreateWithoutPlanInput[] | InstitutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutPlanInput | InstitutionCreateOrConnectWithoutPlanInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutPlanInput | InstitutionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: InstitutionCreateManyPlanInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutPlanInput | InstitutionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutPlanInput | InstitutionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type InstitutionSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutPlanInput, InstitutionSubscriptionUncheckedCreateWithoutPlanInput> | InstitutionSubscriptionCreateWithoutPlanInput[] | InstitutionSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutPlanInput | InstitutionSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: InstitutionSubscriptionUpsertWithWhereUniqueWithoutPlanInput | InstitutionSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: InstitutionSubscriptionCreateManyPlanInputEnvelope
    set?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    disconnect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    delete?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    update?: InstitutionSubscriptionUpdateWithWhereUniqueWithoutPlanInput | InstitutionSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: InstitutionSubscriptionUpdateManyWithWhereWithoutPlanInput | InstitutionSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: InstitutionSubscriptionScalarWhereInput | InstitutionSubscriptionScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutInstitutionsInput = {
    create?: XOR<PlanCreateWithoutInstitutionsInput, PlanUncheckedCreateWithoutInstitutionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutInstitutionsInput
    connect?: PlanWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<UserCreateWithoutInstitutionInput, UserUncheckedCreateWithoutInstitutionInput> | UserCreateWithoutInstitutionInput[] | UserUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInstitutionInput | UserCreateOrConnectWithoutInstitutionInput[]
    createMany?: UserCreateManyInstitutionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<RoleCreateWithoutInstitutionInput, RoleUncheckedCreateWithoutInstitutionInput> | RoleCreateWithoutInstitutionInput[] | RoleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutInstitutionInput | RoleCreateOrConnectWithoutInstitutionInput[]
    createMany?: RoleCreateManyInstitutionInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type CareerCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<CareerCreateWithoutInstitutionInput, CareerUncheckedCreateWithoutInstitutionInput> | CareerCreateWithoutInstitutionInput[] | CareerUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutInstitutionInput | CareerCreateOrConnectWithoutInstitutionInput[]
    createMany?: CareerCreateManyInstitutionInputEnvelope
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
  }

  export type InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutInstitutionInput, InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput> | InstitutionSubscriptionCreateWithoutInstitutionInput[] | InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput | InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput[]
    createMany?: InstitutionSubscriptionCreateManyInstitutionInputEnvelope
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
  }

  export type InstitutionPaymentCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InstitutionPaymentCreateWithoutInstitutionInput, InstitutionPaymentUncheckedCreateWithoutInstitutionInput> | InstitutionPaymentCreateWithoutInstitutionInput[] | InstitutionPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutInstitutionInput | InstitutionPaymentCreateOrConnectWithoutInstitutionInput[]
    createMany?: InstitutionPaymentCreateManyInstitutionInputEnvelope
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
  }

  export type InstitutionLogCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InstitutionLogCreateWithoutInstitutionInput, InstitutionLogUncheckedCreateWithoutInstitutionInput> | InstitutionLogCreateWithoutInstitutionInput[] | InstitutionLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutInstitutionInput | InstitutionLogCreateOrConnectWithoutInstitutionInput[]
    createMany?: InstitutionLogCreateManyInstitutionInputEnvelope
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
  }

  export type AIUsageLogCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AIUsageLogCreateWithoutInstitutionInput, AIUsageLogUncheckedCreateWithoutInstitutionInput> | AIUsageLogCreateWithoutInstitutionInput[] | AIUsageLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutInstitutionInput | AIUsageLogCreateOrConnectWithoutInstitutionInput[]
    createMany?: AIUsageLogCreateManyInstitutionInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type TemplateCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<TemplateCreateWithoutInstitutionInput, TemplateUncheckedCreateWithoutInstitutionInput> | TemplateCreateWithoutInstitutionInput[] | TemplateUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstitutionInput | TemplateCreateOrConnectWithoutInstitutionInput[]
    createMany?: TemplateCreateManyInstitutionInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<IntegrationCreateWithoutInstitutionInput, IntegrationUncheckedCreateWithoutInstitutionInput> | IntegrationCreateWithoutInstitutionInput[] | IntegrationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutInstitutionInput | IntegrationCreateOrConnectWithoutInstitutionInput[]
    createMany?: IntegrationCreateManyInstitutionInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type ApiClientCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ApiClientCreateWithoutInstitutionInput, ApiClientUncheckedCreateWithoutInstitutionInput> | ApiClientCreateWithoutInstitutionInput[] | ApiClientUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ApiClientCreateOrConnectWithoutInstitutionInput | ApiClientCreateOrConnectWithoutInstitutionInput[]
    createMany?: ApiClientCreateManyInstitutionInputEnvelope
    connect?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AnnouncementCreateWithoutInstitutionInput, AnnouncementUncheckedCreateWithoutInstitutionInput> | AnnouncementCreateWithoutInstitutionInput[] | AnnouncementUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstitutionInput | AnnouncementCreateOrConnectWithoutInstitutionInput[]
    createMany?: AnnouncementCreateManyInstitutionInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type DataBackupCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<DataBackupCreateWithoutInstitutionInput, DataBackupUncheckedCreateWithoutInstitutionInput> | DataBackupCreateWithoutInstitutionInput[] | DataBackupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutInstitutionInput | DataBackupCreateOrConnectWithoutInstitutionInput[]
    createMany?: DataBackupCreateManyInstitutionInputEnvelope
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
  }

  export type FeeScheduleCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<FeeScheduleCreateWithoutInstitutionInput, FeeScheduleUncheckedCreateWithoutInstitutionInput> | FeeScheduleCreateWithoutInstitutionInput[] | FeeScheduleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutInstitutionInput | FeeScheduleCreateOrConnectWithoutInstitutionInput[]
    createMany?: FeeScheduleCreateManyInstitutionInputEnvelope
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
  }

  export type ABACPolicyCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ABACPolicyCreateWithoutInstitutionInput, ABACPolicyUncheckedCreateWithoutInstitutionInput> | ABACPolicyCreateWithoutInstitutionInput[] | ABACPolicyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ABACPolicyCreateOrConnectWithoutInstitutionInput | ABACPolicyCreateOrConnectWithoutInstitutionInput[]
    createMany?: ABACPolicyCreateManyInstitutionInputEnvelope
    connect?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TutorProfileCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<TutorProfileCreateWithoutInstitutionInput, TutorProfileUncheckedCreateWithoutInstitutionInput> | TutorProfileCreateWithoutInstitutionInput[] | TutorProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TutorProfileCreateOrConnectWithoutInstitutionInput | TutorProfileCreateOrConnectWithoutInstitutionInput[]
    createMany?: TutorProfileCreateManyInstitutionInputEnvelope
    connect?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
  }

  export type StudentPaymentCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<StudentPaymentCreateWithoutInstitutionInput, StudentPaymentUncheckedCreateWithoutInstitutionInput> | StudentPaymentCreateWithoutInstitutionInput[] | StudentPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutInstitutionInput | StudentPaymentCreateOrConnectWithoutInstitutionInput[]
    createMany?: StudentPaymentCreateManyInstitutionInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type AIAgentCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AIAgentCreateWithoutInstitutionInput, AIAgentUncheckedCreateWithoutInstitutionInput> | AIAgentCreateWithoutInstitutionInput[] | AIAgentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIAgentCreateOrConnectWithoutInstitutionInput | AIAgentCreateOrConnectWithoutInstitutionInput[]
    createMany?: AIAgentCreateManyInstitutionInputEnvelope
    connect?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<WebhookCreateWithoutInstitutionInput, WebhookUncheckedCreateWithoutInstitutionInput> | WebhookCreateWithoutInstitutionInput[] | WebhookUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutInstitutionInput | WebhookCreateOrConnectWithoutInstitutionInput[]
    createMany?: WebhookCreateManyInstitutionInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<UserCreateWithoutInstitutionInput, UserUncheckedCreateWithoutInstitutionInput> | UserCreateWithoutInstitutionInput[] | UserUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInstitutionInput | UserCreateOrConnectWithoutInstitutionInput[]
    createMany?: UserCreateManyInstitutionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<RoleCreateWithoutInstitutionInput, RoleUncheckedCreateWithoutInstitutionInput> | RoleCreateWithoutInstitutionInput[] | RoleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutInstitutionInput | RoleCreateOrConnectWithoutInstitutionInput[]
    createMany?: RoleCreateManyInstitutionInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type CareerUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<CareerCreateWithoutInstitutionInput, CareerUncheckedCreateWithoutInstitutionInput> | CareerCreateWithoutInstitutionInput[] | CareerUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutInstitutionInput | CareerCreateOrConnectWithoutInstitutionInput[]
    createMany?: CareerCreateManyInstitutionInputEnvelope
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
  }

  export type InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutInstitutionInput, InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput> | InstitutionSubscriptionCreateWithoutInstitutionInput[] | InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput | InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput[]
    createMany?: InstitutionSubscriptionCreateManyInstitutionInputEnvelope
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
  }

  export type InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InstitutionPaymentCreateWithoutInstitutionInput, InstitutionPaymentUncheckedCreateWithoutInstitutionInput> | InstitutionPaymentCreateWithoutInstitutionInput[] | InstitutionPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutInstitutionInput | InstitutionPaymentCreateOrConnectWithoutInstitutionInput[]
    createMany?: InstitutionPaymentCreateManyInstitutionInputEnvelope
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
  }

  export type InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InstitutionLogCreateWithoutInstitutionInput, InstitutionLogUncheckedCreateWithoutInstitutionInput> | InstitutionLogCreateWithoutInstitutionInput[] | InstitutionLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutInstitutionInput | InstitutionLogCreateOrConnectWithoutInstitutionInput[]
    createMany?: InstitutionLogCreateManyInstitutionInputEnvelope
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
  }

  export type AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AIUsageLogCreateWithoutInstitutionInput, AIUsageLogUncheckedCreateWithoutInstitutionInput> | AIUsageLogCreateWithoutInstitutionInput[] | AIUsageLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutInstitutionInput | AIUsageLogCreateOrConnectWithoutInstitutionInput[]
    createMany?: AIUsageLogCreateManyInstitutionInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type TemplateUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<TemplateCreateWithoutInstitutionInput, TemplateUncheckedCreateWithoutInstitutionInput> | TemplateCreateWithoutInstitutionInput[] | TemplateUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstitutionInput | TemplateCreateOrConnectWithoutInstitutionInput[]
    createMany?: TemplateCreateManyInstitutionInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<IntegrationCreateWithoutInstitutionInput, IntegrationUncheckedCreateWithoutInstitutionInput> | IntegrationCreateWithoutInstitutionInput[] | IntegrationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutInstitutionInput | IntegrationCreateOrConnectWithoutInstitutionInput[]
    createMany?: IntegrationCreateManyInstitutionInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type ApiClientUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ApiClientCreateWithoutInstitutionInput, ApiClientUncheckedCreateWithoutInstitutionInput> | ApiClientCreateWithoutInstitutionInput[] | ApiClientUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ApiClientCreateOrConnectWithoutInstitutionInput | ApiClientCreateOrConnectWithoutInstitutionInput[]
    createMany?: ApiClientCreateManyInstitutionInputEnvelope
    connect?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AnnouncementCreateWithoutInstitutionInput, AnnouncementUncheckedCreateWithoutInstitutionInput> | AnnouncementCreateWithoutInstitutionInput[] | AnnouncementUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstitutionInput | AnnouncementCreateOrConnectWithoutInstitutionInput[]
    createMany?: AnnouncementCreateManyInstitutionInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type DataBackupUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<DataBackupCreateWithoutInstitutionInput, DataBackupUncheckedCreateWithoutInstitutionInput> | DataBackupCreateWithoutInstitutionInput[] | DataBackupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutInstitutionInput | DataBackupCreateOrConnectWithoutInstitutionInput[]
    createMany?: DataBackupCreateManyInstitutionInputEnvelope
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
  }

  export type FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<FeeScheduleCreateWithoutInstitutionInput, FeeScheduleUncheckedCreateWithoutInstitutionInput> | FeeScheduleCreateWithoutInstitutionInput[] | FeeScheduleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutInstitutionInput | FeeScheduleCreateOrConnectWithoutInstitutionInput[]
    createMany?: FeeScheduleCreateManyInstitutionInputEnvelope
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
  }

  export type ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ABACPolicyCreateWithoutInstitutionInput, ABACPolicyUncheckedCreateWithoutInstitutionInput> | ABACPolicyCreateWithoutInstitutionInput[] | ABACPolicyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ABACPolicyCreateOrConnectWithoutInstitutionInput | ABACPolicyCreateOrConnectWithoutInstitutionInput[]
    createMany?: ABACPolicyCreateManyInstitutionInputEnvelope
    connect?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<TutorProfileCreateWithoutInstitutionInput, TutorProfileUncheckedCreateWithoutInstitutionInput> | TutorProfileCreateWithoutInstitutionInput[] | TutorProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TutorProfileCreateOrConnectWithoutInstitutionInput | TutorProfileCreateOrConnectWithoutInstitutionInput[]
    createMany?: TutorProfileCreateManyInstitutionInputEnvelope
    connect?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
  }

  export type StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<StudentPaymentCreateWithoutInstitutionInput, StudentPaymentUncheckedCreateWithoutInstitutionInput> | StudentPaymentCreateWithoutInstitutionInput[] | StudentPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutInstitutionInput | StudentPaymentCreateOrConnectWithoutInstitutionInput[]
    createMany?: StudentPaymentCreateManyInstitutionInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type AIAgentUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AIAgentCreateWithoutInstitutionInput, AIAgentUncheckedCreateWithoutInstitutionInput> | AIAgentCreateWithoutInstitutionInput[] | AIAgentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIAgentCreateOrConnectWithoutInstitutionInput | AIAgentCreateOrConnectWithoutInstitutionInput[]
    createMany?: AIAgentCreateManyInstitutionInputEnvelope
    connect?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<WebhookCreateWithoutInstitutionInput, WebhookUncheckedCreateWithoutInstitutionInput> | WebhookCreateWithoutInstitutionInput[] | WebhookUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutInstitutionInput | WebhookCreateOrConnectWithoutInstitutionInput[]
    createMany?: WebhookCreateManyInstitutionInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type PlanUpdateOneWithoutInstitutionsNestedInput = {
    create?: XOR<PlanCreateWithoutInstitutionsInput, PlanUncheckedCreateWithoutInstitutionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutInstitutionsInput
    upsert?: PlanUpsertWithoutInstitutionsInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutInstitutionsInput, PlanUpdateWithoutInstitutionsInput>, PlanUncheckedUpdateWithoutInstitutionsInput>
  }

  export type UserUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<UserCreateWithoutInstitutionInput, UserUncheckedCreateWithoutInstitutionInput> | UserCreateWithoutInstitutionInput[] | UserUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInstitutionInput | UserCreateOrConnectWithoutInstitutionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutInstitutionInput | UserUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: UserCreateManyInstitutionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutInstitutionInput | UserUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutInstitutionInput | UserUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<RoleCreateWithoutInstitutionInput, RoleUncheckedCreateWithoutInstitutionInput> | RoleCreateWithoutInstitutionInput[] | RoleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutInstitutionInput | RoleCreateOrConnectWithoutInstitutionInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutInstitutionInput | RoleUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: RoleCreateManyInstitutionInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutInstitutionInput | RoleUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutInstitutionInput | RoleUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type CareerUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<CareerCreateWithoutInstitutionInput, CareerUncheckedCreateWithoutInstitutionInput> | CareerCreateWithoutInstitutionInput[] | CareerUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutInstitutionInput | CareerCreateOrConnectWithoutInstitutionInput[]
    upsert?: CareerUpsertWithWhereUniqueWithoutInstitutionInput | CareerUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: CareerCreateManyInstitutionInputEnvelope
    set?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    disconnect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    delete?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    update?: CareerUpdateWithWhereUniqueWithoutInstitutionInput | CareerUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: CareerUpdateManyWithWhereWithoutInstitutionInput | CareerUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: CareerScalarWhereInput | CareerScalarWhereInput[]
  }

  export type InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutInstitutionInput, InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput> | InstitutionSubscriptionCreateWithoutInstitutionInput[] | InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput | InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput[]
    upsert?: InstitutionSubscriptionUpsertWithWhereUniqueWithoutInstitutionInput | InstitutionSubscriptionUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InstitutionSubscriptionCreateManyInstitutionInputEnvelope
    set?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    disconnect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    delete?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    update?: InstitutionSubscriptionUpdateWithWhereUniqueWithoutInstitutionInput | InstitutionSubscriptionUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InstitutionSubscriptionUpdateManyWithWhereWithoutInstitutionInput | InstitutionSubscriptionUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InstitutionSubscriptionScalarWhereInput | InstitutionSubscriptionScalarWhereInput[]
  }

  export type InstitutionPaymentUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InstitutionPaymentCreateWithoutInstitutionInput, InstitutionPaymentUncheckedCreateWithoutInstitutionInput> | InstitutionPaymentCreateWithoutInstitutionInput[] | InstitutionPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutInstitutionInput | InstitutionPaymentCreateOrConnectWithoutInstitutionInput[]
    upsert?: InstitutionPaymentUpsertWithWhereUniqueWithoutInstitutionInput | InstitutionPaymentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InstitutionPaymentCreateManyInstitutionInputEnvelope
    set?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    disconnect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    delete?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    update?: InstitutionPaymentUpdateWithWhereUniqueWithoutInstitutionInput | InstitutionPaymentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InstitutionPaymentUpdateManyWithWhereWithoutInstitutionInput | InstitutionPaymentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InstitutionPaymentScalarWhereInput | InstitutionPaymentScalarWhereInput[]
  }

  export type InstitutionLogUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InstitutionLogCreateWithoutInstitutionInput, InstitutionLogUncheckedCreateWithoutInstitutionInput> | InstitutionLogCreateWithoutInstitutionInput[] | InstitutionLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutInstitutionInput | InstitutionLogCreateOrConnectWithoutInstitutionInput[]
    upsert?: InstitutionLogUpsertWithWhereUniqueWithoutInstitutionInput | InstitutionLogUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InstitutionLogCreateManyInstitutionInputEnvelope
    set?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    disconnect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    delete?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    update?: InstitutionLogUpdateWithWhereUniqueWithoutInstitutionInput | InstitutionLogUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InstitutionLogUpdateManyWithWhereWithoutInstitutionInput | InstitutionLogUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InstitutionLogScalarWhereInput | InstitutionLogScalarWhereInput[]
  }

  export type AIUsageLogUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutInstitutionInput, AIUsageLogUncheckedCreateWithoutInstitutionInput> | AIUsageLogCreateWithoutInstitutionInput[] | AIUsageLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutInstitutionInput | AIUsageLogCreateOrConnectWithoutInstitutionInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutInstitutionInput | AIUsageLogUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AIUsageLogCreateManyInstitutionInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutInstitutionInput | AIUsageLogUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutInstitutionInput | AIUsageLogUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type TemplateUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<TemplateCreateWithoutInstitutionInput, TemplateUncheckedCreateWithoutInstitutionInput> | TemplateCreateWithoutInstitutionInput[] | TemplateUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstitutionInput | TemplateCreateOrConnectWithoutInstitutionInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutInstitutionInput | TemplateUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: TemplateCreateManyInstitutionInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutInstitutionInput | TemplateUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutInstitutionInput | TemplateUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<IntegrationCreateWithoutInstitutionInput, IntegrationUncheckedCreateWithoutInstitutionInput> | IntegrationCreateWithoutInstitutionInput[] | IntegrationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutInstitutionInput | IntegrationCreateOrConnectWithoutInstitutionInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutInstitutionInput | IntegrationUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: IntegrationCreateManyInstitutionInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutInstitutionInput | IntegrationUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutInstitutionInput | IntegrationUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type ApiClientUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ApiClientCreateWithoutInstitutionInput, ApiClientUncheckedCreateWithoutInstitutionInput> | ApiClientCreateWithoutInstitutionInput[] | ApiClientUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ApiClientCreateOrConnectWithoutInstitutionInput | ApiClientCreateOrConnectWithoutInstitutionInput[]
    upsert?: ApiClientUpsertWithWhereUniqueWithoutInstitutionInput | ApiClientUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ApiClientCreateManyInstitutionInputEnvelope
    set?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    disconnect?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    delete?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    connect?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    update?: ApiClientUpdateWithWhereUniqueWithoutInstitutionInput | ApiClientUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ApiClientUpdateManyWithWhereWithoutInstitutionInput | ApiClientUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ApiClientScalarWhereInput | ApiClientScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AnnouncementCreateWithoutInstitutionInput, AnnouncementUncheckedCreateWithoutInstitutionInput> | AnnouncementCreateWithoutInstitutionInput[] | AnnouncementUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstitutionInput | AnnouncementCreateOrConnectWithoutInstitutionInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutInstitutionInput | AnnouncementUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AnnouncementCreateManyInstitutionInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutInstitutionInput | AnnouncementUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutInstitutionInput | AnnouncementUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type DataBackupUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<DataBackupCreateWithoutInstitutionInput, DataBackupUncheckedCreateWithoutInstitutionInput> | DataBackupCreateWithoutInstitutionInput[] | DataBackupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutInstitutionInput | DataBackupCreateOrConnectWithoutInstitutionInput[]
    upsert?: DataBackupUpsertWithWhereUniqueWithoutInstitutionInput | DataBackupUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: DataBackupCreateManyInstitutionInputEnvelope
    set?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    disconnect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    delete?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    update?: DataBackupUpdateWithWhereUniqueWithoutInstitutionInput | DataBackupUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: DataBackupUpdateManyWithWhereWithoutInstitutionInput | DataBackupUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: DataBackupScalarWhereInput | DataBackupScalarWhereInput[]
  }

  export type FeeScheduleUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<FeeScheduleCreateWithoutInstitutionInput, FeeScheduleUncheckedCreateWithoutInstitutionInput> | FeeScheduleCreateWithoutInstitutionInput[] | FeeScheduleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutInstitutionInput | FeeScheduleCreateOrConnectWithoutInstitutionInput[]
    upsert?: FeeScheduleUpsertWithWhereUniqueWithoutInstitutionInput | FeeScheduleUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: FeeScheduleCreateManyInstitutionInputEnvelope
    set?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    disconnect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    delete?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    update?: FeeScheduleUpdateWithWhereUniqueWithoutInstitutionInput | FeeScheduleUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: FeeScheduleUpdateManyWithWhereWithoutInstitutionInput | FeeScheduleUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: FeeScheduleScalarWhereInput | FeeScheduleScalarWhereInput[]
  }

  export type ABACPolicyUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ABACPolicyCreateWithoutInstitutionInput, ABACPolicyUncheckedCreateWithoutInstitutionInput> | ABACPolicyCreateWithoutInstitutionInput[] | ABACPolicyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ABACPolicyCreateOrConnectWithoutInstitutionInput | ABACPolicyCreateOrConnectWithoutInstitutionInput[]
    upsert?: ABACPolicyUpsertWithWhereUniqueWithoutInstitutionInput | ABACPolicyUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ABACPolicyCreateManyInstitutionInputEnvelope
    set?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    disconnect?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    delete?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    connect?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    update?: ABACPolicyUpdateWithWhereUniqueWithoutInstitutionInput | ABACPolicyUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ABACPolicyUpdateManyWithWhereWithoutInstitutionInput | ABACPolicyUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ABACPolicyScalarWhereInput | ABACPolicyScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutInstitutionInput | StudentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutInstitutionInput | StudentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutInstitutionInput | StudentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TutorProfileUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<TutorProfileCreateWithoutInstitutionInput, TutorProfileUncheckedCreateWithoutInstitutionInput> | TutorProfileCreateWithoutInstitutionInput[] | TutorProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TutorProfileCreateOrConnectWithoutInstitutionInput | TutorProfileCreateOrConnectWithoutInstitutionInput[]
    upsert?: TutorProfileUpsertWithWhereUniqueWithoutInstitutionInput | TutorProfileUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: TutorProfileCreateManyInstitutionInputEnvelope
    set?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    disconnect?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    delete?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    connect?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    update?: TutorProfileUpdateWithWhereUniqueWithoutInstitutionInput | TutorProfileUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: TutorProfileUpdateManyWithWhereWithoutInstitutionInput | TutorProfileUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: TutorProfileScalarWhereInput | TutorProfileScalarWhereInput[]
  }

  export type StudentPaymentUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutInstitutionInput, StudentPaymentUncheckedCreateWithoutInstitutionInput> | StudentPaymentCreateWithoutInstitutionInput[] | StudentPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutInstitutionInput | StudentPaymentCreateOrConnectWithoutInstitutionInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutInstitutionInput | StudentPaymentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: StudentPaymentCreateManyInstitutionInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutInstitutionInput | StudentPaymentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutInstitutionInput | StudentPaymentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type AIAgentUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AIAgentCreateWithoutInstitutionInput, AIAgentUncheckedCreateWithoutInstitutionInput> | AIAgentCreateWithoutInstitutionInput[] | AIAgentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIAgentCreateOrConnectWithoutInstitutionInput | AIAgentCreateOrConnectWithoutInstitutionInput[]
    upsert?: AIAgentUpsertWithWhereUniqueWithoutInstitutionInput | AIAgentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AIAgentCreateManyInstitutionInputEnvelope
    set?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    disconnect?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    delete?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    connect?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    update?: AIAgentUpdateWithWhereUniqueWithoutInstitutionInput | AIAgentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AIAgentUpdateManyWithWhereWithoutInstitutionInput | AIAgentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AIAgentScalarWhereInput | AIAgentScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<WebhookCreateWithoutInstitutionInput, WebhookUncheckedCreateWithoutInstitutionInput> | WebhookCreateWithoutInstitutionInput[] | WebhookUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutInstitutionInput | WebhookCreateOrConnectWithoutInstitutionInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutInstitutionInput | WebhookUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: WebhookCreateManyInstitutionInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutInstitutionInput | WebhookUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutInstitutionInput | WebhookUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<UserCreateWithoutInstitutionInput, UserUncheckedCreateWithoutInstitutionInput> | UserCreateWithoutInstitutionInput[] | UserUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInstitutionInput | UserCreateOrConnectWithoutInstitutionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutInstitutionInput | UserUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: UserCreateManyInstitutionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutInstitutionInput | UserUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutInstitutionInput | UserUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<RoleCreateWithoutInstitutionInput, RoleUncheckedCreateWithoutInstitutionInput> | RoleCreateWithoutInstitutionInput[] | RoleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutInstitutionInput | RoleCreateOrConnectWithoutInstitutionInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutInstitutionInput | RoleUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: RoleCreateManyInstitutionInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutInstitutionInput | RoleUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutInstitutionInput | RoleUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type CareerUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<CareerCreateWithoutInstitutionInput, CareerUncheckedCreateWithoutInstitutionInput> | CareerCreateWithoutInstitutionInput[] | CareerUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutInstitutionInput | CareerCreateOrConnectWithoutInstitutionInput[]
    upsert?: CareerUpsertWithWhereUniqueWithoutInstitutionInput | CareerUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: CareerCreateManyInstitutionInputEnvelope
    set?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    disconnect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    delete?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    update?: CareerUpdateWithWhereUniqueWithoutInstitutionInput | CareerUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: CareerUpdateManyWithWhereWithoutInstitutionInput | CareerUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: CareerScalarWhereInput | CareerScalarWhereInput[]
  }

  export type InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutInstitutionInput, InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput> | InstitutionSubscriptionCreateWithoutInstitutionInput[] | InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput | InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput[]
    upsert?: InstitutionSubscriptionUpsertWithWhereUniqueWithoutInstitutionInput | InstitutionSubscriptionUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InstitutionSubscriptionCreateManyInstitutionInputEnvelope
    set?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    disconnect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    delete?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    connect?: InstitutionSubscriptionWhereUniqueInput | InstitutionSubscriptionWhereUniqueInput[]
    update?: InstitutionSubscriptionUpdateWithWhereUniqueWithoutInstitutionInput | InstitutionSubscriptionUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InstitutionSubscriptionUpdateManyWithWhereWithoutInstitutionInput | InstitutionSubscriptionUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InstitutionSubscriptionScalarWhereInput | InstitutionSubscriptionScalarWhereInput[]
  }

  export type InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InstitutionPaymentCreateWithoutInstitutionInput, InstitutionPaymentUncheckedCreateWithoutInstitutionInput> | InstitutionPaymentCreateWithoutInstitutionInput[] | InstitutionPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutInstitutionInput | InstitutionPaymentCreateOrConnectWithoutInstitutionInput[]
    upsert?: InstitutionPaymentUpsertWithWhereUniqueWithoutInstitutionInput | InstitutionPaymentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InstitutionPaymentCreateManyInstitutionInputEnvelope
    set?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    disconnect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    delete?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    update?: InstitutionPaymentUpdateWithWhereUniqueWithoutInstitutionInput | InstitutionPaymentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InstitutionPaymentUpdateManyWithWhereWithoutInstitutionInput | InstitutionPaymentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InstitutionPaymentScalarWhereInput | InstitutionPaymentScalarWhereInput[]
  }

  export type InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InstitutionLogCreateWithoutInstitutionInput, InstitutionLogUncheckedCreateWithoutInstitutionInput> | InstitutionLogCreateWithoutInstitutionInput[] | InstitutionLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutInstitutionInput | InstitutionLogCreateOrConnectWithoutInstitutionInput[]
    upsert?: InstitutionLogUpsertWithWhereUniqueWithoutInstitutionInput | InstitutionLogUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InstitutionLogCreateManyInstitutionInputEnvelope
    set?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    disconnect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    delete?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    update?: InstitutionLogUpdateWithWhereUniqueWithoutInstitutionInput | InstitutionLogUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InstitutionLogUpdateManyWithWhereWithoutInstitutionInput | InstitutionLogUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InstitutionLogScalarWhereInput | InstitutionLogScalarWhereInput[]
  }

  export type AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutInstitutionInput, AIUsageLogUncheckedCreateWithoutInstitutionInput> | AIUsageLogCreateWithoutInstitutionInput[] | AIUsageLogUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutInstitutionInput | AIUsageLogCreateOrConnectWithoutInstitutionInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutInstitutionInput | AIUsageLogUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AIUsageLogCreateManyInstitutionInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutInstitutionInput | AIUsageLogUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutInstitutionInput | AIUsageLogUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type TemplateUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<TemplateCreateWithoutInstitutionInput, TemplateUncheckedCreateWithoutInstitutionInput> | TemplateCreateWithoutInstitutionInput[] | TemplateUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstitutionInput | TemplateCreateOrConnectWithoutInstitutionInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutInstitutionInput | TemplateUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: TemplateCreateManyInstitutionInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutInstitutionInput | TemplateUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutInstitutionInput | TemplateUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<IntegrationCreateWithoutInstitutionInput, IntegrationUncheckedCreateWithoutInstitutionInput> | IntegrationCreateWithoutInstitutionInput[] | IntegrationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutInstitutionInput | IntegrationCreateOrConnectWithoutInstitutionInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutInstitutionInput | IntegrationUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: IntegrationCreateManyInstitutionInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutInstitutionInput | IntegrationUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutInstitutionInput | IntegrationUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ApiClientCreateWithoutInstitutionInput, ApiClientUncheckedCreateWithoutInstitutionInput> | ApiClientCreateWithoutInstitutionInput[] | ApiClientUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ApiClientCreateOrConnectWithoutInstitutionInput | ApiClientCreateOrConnectWithoutInstitutionInput[]
    upsert?: ApiClientUpsertWithWhereUniqueWithoutInstitutionInput | ApiClientUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ApiClientCreateManyInstitutionInputEnvelope
    set?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    disconnect?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    delete?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    connect?: ApiClientWhereUniqueInput | ApiClientWhereUniqueInput[]
    update?: ApiClientUpdateWithWhereUniqueWithoutInstitutionInput | ApiClientUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ApiClientUpdateManyWithWhereWithoutInstitutionInput | ApiClientUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ApiClientScalarWhereInput | ApiClientScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AnnouncementCreateWithoutInstitutionInput, AnnouncementUncheckedCreateWithoutInstitutionInput> | AnnouncementCreateWithoutInstitutionInput[] | AnnouncementUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstitutionInput | AnnouncementCreateOrConnectWithoutInstitutionInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutInstitutionInput | AnnouncementUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AnnouncementCreateManyInstitutionInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutInstitutionInput | AnnouncementUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutInstitutionInput | AnnouncementUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<DataBackupCreateWithoutInstitutionInput, DataBackupUncheckedCreateWithoutInstitutionInput> | DataBackupCreateWithoutInstitutionInput[] | DataBackupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutInstitutionInput | DataBackupCreateOrConnectWithoutInstitutionInput[]
    upsert?: DataBackupUpsertWithWhereUniqueWithoutInstitutionInput | DataBackupUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: DataBackupCreateManyInstitutionInputEnvelope
    set?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    disconnect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    delete?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    update?: DataBackupUpdateWithWhereUniqueWithoutInstitutionInput | DataBackupUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: DataBackupUpdateManyWithWhereWithoutInstitutionInput | DataBackupUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: DataBackupScalarWhereInput | DataBackupScalarWhereInput[]
  }

  export type FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<FeeScheduleCreateWithoutInstitutionInput, FeeScheduleUncheckedCreateWithoutInstitutionInput> | FeeScheduleCreateWithoutInstitutionInput[] | FeeScheduleUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutInstitutionInput | FeeScheduleCreateOrConnectWithoutInstitutionInput[]
    upsert?: FeeScheduleUpsertWithWhereUniqueWithoutInstitutionInput | FeeScheduleUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: FeeScheduleCreateManyInstitutionInputEnvelope
    set?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    disconnect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    delete?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    update?: FeeScheduleUpdateWithWhereUniqueWithoutInstitutionInput | FeeScheduleUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: FeeScheduleUpdateManyWithWhereWithoutInstitutionInput | FeeScheduleUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: FeeScheduleScalarWhereInput | FeeScheduleScalarWhereInput[]
  }

  export type ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ABACPolicyCreateWithoutInstitutionInput, ABACPolicyUncheckedCreateWithoutInstitutionInput> | ABACPolicyCreateWithoutInstitutionInput[] | ABACPolicyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ABACPolicyCreateOrConnectWithoutInstitutionInput | ABACPolicyCreateOrConnectWithoutInstitutionInput[]
    upsert?: ABACPolicyUpsertWithWhereUniqueWithoutInstitutionInput | ABACPolicyUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ABACPolicyCreateManyInstitutionInputEnvelope
    set?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    disconnect?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    delete?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    connect?: ABACPolicyWhereUniqueInput | ABACPolicyWhereUniqueInput[]
    update?: ABACPolicyUpdateWithWhereUniqueWithoutInstitutionInput | ABACPolicyUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ABACPolicyUpdateManyWithWhereWithoutInstitutionInput | ABACPolicyUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ABACPolicyScalarWhereInput | ABACPolicyScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutInstitutionInput | StudentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutInstitutionInput | StudentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutInstitutionInput | StudentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<TutorProfileCreateWithoutInstitutionInput, TutorProfileUncheckedCreateWithoutInstitutionInput> | TutorProfileCreateWithoutInstitutionInput[] | TutorProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TutorProfileCreateOrConnectWithoutInstitutionInput | TutorProfileCreateOrConnectWithoutInstitutionInput[]
    upsert?: TutorProfileUpsertWithWhereUniqueWithoutInstitutionInput | TutorProfileUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: TutorProfileCreateManyInstitutionInputEnvelope
    set?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    disconnect?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    delete?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    connect?: TutorProfileWhereUniqueInput | TutorProfileWhereUniqueInput[]
    update?: TutorProfileUpdateWithWhereUniqueWithoutInstitutionInput | TutorProfileUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: TutorProfileUpdateManyWithWhereWithoutInstitutionInput | TutorProfileUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: TutorProfileScalarWhereInput | TutorProfileScalarWhereInput[]
  }

  export type StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutInstitutionInput, StudentPaymentUncheckedCreateWithoutInstitutionInput> | StudentPaymentCreateWithoutInstitutionInput[] | StudentPaymentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutInstitutionInput | StudentPaymentCreateOrConnectWithoutInstitutionInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutInstitutionInput | StudentPaymentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: StudentPaymentCreateManyInstitutionInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutInstitutionInput | StudentPaymentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutInstitutionInput | StudentPaymentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AIAgentCreateWithoutInstitutionInput, AIAgentUncheckedCreateWithoutInstitutionInput> | AIAgentCreateWithoutInstitutionInput[] | AIAgentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AIAgentCreateOrConnectWithoutInstitutionInput | AIAgentCreateOrConnectWithoutInstitutionInput[]
    upsert?: AIAgentUpsertWithWhereUniqueWithoutInstitutionInput | AIAgentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AIAgentCreateManyInstitutionInputEnvelope
    set?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    disconnect?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    delete?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    connect?: AIAgentWhereUniqueInput | AIAgentWhereUniqueInput[]
    update?: AIAgentUpdateWithWhereUniqueWithoutInstitutionInput | AIAgentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AIAgentUpdateManyWithWhereWithoutInstitutionInput | AIAgentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AIAgentScalarWhereInput | AIAgentScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<WebhookCreateWithoutInstitutionInput, WebhookUncheckedCreateWithoutInstitutionInput> | WebhookCreateWithoutInstitutionInput[] | WebhookUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutInstitutionInput | WebhookCreateOrConnectWithoutInstitutionInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutInstitutionInput | WebhookUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: WebhookCreateManyInstitutionInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutInstitutionInput | WebhookUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutInstitutionInput | WebhookUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type InstitutionCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<InstitutionCreateWithoutSubscriptionsInput, InstitutionUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutSubscriptionsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutInstitutionSubscriptionInput = {
    create?: XOR<PlanCreateWithoutInstitutionSubscriptionInput, PlanUncheckedCreateWithoutInstitutionSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutInstitutionSubscriptionInput
    connect?: PlanWhereUniqueInput
  }

  export type InstitutionPaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InstitutionPaymentCreateWithoutSubscriptionInput, InstitutionPaymentUncheckedCreateWithoutSubscriptionInput> | InstitutionPaymentCreateWithoutSubscriptionInput[] | InstitutionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutSubscriptionInput | InstitutionPaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InstitutionPaymentCreateManySubscriptionInputEnvelope
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
  }

  export type InstitutionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InstitutionPaymentCreateWithoutSubscriptionInput, InstitutionPaymentUncheckedCreateWithoutSubscriptionInput> | InstitutionPaymentCreateWithoutSubscriptionInput[] | InstitutionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutSubscriptionInput | InstitutionPaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InstitutionPaymentCreateManySubscriptionInputEnvelope
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type InstitutionUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<InstitutionCreateWithoutSubscriptionsInput, InstitutionUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutSubscriptionsInput
    upsert?: InstitutionUpsertWithoutSubscriptionsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutSubscriptionsInput, InstitutionUpdateWithoutSubscriptionsInput>, InstitutionUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateOneRequiredWithoutInstitutionSubscriptionNestedInput = {
    create?: XOR<PlanCreateWithoutInstitutionSubscriptionInput, PlanUncheckedCreateWithoutInstitutionSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutInstitutionSubscriptionInput
    upsert?: PlanUpsertWithoutInstitutionSubscriptionInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutInstitutionSubscriptionInput, PlanUpdateWithoutInstitutionSubscriptionInput>, PlanUncheckedUpdateWithoutInstitutionSubscriptionInput>
  }

  export type InstitutionPaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InstitutionPaymentCreateWithoutSubscriptionInput, InstitutionPaymentUncheckedCreateWithoutSubscriptionInput> | InstitutionPaymentCreateWithoutSubscriptionInput[] | InstitutionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutSubscriptionInput | InstitutionPaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InstitutionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput | InstitutionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InstitutionPaymentCreateManySubscriptionInputEnvelope
    set?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    disconnect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    delete?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    update?: InstitutionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput | InstitutionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InstitutionPaymentUpdateManyWithWhereWithoutSubscriptionInput | InstitutionPaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InstitutionPaymentScalarWhereInput | InstitutionPaymentScalarWhereInput[]
  }

  export type InstitutionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InstitutionPaymentCreateWithoutSubscriptionInput, InstitutionPaymentUncheckedCreateWithoutSubscriptionInput> | InstitutionPaymentCreateWithoutSubscriptionInput[] | InstitutionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InstitutionPaymentCreateOrConnectWithoutSubscriptionInput | InstitutionPaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InstitutionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput | InstitutionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InstitutionPaymentCreateManySubscriptionInputEnvelope
    set?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    disconnect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    delete?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    connect?: InstitutionPaymentWhereUniqueInput | InstitutionPaymentWhereUniqueInput[]
    update?: InstitutionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput | InstitutionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InstitutionPaymentUpdateManyWithWhereWithoutSubscriptionInput | InstitutionPaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InstitutionPaymentScalarWhereInput | InstitutionPaymentScalarWhereInput[]
  }

  export type InstitutionCreateNestedOneWithoutInstitutionPaymentsInput = {
    create?: XOR<InstitutionCreateWithoutInstitutionPaymentsInput, InstitutionUncheckedCreateWithoutInstitutionPaymentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutInstitutionPaymentsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type InstitutionSubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutPaymentsInput, InstitutionSubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: InstitutionSubscriptionWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type InstitutionUpdateOneRequiredWithoutInstitutionPaymentsNestedInput = {
    create?: XOR<InstitutionCreateWithoutInstitutionPaymentsInput, InstitutionUncheckedCreateWithoutInstitutionPaymentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutInstitutionPaymentsInput
    upsert?: InstitutionUpsertWithoutInstitutionPaymentsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutInstitutionPaymentsInput, InstitutionUpdateWithoutInstitutionPaymentsInput>, InstitutionUncheckedUpdateWithoutInstitutionPaymentsInput>
  }

  export type InstitutionSubscriptionUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InstitutionSubscriptionCreateWithoutPaymentsInput, InstitutionSubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstitutionSubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: InstitutionSubscriptionUpsertWithoutPaymentsInput
    disconnect?: InstitutionSubscriptionWhereInput | boolean
    delete?: InstitutionSubscriptionWhereInput | boolean
    connect?: InstitutionSubscriptionWhereUniqueInput
    update?: XOR<XOR<InstitutionSubscriptionUpdateToOneWithWhereWithoutPaymentsInput, InstitutionSubscriptionUpdateWithoutPaymentsInput>, InstitutionSubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstitutionCreateNestedOneWithoutUsersInput = {
    create?: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutUsersInput
    connect?: InstitutionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type TutorProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<TutorProfileCreateWithoutUserInput, TutorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorProfileCreateOrConnectWithoutUserInput
    connect?: TutorProfileWhereUniqueInput
  }

  export type DashboardConfigCreateNestedManyWithoutUserInput = {
    create?: XOR<DashboardConfigCreateWithoutUserInput, DashboardConfigUncheckedCreateWithoutUserInput> | DashboardConfigCreateWithoutUserInput[] | DashboardConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardConfigCreateOrConnectWithoutUserInput | DashboardConfigCreateOrConnectWithoutUserInput[]
    createMany?: DashboardConfigCreateManyUserInputEnvelope
    connect?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
  }

  export type AIUsageLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type InstitutionLogCreateNestedManyWithoutUserInput = {
    create?: XOR<InstitutionLogCreateWithoutUserInput, InstitutionLogUncheckedCreateWithoutUserInput> | InstitutionLogCreateWithoutUserInput[] | InstitutionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutUserInput | InstitutionLogCreateOrConnectWithoutUserInput[]
    createMany?: InstitutionLogCreateManyUserInputEnvelope
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CareerCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CareerCreateWithoutCreatedByInput, CareerUncheckedCreateWithoutCreatedByInput> | CareerCreateWithoutCreatedByInput[] | CareerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutCreatedByInput | CareerCreateOrConnectWithoutCreatedByInput[]
    createMany?: CareerCreateManyCreatedByInputEnvelope
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonPlanCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LessonPlanCreateWithoutCreatedByInput, LessonPlanUncheckedCreateWithoutCreatedByInput> | LessonPlanCreateWithoutCreatedByInput[] | LessonPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutCreatedByInput | LessonPlanCreateOrConnectWithoutCreatedByInput[]
    createMany?: LessonPlanCreateManyCreatedByInputEnvelope
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
  }

  export type VirtualClassroomCreateNestedManyWithoutTeacherInput = {
    create?: XOR<VirtualClassroomCreateWithoutTeacherInput, VirtualClassroomUncheckedCreateWithoutTeacherInput> | VirtualClassroomCreateWithoutTeacherInput[] | VirtualClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutTeacherInput | VirtualClassroomCreateOrConnectWithoutTeacherInput[]
    createMany?: VirtualClassroomCreateManyTeacherInputEnvelope
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GradeCreateWithoutCreatedByInput, GradeUncheckedCreateWithoutCreatedByInput> | GradeCreateWithoutCreatedByInput[] | GradeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCreatedByInput | GradeCreateOrConnectWithoutCreatedByInput[]
    createMany?: GradeCreateManyCreatedByInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutNotedByInput = {
    create?: XOR<AttendanceCreateWithoutNotedByInput, AttendanceUncheckedCreateWithoutNotedByInput> | AttendanceCreateWithoutNotedByInput[] | AttendanceUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutNotedByInput | AttendanceCreateOrConnectWithoutNotedByInput[]
    createMany?: AttendanceCreateManyNotedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type DisciplinaryRecordCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutRecordedByInput, DisciplinaryRecordUncheckedCreateWithoutRecordedByInput> | DisciplinaryRecordCreateWithoutRecordedByInput[] | DisciplinaryRecordUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutRecordedByInput | DisciplinaryRecordCreateOrConnectWithoutRecordedByInput[]
    createMany?: DisciplinaryRecordCreateManyRecordedByInputEnvelope
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutIssuedByInput = {
    create?: XOR<CertificateCreateWithoutIssuedByInput, CertificateUncheckedCreateWithoutIssuedByInput> | CertificateCreateWithoutIssuedByInput[] | CertificateUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutIssuedByInput | CertificateCreateOrConnectWithoutIssuedByInput[]
    createMany?: CertificateCreateManyIssuedByInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type AIConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type DataBackupCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DataBackupCreateWithoutCreatedByInput, DataBackupUncheckedCreateWithoutCreatedByInput> | DataBackupCreateWithoutCreatedByInput[] | DataBackupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutCreatedByInput | DataBackupCreateOrConnectWithoutCreatedByInput[]
    createMany?: DataBackupCreateManyCreatedByInputEnvelope
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
  }

  export type TemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TemplateCreateWithoutCreatedByInput, TemplateUncheckedCreateWithoutCreatedByInput> | TemplateCreateWithoutCreatedByInput[] | TemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCreatedByInput | TemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: TemplateCreateManyCreatedByInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type TutorProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TutorProfileCreateWithoutUserInput, TutorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorProfileCreateOrConnectWithoutUserInput
    connect?: TutorProfileWhereUniqueInput
  }

  export type DashboardConfigUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DashboardConfigCreateWithoutUserInput, DashboardConfigUncheckedCreateWithoutUserInput> | DashboardConfigCreateWithoutUserInput[] | DashboardConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardConfigCreateOrConnectWithoutUserInput | DashboardConfigCreateOrConnectWithoutUserInput[]
    createMany?: DashboardConfigCreateManyUserInputEnvelope
    connect?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
  }

  export type AIUsageLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type InstitutionLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstitutionLogCreateWithoutUserInput, InstitutionLogUncheckedCreateWithoutUserInput> | InstitutionLogCreateWithoutUserInput[] | InstitutionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutUserInput | InstitutionLogCreateOrConnectWithoutUserInput[]
    createMany?: InstitutionLogCreateManyUserInputEnvelope
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CareerUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CareerCreateWithoutCreatedByInput, CareerUncheckedCreateWithoutCreatedByInput> | CareerCreateWithoutCreatedByInput[] | CareerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutCreatedByInput | CareerCreateOrConnectWithoutCreatedByInput[]
    createMany?: CareerCreateManyCreatedByInputEnvelope
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LessonPlanCreateWithoutCreatedByInput, LessonPlanUncheckedCreateWithoutCreatedByInput> | LessonPlanCreateWithoutCreatedByInput[] | LessonPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutCreatedByInput | LessonPlanCreateOrConnectWithoutCreatedByInput[]
    createMany?: LessonPlanCreateManyCreatedByInputEnvelope
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
  }

  export type VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<VirtualClassroomCreateWithoutTeacherInput, VirtualClassroomUncheckedCreateWithoutTeacherInput> | VirtualClassroomCreateWithoutTeacherInput[] | VirtualClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutTeacherInput | VirtualClassroomCreateOrConnectWithoutTeacherInput[]
    createMany?: VirtualClassroomCreateManyTeacherInputEnvelope
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GradeCreateWithoutCreatedByInput, GradeUncheckedCreateWithoutCreatedByInput> | GradeCreateWithoutCreatedByInput[] | GradeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCreatedByInput | GradeCreateOrConnectWithoutCreatedByInput[]
    createMany?: GradeCreateManyCreatedByInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutNotedByInput = {
    create?: XOR<AttendanceCreateWithoutNotedByInput, AttendanceUncheckedCreateWithoutNotedByInput> | AttendanceCreateWithoutNotedByInput[] | AttendanceUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutNotedByInput | AttendanceCreateOrConnectWithoutNotedByInput[]
    createMany?: AttendanceCreateManyNotedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutRecordedByInput, DisciplinaryRecordUncheckedCreateWithoutRecordedByInput> | DisciplinaryRecordCreateWithoutRecordedByInput[] | DisciplinaryRecordUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutRecordedByInput | DisciplinaryRecordCreateOrConnectWithoutRecordedByInput[]
    createMany?: DisciplinaryRecordCreateManyRecordedByInputEnvelope
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutIssuedByInput = {
    create?: XOR<CertificateCreateWithoutIssuedByInput, CertificateUncheckedCreateWithoutIssuedByInput> | CertificateCreateWithoutIssuedByInput[] | CertificateUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutIssuedByInput | CertificateCreateOrConnectWithoutIssuedByInput[]
    createMany?: CertificateCreateManyIssuedByInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type AIConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type DataBackupUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DataBackupCreateWithoutCreatedByInput, DataBackupUncheckedCreateWithoutCreatedByInput> | DataBackupCreateWithoutCreatedByInput[] | DataBackupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutCreatedByInput | DataBackupCreateOrConnectWithoutCreatedByInput[]
    createMany?: DataBackupCreateManyCreatedByInputEnvelope
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
  }

  export type TemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TemplateCreateWithoutCreatedByInput, TemplateUncheckedCreateWithoutCreatedByInput> | TemplateCreateWithoutCreatedByInput[] | TemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCreatedByInput | TemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: TemplateCreateManyCreatedByInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type InstitutionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutUsersInput
    upsert?: InstitutionUpsertWithoutUsersInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutUsersInput, InstitutionUpdateWithoutUsersInput>, InstitutionUncheckedUpdateWithoutUsersInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TutorProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<TutorProfileCreateWithoutUserInput, TutorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorProfileCreateOrConnectWithoutUserInput
    upsert?: TutorProfileUpsertWithoutUserInput
    disconnect?: TutorProfileWhereInput | boolean
    delete?: TutorProfileWhereInput | boolean
    connect?: TutorProfileWhereUniqueInput
    update?: XOR<XOR<TutorProfileUpdateToOneWithWhereWithoutUserInput, TutorProfileUpdateWithoutUserInput>, TutorProfileUncheckedUpdateWithoutUserInput>
  }

  export type DashboardConfigUpdateManyWithoutUserNestedInput = {
    create?: XOR<DashboardConfigCreateWithoutUserInput, DashboardConfigUncheckedCreateWithoutUserInput> | DashboardConfigCreateWithoutUserInput[] | DashboardConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardConfigCreateOrConnectWithoutUserInput | DashboardConfigCreateOrConnectWithoutUserInput[]
    upsert?: DashboardConfigUpsertWithWhereUniqueWithoutUserInput | DashboardConfigUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DashboardConfigCreateManyUserInputEnvelope
    set?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    disconnect?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    delete?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    connect?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    update?: DashboardConfigUpdateWithWhereUniqueWithoutUserInput | DashboardConfigUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DashboardConfigUpdateManyWithWhereWithoutUserInput | DashboardConfigUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DashboardConfigScalarWhereInput | DashboardConfigScalarWhereInput[]
  }

  export type AIUsageLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutUserInput | AIUsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutUserInput | AIUsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutUserInput | AIUsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type InstitutionLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstitutionLogCreateWithoutUserInput, InstitutionLogUncheckedCreateWithoutUserInput> | InstitutionLogCreateWithoutUserInput[] | InstitutionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutUserInput | InstitutionLogCreateOrConnectWithoutUserInput[]
    upsert?: InstitutionLogUpsertWithWhereUniqueWithoutUserInput | InstitutionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstitutionLogCreateManyUserInputEnvelope
    set?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    disconnect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    delete?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    update?: InstitutionLogUpdateWithWhereUniqueWithoutUserInput | InstitutionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstitutionLogUpdateManyWithWhereWithoutUserInput | InstitutionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstitutionLogScalarWhereInput | InstitutionLogScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CareerUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CareerCreateWithoutCreatedByInput, CareerUncheckedCreateWithoutCreatedByInput> | CareerCreateWithoutCreatedByInput[] | CareerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutCreatedByInput | CareerCreateOrConnectWithoutCreatedByInput[]
    upsert?: CareerUpsertWithWhereUniqueWithoutCreatedByInput | CareerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CareerCreateManyCreatedByInputEnvelope
    set?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    disconnect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    delete?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    update?: CareerUpdateWithWhereUniqueWithoutCreatedByInput | CareerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CareerUpdateManyWithWhereWithoutCreatedByInput | CareerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CareerScalarWhereInput | CareerScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatedByInput | CourseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatedByInput | CourseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatedByInput | CourseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LessonPlanUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LessonPlanCreateWithoutCreatedByInput, LessonPlanUncheckedCreateWithoutCreatedByInput> | LessonPlanCreateWithoutCreatedByInput[] | LessonPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutCreatedByInput | LessonPlanCreateOrConnectWithoutCreatedByInput[]
    upsert?: LessonPlanUpsertWithWhereUniqueWithoutCreatedByInput | LessonPlanUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LessonPlanCreateManyCreatedByInputEnvelope
    set?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    disconnect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    delete?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    update?: LessonPlanUpdateWithWhereUniqueWithoutCreatedByInput | LessonPlanUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LessonPlanUpdateManyWithWhereWithoutCreatedByInput | LessonPlanUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
  }

  export type VirtualClassroomUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutTeacherInput, VirtualClassroomUncheckedCreateWithoutTeacherInput> | VirtualClassroomCreateWithoutTeacherInput[] | VirtualClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutTeacherInput | VirtualClassroomCreateOrConnectWithoutTeacherInput[]
    upsert?: VirtualClassroomUpsertWithWhereUniqueWithoutTeacherInput | VirtualClassroomUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: VirtualClassroomCreateManyTeacherInputEnvelope
    set?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    disconnect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    delete?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    update?: VirtualClassroomUpdateWithWhereUniqueWithoutTeacherInput | VirtualClassroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: VirtualClassroomUpdateManyWithWhereWithoutTeacherInput | VirtualClassroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GradeCreateWithoutCreatedByInput, GradeUncheckedCreateWithoutCreatedByInput> | GradeCreateWithoutCreatedByInput[] | GradeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCreatedByInput | GradeCreateOrConnectWithoutCreatedByInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutCreatedByInput | GradeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GradeCreateManyCreatedByInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutCreatedByInput | GradeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutCreatedByInput | GradeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutNotedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutNotedByInput, AttendanceUncheckedCreateWithoutNotedByInput> | AttendanceCreateWithoutNotedByInput[] | AttendanceUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutNotedByInput | AttendanceCreateOrConnectWithoutNotedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutNotedByInput | AttendanceUpsertWithWhereUniqueWithoutNotedByInput[]
    createMany?: AttendanceCreateManyNotedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutNotedByInput | AttendanceUpdateWithWhereUniqueWithoutNotedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutNotedByInput | AttendanceUpdateManyWithWhereWithoutNotedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutRecordedByInput, DisciplinaryRecordUncheckedCreateWithoutRecordedByInput> | DisciplinaryRecordCreateWithoutRecordedByInput[] | DisciplinaryRecordUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutRecordedByInput | DisciplinaryRecordCreateOrConnectWithoutRecordedByInput[]
    upsert?: DisciplinaryRecordUpsertWithWhereUniqueWithoutRecordedByInput | DisciplinaryRecordUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: DisciplinaryRecordCreateManyRecordedByInputEnvelope
    set?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    disconnect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    delete?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    update?: DisciplinaryRecordUpdateWithWhereUniqueWithoutRecordedByInput | DisciplinaryRecordUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: DisciplinaryRecordUpdateManyWithWhereWithoutRecordedByInput | DisciplinaryRecordUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutIssuedByNestedInput = {
    create?: XOR<CertificateCreateWithoutIssuedByInput, CertificateUncheckedCreateWithoutIssuedByInput> | CertificateCreateWithoutIssuedByInput[] | CertificateUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutIssuedByInput | CertificateCreateOrConnectWithoutIssuedByInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutIssuedByInput | CertificateUpsertWithWhereUniqueWithoutIssuedByInput[]
    createMany?: CertificateCreateManyIssuedByInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutIssuedByInput | CertificateUpdateWithWhereUniqueWithoutIssuedByInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutIssuedByInput | CertificateUpdateManyWithWhereWithoutIssuedByInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type AIConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutUserInput | AIConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutUserInput | AIConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutUserInput | AIConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput | AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput | AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCreatedByInput | AnnouncementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type DataBackupUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DataBackupCreateWithoutCreatedByInput, DataBackupUncheckedCreateWithoutCreatedByInput> | DataBackupCreateWithoutCreatedByInput[] | DataBackupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutCreatedByInput | DataBackupCreateOrConnectWithoutCreatedByInput[]
    upsert?: DataBackupUpsertWithWhereUniqueWithoutCreatedByInput | DataBackupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DataBackupCreateManyCreatedByInputEnvelope
    set?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    disconnect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    delete?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    update?: DataBackupUpdateWithWhereUniqueWithoutCreatedByInput | DataBackupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DataBackupUpdateManyWithWhereWithoutCreatedByInput | DataBackupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DataBackupScalarWhereInput | DataBackupScalarWhereInput[]
  }

  export type TemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TemplateCreateWithoutCreatedByInput, TemplateUncheckedCreateWithoutCreatedByInput> | TemplateCreateWithoutCreatedByInput[] | TemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCreatedByInput | TemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutCreatedByInput | TemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TemplateCreateManyCreatedByInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutCreatedByInput | TemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutCreatedByInput | TemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TutorProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TutorProfileCreateWithoutUserInput, TutorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TutorProfileCreateOrConnectWithoutUserInput
    upsert?: TutorProfileUpsertWithoutUserInput
    disconnect?: TutorProfileWhereInput | boolean
    delete?: TutorProfileWhereInput | boolean
    connect?: TutorProfileWhereUniqueInput
    update?: XOR<XOR<TutorProfileUpdateToOneWithWhereWithoutUserInput, TutorProfileUpdateWithoutUserInput>, TutorProfileUncheckedUpdateWithoutUserInput>
  }

  export type DashboardConfigUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DashboardConfigCreateWithoutUserInput, DashboardConfigUncheckedCreateWithoutUserInput> | DashboardConfigCreateWithoutUserInput[] | DashboardConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardConfigCreateOrConnectWithoutUserInput | DashboardConfigCreateOrConnectWithoutUserInput[]
    upsert?: DashboardConfigUpsertWithWhereUniqueWithoutUserInput | DashboardConfigUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DashboardConfigCreateManyUserInputEnvelope
    set?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    disconnect?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    delete?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    connect?: DashboardConfigWhereUniqueInput | DashboardConfigWhereUniqueInput[]
    update?: DashboardConfigUpdateWithWhereUniqueWithoutUserInput | DashboardConfigUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DashboardConfigUpdateManyWithWhereWithoutUserInput | DashboardConfigUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DashboardConfigScalarWhereInput | DashboardConfigScalarWhereInput[]
  }

  export type AIUsageLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutUserInput | AIUsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutUserInput | AIUsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutUserInput | AIUsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type InstitutionLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstitutionLogCreateWithoutUserInput, InstitutionLogUncheckedCreateWithoutUserInput> | InstitutionLogCreateWithoutUserInput[] | InstitutionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstitutionLogCreateOrConnectWithoutUserInput | InstitutionLogCreateOrConnectWithoutUserInput[]
    upsert?: InstitutionLogUpsertWithWhereUniqueWithoutUserInput | InstitutionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstitutionLogCreateManyUserInputEnvelope
    set?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    disconnect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    delete?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    connect?: InstitutionLogWhereUniqueInput | InstitutionLogWhereUniqueInput[]
    update?: InstitutionLogUpdateWithWhereUniqueWithoutUserInput | InstitutionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstitutionLogUpdateManyWithWhereWithoutUserInput | InstitutionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstitutionLogScalarWhereInput | InstitutionLogScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CareerUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CareerCreateWithoutCreatedByInput, CareerUncheckedCreateWithoutCreatedByInput> | CareerCreateWithoutCreatedByInput[] | CareerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutCreatedByInput | CareerCreateOrConnectWithoutCreatedByInput[]
    upsert?: CareerUpsertWithWhereUniqueWithoutCreatedByInput | CareerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CareerCreateManyCreatedByInputEnvelope
    set?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    disconnect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    delete?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    update?: CareerUpdateWithWhereUniqueWithoutCreatedByInput | CareerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CareerUpdateManyWithWhereWithoutCreatedByInput | CareerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CareerScalarWhereInput | CareerScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput> | CourseCreateWithoutCreatedByInput[] | CourseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatedByInput | CourseCreateOrConnectWithoutCreatedByInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatedByInput | CourseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CourseCreateManyCreatedByInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatedByInput | CourseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatedByInput | CourseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LessonPlanCreateWithoutCreatedByInput, LessonPlanUncheckedCreateWithoutCreatedByInput> | LessonPlanCreateWithoutCreatedByInput[] | LessonPlanUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutCreatedByInput | LessonPlanCreateOrConnectWithoutCreatedByInput[]
    upsert?: LessonPlanUpsertWithWhereUniqueWithoutCreatedByInput | LessonPlanUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LessonPlanCreateManyCreatedByInputEnvelope
    set?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    disconnect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    delete?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    update?: LessonPlanUpdateWithWhereUniqueWithoutCreatedByInput | LessonPlanUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LessonPlanUpdateManyWithWhereWithoutCreatedByInput | LessonPlanUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
  }

  export type VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutTeacherInput, VirtualClassroomUncheckedCreateWithoutTeacherInput> | VirtualClassroomCreateWithoutTeacherInput[] | VirtualClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutTeacherInput | VirtualClassroomCreateOrConnectWithoutTeacherInput[]
    upsert?: VirtualClassroomUpsertWithWhereUniqueWithoutTeacherInput | VirtualClassroomUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: VirtualClassroomCreateManyTeacherInputEnvelope
    set?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    disconnect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    delete?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    update?: VirtualClassroomUpdateWithWhereUniqueWithoutTeacherInput | VirtualClassroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: VirtualClassroomUpdateManyWithWhereWithoutTeacherInput | VirtualClassroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GradeCreateWithoutCreatedByInput, GradeUncheckedCreateWithoutCreatedByInput> | GradeCreateWithoutCreatedByInput[] | GradeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCreatedByInput | GradeCreateOrConnectWithoutCreatedByInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutCreatedByInput | GradeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GradeCreateManyCreatedByInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutCreatedByInput | GradeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutCreatedByInput | GradeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutNotedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutNotedByInput, AttendanceUncheckedCreateWithoutNotedByInput> | AttendanceCreateWithoutNotedByInput[] | AttendanceUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutNotedByInput | AttendanceCreateOrConnectWithoutNotedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutNotedByInput | AttendanceUpsertWithWhereUniqueWithoutNotedByInput[]
    createMany?: AttendanceCreateManyNotedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutNotedByInput | AttendanceUpdateWithWhereUniqueWithoutNotedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutNotedByInput | AttendanceUpdateManyWithWhereWithoutNotedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutRecordedByInput, DisciplinaryRecordUncheckedCreateWithoutRecordedByInput> | DisciplinaryRecordCreateWithoutRecordedByInput[] | DisciplinaryRecordUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutRecordedByInput | DisciplinaryRecordCreateOrConnectWithoutRecordedByInput[]
    upsert?: DisciplinaryRecordUpsertWithWhereUniqueWithoutRecordedByInput | DisciplinaryRecordUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: DisciplinaryRecordCreateManyRecordedByInputEnvelope
    set?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    disconnect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    delete?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    update?: DisciplinaryRecordUpdateWithWhereUniqueWithoutRecordedByInput | DisciplinaryRecordUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: DisciplinaryRecordUpdateManyWithWhereWithoutRecordedByInput | DisciplinaryRecordUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutIssuedByNestedInput = {
    create?: XOR<CertificateCreateWithoutIssuedByInput, CertificateUncheckedCreateWithoutIssuedByInput> | CertificateCreateWithoutIssuedByInput[] | CertificateUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutIssuedByInput | CertificateCreateOrConnectWithoutIssuedByInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutIssuedByInput | CertificateUpsertWithWhereUniqueWithoutIssuedByInput[]
    createMany?: CertificateCreateManyIssuedByInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutIssuedByInput | CertificateUpdateWithWhereUniqueWithoutIssuedByInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutIssuedByInput | CertificateUpdateManyWithWhereWithoutIssuedByInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type AIConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput> | AIConversationCreateWithoutUserInput[] | AIConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutUserInput | AIConversationCreateOrConnectWithoutUserInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutUserInput | AIConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIConversationCreateManyUserInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutUserInput | AIConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutUserInput | AIConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput | AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput | AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCreatedByInput | AnnouncementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DataBackupCreateWithoutCreatedByInput, DataBackupUncheckedCreateWithoutCreatedByInput> | DataBackupCreateWithoutCreatedByInput[] | DataBackupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DataBackupCreateOrConnectWithoutCreatedByInput | DataBackupCreateOrConnectWithoutCreatedByInput[]
    upsert?: DataBackupUpsertWithWhereUniqueWithoutCreatedByInput | DataBackupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DataBackupCreateManyCreatedByInputEnvelope
    set?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    disconnect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    delete?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    connect?: DataBackupWhereUniqueInput | DataBackupWhereUniqueInput[]
    update?: DataBackupUpdateWithWhereUniqueWithoutCreatedByInput | DataBackupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DataBackupUpdateManyWithWhereWithoutCreatedByInput | DataBackupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DataBackupScalarWhereInput | DataBackupScalarWhereInput[]
  }

  export type TemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TemplateCreateWithoutCreatedByInput, TemplateUncheckedCreateWithoutCreatedByInput> | TemplateCreateWithoutCreatedByInput[] | TemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCreatedByInput | TemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutCreatedByInput | TemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TemplateCreateManyCreatedByInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutCreatedByInput | TemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutCreatedByInput | TemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type InstitutionCreateNestedOneWithoutRolesInput = {
    create?: XOR<InstitutionCreateWithoutRolesInput, InstitutionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutRolesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName
  }

  export type InstitutionUpdateOneWithoutRolesNestedInput = {
    create?: XOR<InstitutionCreateWithoutRolesInput, InstitutionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutRolesInput
    upsert?: InstitutionUpsertWithoutRolesInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutRolesInput, InstitutionUpdateWithoutRolesInput>, InstitutionUncheckedUpdateWithoutRolesInput>
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type InstitutionCreateNestedOneWithoutABACPolicyInput = {
    create?: XOR<InstitutionCreateWithoutABACPolicyInput, InstitutionUncheckedCreateWithoutABACPolicyInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutABACPolicyInput
    connect?: InstitutionWhereUniqueInput
  }

  export type EnumPolicyEffectFieldUpdateOperationsInput = {
    set?: $Enums.PolicyEffect
  }

  export type InstitutionUpdateOneWithoutABACPolicyNestedInput = {
    create?: XOR<InstitutionCreateWithoutABACPolicyInput, InstitutionUncheckedCreateWithoutABACPolicyInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutABACPolicyInput
    upsert?: InstitutionUpsertWithoutABACPolicyInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutABACPolicyInput, InstitutionUpdateWithoutABACPolicyInput>, InstitutionUncheckedUpdateWithoutABACPolicyInput>
  }

  export type InstitutionCreateNestedOneWithoutCareersInput = {
    create?: XOR<InstitutionCreateWithoutCareersInput, InstitutionUncheckedCreateWithoutCareersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutCareersInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCareersInput = {
    create?: XOR<UserCreateWithoutCareersInput, UserUncheckedCreateWithoutCareersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCareersInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutCareerInput = {
    create?: XOR<CourseCreateWithoutCareerInput, CourseUncheckedCreateWithoutCareerInput> | CourseCreateWithoutCareerInput[] | CourseUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCareerInput | CourseCreateOrConnectWithoutCareerInput[]
    createMany?: CourseCreateManyCareerInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type AcademicPeriodCreateNestedManyWithoutCareerInput = {
    create?: XOR<AcademicPeriodCreateWithoutCareerInput, AcademicPeriodUncheckedCreateWithoutCareerInput> | AcademicPeriodCreateWithoutCareerInput[] | AcademicPeriodUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCareerInput | AcademicPeriodCreateOrConnectWithoutCareerInput[]
    createMany?: AcademicPeriodCreateManyCareerInputEnvelope
    connect?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutCareerInput = {
    create?: XOR<StudentCreateWithoutCareerInput, StudentUncheckedCreateWithoutCareerInput> | StudentCreateWithoutCareerInput[] | StudentUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCareerInput | StudentCreateOrConnectWithoutCareerInput[]
    createMany?: StudentCreateManyCareerInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FeeScheduleCreateNestedManyWithoutCareerInput = {
    create?: XOR<FeeScheduleCreateWithoutCareerInput, FeeScheduleUncheckedCreateWithoutCareerInput> | FeeScheduleCreateWithoutCareerInput[] | FeeScheduleUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutCareerInput | FeeScheduleCreateOrConnectWithoutCareerInput[]
    createMany?: FeeScheduleCreateManyCareerInputEnvelope
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<CourseCreateWithoutCareerInput, CourseUncheckedCreateWithoutCareerInput> | CourseCreateWithoutCareerInput[] | CourseUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCareerInput | CourseCreateOrConnectWithoutCareerInput[]
    createMany?: CourseCreateManyCareerInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<AcademicPeriodCreateWithoutCareerInput, AcademicPeriodUncheckedCreateWithoutCareerInput> | AcademicPeriodCreateWithoutCareerInput[] | AcademicPeriodUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCareerInput | AcademicPeriodCreateOrConnectWithoutCareerInput[]
    createMany?: AcademicPeriodCreateManyCareerInputEnvelope
    connect?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<StudentCreateWithoutCareerInput, StudentUncheckedCreateWithoutCareerInput> | StudentCreateWithoutCareerInput[] | StudentUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCareerInput | StudentCreateOrConnectWithoutCareerInput[]
    createMany?: StudentCreateManyCareerInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FeeScheduleUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<FeeScheduleCreateWithoutCareerInput, FeeScheduleUncheckedCreateWithoutCareerInput> | FeeScheduleCreateWithoutCareerInput[] | FeeScheduleUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutCareerInput | FeeScheduleCreateOrConnectWithoutCareerInput[]
    createMany?: FeeScheduleCreateManyCareerInputEnvelope
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
  }

  export type EnumLevelTypeFieldUpdateOperationsInput = {
    set?: $Enums.LevelType
  }

  export type InstitutionUpdateOneRequiredWithoutCareersNestedInput = {
    create?: XOR<InstitutionCreateWithoutCareersInput, InstitutionUncheckedCreateWithoutCareersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutCareersInput
    upsert?: InstitutionUpsertWithoutCareersInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutCareersInput, InstitutionUpdateWithoutCareersInput>, InstitutionUncheckedUpdateWithoutCareersInput>
  }

  export type UserUpdateOneWithoutCareersNestedInput = {
    create?: XOR<UserCreateWithoutCareersInput, UserUncheckedCreateWithoutCareersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCareersInput
    upsert?: UserUpsertWithoutCareersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCareersInput, UserUpdateWithoutCareersInput>, UserUncheckedUpdateWithoutCareersInput>
  }

  export type CourseUpdateManyWithoutCareerNestedInput = {
    create?: XOR<CourseCreateWithoutCareerInput, CourseUncheckedCreateWithoutCareerInput> | CourseCreateWithoutCareerInput[] | CourseUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCareerInput | CourseCreateOrConnectWithoutCareerInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCareerInput | CourseUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: CourseCreateManyCareerInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCareerInput | CourseUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCareerInput | CourseUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type AcademicPeriodUpdateManyWithoutCareerNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutCareerInput, AcademicPeriodUncheckedCreateWithoutCareerInput> | AcademicPeriodCreateWithoutCareerInput[] | AcademicPeriodUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCareerInput | AcademicPeriodCreateOrConnectWithoutCareerInput[]
    upsert?: AcademicPeriodUpsertWithWhereUniqueWithoutCareerInput | AcademicPeriodUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: AcademicPeriodCreateManyCareerInputEnvelope
    set?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    disconnect?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    delete?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    connect?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    update?: AcademicPeriodUpdateWithWhereUniqueWithoutCareerInput | AcademicPeriodUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: AcademicPeriodUpdateManyWithWhereWithoutCareerInput | AcademicPeriodUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: AcademicPeriodScalarWhereInput | AcademicPeriodScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutCareerNestedInput = {
    create?: XOR<StudentCreateWithoutCareerInput, StudentUncheckedCreateWithoutCareerInput> | StudentCreateWithoutCareerInput[] | StudentUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCareerInput | StudentCreateOrConnectWithoutCareerInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCareerInput | StudentUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: StudentCreateManyCareerInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCareerInput | StudentUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCareerInput | StudentUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FeeScheduleUpdateManyWithoutCareerNestedInput = {
    create?: XOR<FeeScheduleCreateWithoutCareerInput, FeeScheduleUncheckedCreateWithoutCareerInput> | FeeScheduleCreateWithoutCareerInput[] | FeeScheduleUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutCareerInput | FeeScheduleCreateOrConnectWithoutCareerInput[]
    upsert?: FeeScheduleUpsertWithWhereUniqueWithoutCareerInput | FeeScheduleUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: FeeScheduleCreateManyCareerInputEnvelope
    set?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    disconnect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    delete?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    update?: FeeScheduleUpdateWithWhereUniqueWithoutCareerInput | FeeScheduleUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: FeeScheduleUpdateManyWithWhereWithoutCareerInput | FeeScheduleUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: FeeScheduleScalarWhereInput | FeeScheduleScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<CourseCreateWithoutCareerInput, CourseUncheckedCreateWithoutCareerInput> | CourseCreateWithoutCareerInput[] | CourseUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCareerInput | CourseCreateOrConnectWithoutCareerInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCareerInput | CourseUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: CourseCreateManyCareerInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCareerInput | CourseUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCareerInput | CourseUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutCareerInput, AcademicPeriodUncheckedCreateWithoutCareerInput> | AcademicPeriodCreateWithoutCareerInput[] | AcademicPeriodUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCareerInput | AcademicPeriodCreateOrConnectWithoutCareerInput[]
    upsert?: AcademicPeriodUpsertWithWhereUniqueWithoutCareerInput | AcademicPeriodUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: AcademicPeriodCreateManyCareerInputEnvelope
    set?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    disconnect?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    delete?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    connect?: AcademicPeriodWhereUniqueInput | AcademicPeriodWhereUniqueInput[]
    update?: AcademicPeriodUpdateWithWhereUniqueWithoutCareerInput | AcademicPeriodUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: AcademicPeriodUpdateManyWithWhereWithoutCareerInput | AcademicPeriodUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: AcademicPeriodScalarWhereInput | AcademicPeriodScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<StudentCreateWithoutCareerInput, StudentUncheckedCreateWithoutCareerInput> | StudentCreateWithoutCareerInput[] | StudentUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCareerInput | StudentCreateOrConnectWithoutCareerInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCareerInput | StudentUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: StudentCreateManyCareerInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCareerInput | StudentUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCareerInput | StudentUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<FeeScheduleCreateWithoutCareerInput, FeeScheduleUncheckedCreateWithoutCareerInput> | FeeScheduleCreateWithoutCareerInput[] | FeeScheduleUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutCareerInput | FeeScheduleCreateOrConnectWithoutCareerInput[]
    upsert?: FeeScheduleUpsertWithWhereUniqueWithoutCareerInput | FeeScheduleUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: FeeScheduleCreateManyCareerInputEnvelope
    set?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    disconnect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    delete?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    connect?: FeeScheduleWhereUniqueInput | FeeScheduleWhereUniqueInput[]
    update?: FeeScheduleUpdateWithWhereUniqueWithoutCareerInput | FeeScheduleUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: FeeScheduleUpdateManyWithWhereWithoutCareerInput | FeeScheduleUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: FeeScheduleScalarWhereInput | FeeScheduleScalarWhereInput[]
  }

  export type CareerCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<CareerCreateWithoutPeriodsInput, CareerUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutPeriodsInput
    connect?: CareerWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<CourseCreateWithoutAcademicPeriodInput, CourseUncheckedCreateWithoutAcademicPeriodInput> | CourseCreateWithoutAcademicPeriodInput[] | CourseUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicPeriodInput | CourseCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: CourseCreateManyAcademicPeriodInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<EnrollmentCreateWithoutAcademicPeriodInput, EnrollmentUncheckedCreateWithoutAcademicPeriodInput> | EnrollmentCreateWithoutAcademicPeriodInput[] | EnrollmentUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutAcademicPeriodInput | EnrollmentCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: EnrollmentCreateManyAcademicPeriodInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<CourseCreateWithoutAcademicPeriodInput, CourseUncheckedCreateWithoutAcademicPeriodInput> | CourseCreateWithoutAcademicPeriodInput[] | CourseUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicPeriodInput | CourseCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: CourseCreateManyAcademicPeriodInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<EnrollmentCreateWithoutAcademicPeriodInput, EnrollmentUncheckedCreateWithoutAcademicPeriodInput> | EnrollmentCreateWithoutAcademicPeriodInput[] | EnrollmentUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutAcademicPeriodInput | EnrollmentCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: EnrollmentCreateManyAcademicPeriodInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CareerUpdateOneRequiredWithoutPeriodsNestedInput = {
    create?: XOR<CareerCreateWithoutPeriodsInput, CareerUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutPeriodsInput
    upsert?: CareerUpsertWithoutPeriodsInput
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutPeriodsInput, CareerUpdateWithoutPeriodsInput>, CareerUncheckedUpdateWithoutPeriodsInput>
  }

  export type CourseUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<CourseCreateWithoutAcademicPeriodInput, CourseUncheckedCreateWithoutAcademicPeriodInput> | CourseCreateWithoutAcademicPeriodInput[] | CourseUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicPeriodInput | CourseCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAcademicPeriodInput | CourseUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: CourseCreateManyAcademicPeriodInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAcademicPeriodInput | CourseUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAcademicPeriodInput | CourseUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<EnrollmentCreateWithoutAcademicPeriodInput, EnrollmentUncheckedCreateWithoutAcademicPeriodInput> | EnrollmentCreateWithoutAcademicPeriodInput[] | EnrollmentUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutAcademicPeriodInput | EnrollmentCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutAcademicPeriodInput | EnrollmentUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: EnrollmentCreateManyAcademicPeriodInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutAcademicPeriodInput | EnrollmentUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutAcademicPeriodInput | EnrollmentUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<CourseCreateWithoutAcademicPeriodInput, CourseUncheckedCreateWithoutAcademicPeriodInput> | CourseCreateWithoutAcademicPeriodInput[] | CourseUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicPeriodInput | CourseCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAcademicPeriodInput | CourseUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: CourseCreateManyAcademicPeriodInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAcademicPeriodInput | CourseUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAcademicPeriodInput | CourseUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<EnrollmentCreateWithoutAcademicPeriodInput, EnrollmentUncheckedCreateWithoutAcademicPeriodInput> | EnrollmentCreateWithoutAcademicPeriodInput[] | EnrollmentUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutAcademicPeriodInput | EnrollmentCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutAcademicPeriodInput | EnrollmentUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: EnrollmentCreateManyAcademicPeriodInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutAcademicPeriodInput | EnrollmentUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutAcademicPeriodInput | EnrollmentUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CareerCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CareerCreateWithoutCoursesInput, CareerUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CareerCreateOrConnectWithoutCoursesInput
    connect?: CareerWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutCoursesInput = {
    create?: XOR<AcademicPeriodCreateWithoutCoursesInput, AcademicPeriodUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCoursesInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutCourseInput = {
    create?: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput> | SubjectCreateWithoutCourseInput[] | SubjectUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseInput | SubjectCreateOrConnectWithoutCourseInput[]
    createMany?: SubjectCreateManyCourseInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput> | SubjectCreateWithoutCourseInput[] | SubjectUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseInput | SubjectCreateOrConnectWithoutCourseInput[]
    createMany?: SubjectCreateManyCourseInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CareerUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CareerCreateWithoutCoursesInput, CareerUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CareerCreateOrConnectWithoutCoursesInput
    upsert?: CareerUpsertWithoutCoursesInput
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutCoursesInput, CareerUpdateWithoutCoursesInput>, CareerUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademicPeriodUpdateOneWithoutCoursesNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutCoursesInput, AcademicPeriodUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCoursesInput
    upsert?: AcademicPeriodUpsertWithoutCoursesInput
    disconnect?: AcademicPeriodWhereInput | boolean
    delete?: AcademicPeriodWhereInput | boolean
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutCoursesInput, AcademicPeriodUpdateWithoutCoursesInput>, AcademicPeriodUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateOneWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type SubjectUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput> | SubjectCreateWithoutCourseInput[] | SubjectUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseInput | SubjectCreateOrConnectWithoutCourseInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutCourseInput | SubjectUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SubjectCreateManyCourseInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutCourseInput | SubjectUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutCourseInput | SubjectUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput> | SubjectCreateWithoutCourseInput[] | SubjectUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseInput | SubjectCreateOrConnectWithoutCourseInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutCourseInput | SubjectUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SubjectCreateManyCourseInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutCourseInput | SubjectUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutCourseInput | SubjectUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<CourseCreateWithoutSubjectsInput, CourseUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSubjectsInput
    connect?: CourseWhereUniqueInput
  }

  export type VirtualClassroomCreateNestedManyWithoutSubjectInput = {
    create?: XOR<VirtualClassroomCreateWithoutSubjectInput, VirtualClassroomUncheckedCreateWithoutSubjectInput> | VirtualClassroomCreateWithoutSubjectInput[] | VirtualClassroomUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutSubjectInput | VirtualClassroomCreateOrConnectWithoutSubjectInput[]
    createMany?: VirtualClassroomCreateManySubjectInputEnvelope
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
  }

  export type StudentSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type DisciplinaryRecordCreateNestedManyWithoutSubjectInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutSubjectInput, DisciplinaryRecordUncheckedCreateWithoutSubjectInput> | DisciplinaryRecordCreateWithoutSubjectInput[] | DisciplinaryRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutSubjectInput | DisciplinaryRecordCreateOrConnectWithoutSubjectInput[]
    createMany?: DisciplinaryRecordCreateManySubjectInputEnvelope
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CertificateCreateWithoutSubjectInput, CertificateUncheckedCreateWithoutSubjectInput> | CertificateCreateWithoutSubjectInput[] | CertificateUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSubjectInput | CertificateCreateOrConnectWithoutSubjectInput[]
    createMany?: CertificateCreateManySubjectInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type VirtualClassroomUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<VirtualClassroomCreateWithoutSubjectInput, VirtualClassroomUncheckedCreateWithoutSubjectInput> | VirtualClassroomCreateWithoutSubjectInput[] | VirtualClassroomUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutSubjectInput | VirtualClassroomCreateOrConnectWithoutSubjectInput[]
    createMany?: VirtualClassroomCreateManySubjectInputEnvelope
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
  }

  export type StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type DisciplinaryRecordUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutSubjectInput, DisciplinaryRecordUncheckedCreateWithoutSubjectInput> | DisciplinaryRecordCreateWithoutSubjectInput[] | DisciplinaryRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutSubjectInput | DisciplinaryRecordCreateOrConnectWithoutSubjectInput[]
    createMany?: DisciplinaryRecordCreateManySubjectInputEnvelope
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CertificateCreateWithoutSubjectInput, CertificateUncheckedCreateWithoutSubjectInput> | CertificateCreateWithoutSubjectInput[] | CertificateUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSubjectInput | CertificateCreateOrConnectWithoutSubjectInput[]
    createMany?: CertificateCreateManySubjectInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<CourseCreateWithoutSubjectsInput, CourseUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSubjectsInput
    upsert?: CourseUpsertWithoutSubjectsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSubjectsInput, CourseUpdateWithoutSubjectsInput>, CourseUncheckedUpdateWithoutSubjectsInput>
  }

  export type VirtualClassroomUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutSubjectInput, VirtualClassroomUncheckedCreateWithoutSubjectInput> | VirtualClassroomCreateWithoutSubjectInput[] | VirtualClassroomUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutSubjectInput | VirtualClassroomCreateOrConnectWithoutSubjectInput[]
    upsert?: VirtualClassroomUpsertWithWhereUniqueWithoutSubjectInput | VirtualClassroomUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: VirtualClassroomCreateManySubjectInputEnvelope
    set?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    disconnect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    delete?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    update?: VirtualClassroomUpdateWithWhereUniqueWithoutSubjectInput | VirtualClassroomUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: VirtualClassroomUpdateManyWithWhereWithoutSubjectInput | VirtualClassroomUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
  }

  export type StudentSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput | StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput | StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutSubjectInput | StudentSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type DisciplinaryRecordUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutSubjectInput, DisciplinaryRecordUncheckedCreateWithoutSubjectInput> | DisciplinaryRecordCreateWithoutSubjectInput[] | DisciplinaryRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutSubjectInput | DisciplinaryRecordCreateOrConnectWithoutSubjectInput[]
    upsert?: DisciplinaryRecordUpsertWithWhereUniqueWithoutSubjectInput | DisciplinaryRecordUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: DisciplinaryRecordCreateManySubjectInputEnvelope
    set?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    disconnect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    delete?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    update?: DisciplinaryRecordUpdateWithWhereUniqueWithoutSubjectInput | DisciplinaryRecordUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: DisciplinaryRecordUpdateManyWithWhereWithoutSubjectInput | DisciplinaryRecordUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CertificateCreateWithoutSubjectInput, CertificateUncheckedCreateWithoutSubjectInput> | CertificateCreateWithoutSubjectInput[] | CertificateUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSubjectInput | CertificateCreateOrConnectWithoutSubjectInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutSubjectInput | CertificateUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CertificateCreateManySubjectInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutSubjectInput | CertificateUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutSubjectInput | CertificateUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type VirtualClassroomUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutSubjectInput, VirtualClassroomUncheckedCreateWithoutSubjectInput> | VirtualClassroomCreateWithoutSubjectInput[] | VirtualClassroomUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutSubjectInput | VirtualClassroomCreateOrConnectWithoutSubjectInput[]
    upsert?: VirtualClassroomUpsertWithWhereUniqueWithoutSubjectInput | VirtualClassroomUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: VirtualClassroomCreateManySubjectInputEnvelope
    set?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    disconnect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    delete?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    update?: VirtualClassroomUpdateWithWhereUniqueWithoutSubjectInput | VirtualClassroomUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: VirtualClassroomUpdateManyWithWhereWithoutSubjectInput | VirtualClassroomUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
  }

  export type StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput> | StudentSubjectCreateWithoutSubjectInput[] | StudentSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutSubjectInput | StudentSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput | StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: StudentSubjectCreateManySubjectInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput | StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutSubjectInput | StudentSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type DisciplinaryRecordUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutSubjectInput, DisciplinaryRecordUncheckedCreateWithoutSubjectInput> | DisciplinaryRecordCreateWithoutSubjectInput[] | DisciplinaryRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutSubjectInput | DisciplinaryRecordCreateOrConnectWithoutSubjectInput[]
    upsert?: DisciplinaryRecordUpsertWithWhereUniqueWithoutSubjectInput | DisciplinaryRecordUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: DisciplinaryRecordCreateManySubjectInputEnvelope
    set?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    disconnect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    delete?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    update?: DisciplinaryRecordUpdateWithWhereUniqueWithoutSubjectInput | DisciplinaryRecordUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: DisciplinaryRecordUpdateManyWithWhereWithoutSubjectInput | DisciplinaryRecordUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CertificateCreateWithoutSubjectInput, CertificateUncheckedCreateWithoutSubjectInput> | CertificateCreateWithoutSubjectInput[] | CertificateUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSubjectInput | CertificateCreateOrConnectWithoutSubjectInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutSubjectInput | CertificateUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CertificateCreateManySubjectInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutSubjectInput | CertificateUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutSubjectInput | CertificateUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type SubjectCreateNestedOneWithoutClassroomsInput = {
    create?: XOR<SubjectCreateWithoutClassroomsInput, SubjectUncheckedCreateWithoutClassroomsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassroomsInput
    connect?: SubjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVirtualClassroomsInput = {
    create?: XOR<UserCreateWithoutVirtualClassroomsInput, UserUncheckedCreateWithoutVirtualClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVirtualClassroomsInput
    connect?: UserWhereUniqueInput
  }

  export type AIAgentCreateNestedOneWithoutClassroomsInput = {
    create?: XOR<AIAgentCreateWithoutClassroomsInput, AIAgentUncheckedCreateWithoutClassroomsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutClassroomsInput
    connect?: AIAgentWhereUniqueInput
  }

  export type LessonPlanCreateNestedManyWithoutClassroomInput = {
    create?: XOR<LessonPlanCreateWithoutClassroomInput, LessonPlanUncheckedCreateWithoutClassroomInput> | LessonPlanCreateWithoutClassroomInput[] | LessonPlanUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutClassroomInput | LessonPlanCreateOrConnectWithoutClassroomInput[]
    createMany?: LessonPlanCreateManyClassroomInputEnvelope
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutClassroomInput = {
    create?: XOR<AttendanceCreateWithoutClassroomInput, AttendanceUncheckedCreateWithoutClassroomInput> | AttendanceCreateWithoutClassroomInput[] | AttendanceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassroomInput | AttendanceCreateOrConnectWithoutClassroomInput[]
    createMany?: AttendanceCreateManyClassroomInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AIUsageLogCreateNestedManyWithoutClassroomInput = {
    create?: XOR<AIUsageLogCreateWithoutClassroomInput, AIUsageLogUncheckedCreateWithoutClassroomInput> | AIUsageLogCreateWithoutClassroomInput[] | AIUsageLogUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutClassroomInput | AIUsageLogCreateOrConnectWithoutClassroomInput[]
    createMany?: AIUsageLogCreateManyClassroomInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type StudentSubjectCreateNestedManyWithoutClassroomInput = {
    create?: XOR<StudentSubjectCreateWithoutClassroomInput, StudentSubjectUncheckedCreateWithoutClassroomInput> | StudentSubjectCreateWithoutClassroomInput[] | StudentSubjectUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutClassroomInput | StudentSubjectCreateOrConnectWithoutClassroomInput[]
    createMany?: StudentSubjectCreateManyClassroomInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type LessonPlanUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<LessonPlanCreateWithoutClassroomInput, LessonPlanUncheckedCreateWithoutClassroomInput> | LessonPlanCreateWithoutClassroomInput[] | LessonPlanUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutClassroomInput | LessonPlanCreateOrConnectWithoutClassroomInput[]
    createMany?: LessonPlanCreateManyClassroomInputEnvelope
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<AttendanceCreateWithoutClassroomInput, AttendanceUncheckedCreateWithoutClassroomInput> | AttendanceCreateWithoutClassroomInput[] | AttendanceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassroomInput | AttendanceCreateOrConnectWithoutClassroomInput[]
    createMany?: AttendanceCreateManyClassroomInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<AIUsageLogCreateWithoutClassroomInput, AIUsageLogUncheckedCreateWithoutClassroomInput> | AIUsageLogCreateWithoutClassroomInput[] | AIUsageLogUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutClassroomInput | AIUsageLogCreateOrConnectWithoutClassroomInput[]
    createMany?: AIUsageLogCreateManyClassroomInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<StudentSubjectCreateWithoutClassroomInput, StudentSubjectUncheckedCreateWithoutClassroomInput> | StudentSubjectCreateWithoutClassroomInput[] | StudentSubjectUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutClassroomInput | StudentSubjectCreateOrConnectWithoutClassroomInput[]
    createMany?: StudentSubjectCreateManyClassroomInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type SubjectUpdateOneRequiredWithoutClassroomsNestedInput = {
    create?: XOR<SubjectCreateWithoutClassroomsInput, SubjectUncheckedCreateWithoutClassroomsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassroomsInput
    upsert?: SubjectUpsertWithoutClassroomsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutClassroomsInput, SubjectUpdateWithoutClassroomsInput>, SubjectUncheckedUpdateWithoutClassroomsInput>
  }

  export type UserUpdateOneWithoutVirtualClassroomsNestedInput = {
    create?: XOR<UserCreateWithoutVirtualClassroomsInput, UserUncheckedCreateWithoutVirtualClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVirtualClassroomsInput
    upsert?: UserUpsertWithoutVirtualClassroomsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVirtualClassroomsInput, UserUpdateWithoutVirtualClassroomsInput>, UserUncheckedUpdateWithoutVirtualClassroomsInput>
  }

  export type AIAgentUpdateOneWithoutClassroomsNestedInput = {
    create?: XOR<AIAgentCreateWithoutClassroomsInput, AIAgentUncheckedCreateWithoutClassroomsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutClassroomsInput
    upsert?: AIAgentUpsertWithoutClassroomsInput
    disconnect?: AIAgentWhereInput | boolean
    delete?: AIAgentWhereInput | boolean
    connect?: AIAgentWhereUniqueInput
    update?: XOR<XOR<AIAgentUpdateToOneWithWhereWithoutClassroomsInput, AIAgentUpdateWithoutClassroomsInput>, AIAgentUncheckedUpdateWithoutClassroomsInput>
  }

  export type LessonPlanUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<LessonPlanCreateWithoutClassroomInput, LessonPlanUncheckedCreateWithoutClassroomInput> | LessonPlanCreateWithoutClassroomInput[] | LessonPlanUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutClassroomInput | LessonPlanCreateOrConnectWithoutClassroomInput[]
    upsert?: LessonPlanUpsertWithWhereUniqueWithoutClassroomInput | LessonPlanUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: LessonPlanCreateManyClassroomInputEnvelope
    set?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    disconnect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    delete?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    update?: LessonPlanUpdateWithWhereUniqueWithoutClassroomInput | LessonPlanUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: LessonPlanUpdateManyWithWhereWithoutClassroomInput | LessonPlanUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<AttendanceCreateWithoutClassroomInput, AttendanceUncheckedCreateWithoutClassroomInput> | AttendanceCreateWithoutClassroomInput[] | AttendanceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassroomInput | AttendanceCreateOrConnectWithoutClassroomInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutClassroomInput | AttendanceUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: AttendanceCreateManyClassroomInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutClassroomInput | AttendanceUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutClassroomInput | AttendanceUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AIUsageLogUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutClassroomInput, AIUsageLogUncheckedCreateWithoutClassroomInput> | AIUsageLogCreateWithoutClassroomInput[] | AIUsageLogUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutClassroomInput | AIUsageLogCreateOrConnectWithoutClassroomInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutClassroomInput | AIUsageLogUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: AIUsageLogCreateManyClassroomInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutClassroomInput | AIUsageLogUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutClassroomInput | AIUsageLogUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type StudentSubjectUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutClassroomInput, StudentSubjectUncheckedCreateWithoutClassroomInput> | StudentSubjectCreateWithoutClassroomInput[] | StudentSubjectUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutClassroomInput | StudentSubjectCreateOrConnectWithoutClassroomInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutClassroomInput | StudentSubjectUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: StudentSubjectCreateManyClassroomInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutClassroomInput | StudentSubjectUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutClassroomInput | StudentSubjectUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<LessonPlanCreateWithoutClassroomInput, LessonPlanUncheckedCreateWithoutClassroomInput> | LessonPlanCreateWithoutClassroomInput[] | LessonPlanUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutClassroomInput | LessonPlanCreateOrConnectWithoutClassroomInput[]
    upsert?: LessonPlanUpsertWithWhereUniqueWithoutClassroomInput | LessonPlanUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: LessonPlanCreateManyClassroomInputEnvelope
    set?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    disconnect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    delete?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    update?: LessonPlanUpdateWithWhereUniqueWithoutClassroomInput | LessonPlanUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: LessonPlanUpdateManyWithWhereWithoutClassroomInput | LessonPlanUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<AttendanceCreateWithoutClassroomInput, AttendanceUncheckedCreateWithoutClassroomInput> | AttendanceCreateWithoutClassroomInput[] | AttendanceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassroomInput | AttendanceCreateOrConnectWithoutClassroomInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutClassroomInput | AttendanceUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: AttendanceCreateManyClassroomInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutClassroomInput | AttendanceUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutClassroomInput | AttendanceUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutClassroomInput, AIUsageLogUncheckedCreateWithoutClassroomInput> | AIUsageLogCreateWithoutClassroomInput[] | AIUsageLogUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutClassroomInput | AIUsageLogCreateOrConnectWithoutClassroomInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutClassroomInput | AIUsageLogUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: AIUsageLogCreateManyClassroomInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutClassroomInput | AIUsageLogUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutClassroomInput | AIUsageLogUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutClassroomInput, StudentSubjectUncheckedCreateWithoutClassroomInput> | StudentSubjectCreateWithoutClassroomInput[] | StudentSubjectUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutClassroomInput | StudentSubjectCreateOrConnectWithoutClassroomInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutClassroomInput | StudentSubjectUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: StudentSubjectCreateManyClassroomInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutClassroomInput | StudentSubjectUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutClassroomInput | StudentSubjectUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type VirtualClassroomCreateNestedOneWithoutLessonPlansInput = {
    create?: XOR<VirtualClassroomCreateWithoutLessonPlansInput, VirtualClassroomUncheckedCreateWithoutLessonPlansInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutLessonPlansInput
    connect?: VirtualClassroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonPlansInput = {
    create?: XOR<UserCreateWithoutLessonPlansInput, UserUncheckedCreateWithoutLessonPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonPlansInput
    connect?: UserWhereUniqueInput
  }

  export type VirtualClassroomUpdateOneRequiredWithoutLessonPlansNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutLessonPlansInput, VirtualClassroomUncheckedCreateWithoutLessonPlansInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutLessonPlansInput
    upsert?: VirtualClassroomUpsertWithoutLessonPlansInput
    connect?: VirtualClassroomWhereUniqueInput
    update?: XOR<XOR<VirtualClassroomUpdateToOneWithWhereWithoutLessonPlansInput, VirtualClassroomUpdateWithoutLessonPlansInput>, VirtualClassroomUncheckedUpdateWithoutLessonPlansInput>
  }

  export type UserUpdateOneWithoutLessonPlansNestedInput = {
    create?: XOR<UserCreateWithoutLessonPlansInput, UserUncheckedCreateWithoutLessonPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonPlansInput
    upsert?: UserUpsertWithoutLessonPlansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonPlansInput, UserUpdateWithoutLessonPlansInput>, UserUncheckedUpdateWithoutLessonPlansInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutStudentsInput = {
    create?: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutStudentsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type CareerCreateNestedOneWithoutStudentsInput = {
    create?: XOR<CareerCreateWithoutStudentsInput, CareerUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutStudentsInput
    connect?: CareerWhereUniqueInput
  }

  export type EnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type StudentSubjectCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TutorStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutorStudentCreateWithoutStudentInput, TutorStudentUncheckedCreateWithoutStudentInput> | TutorStudentCreateWithoutStudentInput[] | TutorStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutStudentInput | TutorStudentCreateOrConnectWithoutStudentInput[]
    createMany?: TutorStudentCreateManyStudentInputEnvelope
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
  }

  export type StudentPaymentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type DisciplinaryRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutStudentInput, DisciplinaryRecordUncheckedCreateWithoutStudentInput> | DisciplinaryRecordCreateWithoutStudentInput[] | DisciplinaryRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutStudentInput | DisciplinaryRecordCreateOrConnectWithoutStudentInput[]
    createMany?: DisciplinaryRecordCreateManyStudentInputEnvelope
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
  }

  export type PaymentPlanCreateNestedManyWithoutStudentInput = {
    create?: XOR<PaymentPlanCreateWithoutStudentInput, PaymentPlanUncheckedCreateWithoutStudentInput> | PaymentPlanCreateWithoutStudentInput[] | PaymentPlanUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutStudentInput | PaymentPlanCreateOrConnectWithoutStudentInput[]
    createMany?: PaymentPlanCreateManyStudentInputEnvelope
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type StudentSubjectUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TutorStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TutorStudentCreateWithoutStudentInput, TutorStudentUncheckedCreateWithoutStudentInput> | TutorStudentCreateWithoutStudentInput[] | TutorStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutStudentInput | TutorStudentCreateOrConnectWithoutStudentInput[]
    createMany?: TutorStudentCreateManyStudentInputEnvelope
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
  }

  export type StudentPaymentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutStudentInput, DisciplinaryRecordUncheckedCreateWithoutStudentInput> | DisciplinaryRecordCreateWithoutStudentInput[] | DisciplinaryRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutStudentInput | DisciplinaryRecordCreateOrConnectWithoutStudentInput[]
    createMany?: DisciplinaryRecordCreateManyStudentInputEnvelope
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
  }

  export type PaymentPlanUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PaymentPlanCreateWithoutStudentInput, PaymentPlanUncheckedCreateWithoutStudentInput> | PaymentPlanCreateWithoutStudentInput[] | PaymentPlanUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutStudentInput | PaymentPlanCreateOrConnectWithoutStudentInput[]
    createMany?: PaymentPlanCreateManyStudentInputEnvelope
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentStatus
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type InstitutionUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutStudentsInput
    upsert?: InstitutionUpsertWithoutStudentsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutStudentsInput, InstitutionUpdateWithoutStudentsInput>, InstitutionUncheckedUpdateWithoutStudentsInput>
  }

  export type CareerUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<CareerCreateWithoutStudentsInput, CareerUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutStudentsInput
    upsert?: CareerUpsertWithoutStudentsInput
    disconnect?: CareerWhereInput | boolean
    delete?: CareerWhereInput | boolean
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutStudentsInput, CareerUpdateWithoutStudentsInput>, CareerUncheckedUpdateWithoutStudentsInput>
  }

  export type EnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type StudentSubjectUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutStudentInput | StudentSubjectUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutStudentInput | StudentSubjectUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutStudentInput | StudentSubjectUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TutorStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutorStudentCreateWithoutStudentInput, TutorStudentUncheckedCreateWithoutStudentInput> | TutorStudentCreateWithoutStudentInput[] | TutorStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutStudentInput | TutorStudentCreateOrConnectWithoutStudentInput[]
    upsert?: TutorStudentUpsertWithWhereUniqueWithoutStudentInput | TutorStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutorStudentCreateManyStudentInputEnvelope
    set?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    disconnect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    delete?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    update?: TutorStudentUpdateWithWhereUniqueWithoutStudentInput | TutorStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutorStudentUpdateManyWithWhereWithoutStudentInput | TutorStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutorStudentScalarWhereInput | TutorStudentScalarWhereInput[]
  }

  export type StudentPaymentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutStudentInput | StudentPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type DisciplinaryRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutStudentInput, DisciplinaryRecordUncheckedCreateWithoutStudentInput> | DisciplinaryRecordCreateWithoutStudentInput[] | DisciplinaryRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutStudentInput | DisciplinaryRecordCreateOrConnectWithoutStudentInput[]
    upsert?: DisciplinaryRecordUpsertWithWhereUniqueWithoutStudentInput | DisciplinaryRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DisciplinaryRecordCreateManyStudentInputEnvelope
    set?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    disconnect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    delete?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    update?: DisciplinaryRecordUpdateWithWhereUniqueWithoutStudentInput | DisciplinaryRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DisciplinaryRecordUpdateManyWithWhereWithoutStudentInput | DisciplinaryRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
  }

  export type PaymentPlanUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PaymentPlanCreateWithoutStudentInput, PaymentPlanUncheckedCreateWithoutStudentInput> | PaymentPlanCreateWithoutStudentInput[] | PaymentPlanUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutStudentInput | PaymentPlanCreateOrConnectWithoutStudentInput[]
    upsert?: PaymentPlanUpsertWithWhereUniqueWithoutStudentInput | PaymentPlanUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PaymentPlanCreateManyStudentInputEnvelope
    set?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    disconnect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    delete?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    update?: PaymentPlanUpdateWithWhereUniqueWithoutStudentInput | PaymentPlanUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PaymentPlanUpdateManyWithWhereWithoutStudentInput | PaymentPlanUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PaymentPlanScalarWhereInput | PaymentPlanScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput> | StudentSubjectCreateWithoutStudentInput[] | StudentSubjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutStudentInput | StudentSubjectCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutStudentInput | StudentSubjectUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSubjectCreateManyStudentInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutStudentInput | StudentSubjectUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutStudentInput | StudentSubjectUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TutorStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TutorStudentCreateWithoutStudentInput, TutorStudentUncheckedCreateWithoutStudentInput> | TutorStudentCreateWithoutStudentInput[] | TutorStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutStudentInput | TutorStudentCreateOrConnectWithoutStudentInput[]
    upsert?: TutorStudentUpsertWithWhereUniqueWithoutStudentInput | TutorStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TutorStudentCreateManyStudentInputEnvelope
    set?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    disconnect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    delete?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    update?: TutorStudentUpdateWithWhereUniqueWithoutStudentInput | TutorStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TutorStudentUpdateManyWithWhereWithoutStudentInput | TutorStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TutorStudentScalarWhereInput | TutorStudentScalarWhereInput[]
  }

  export type StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput> | StudentPaymentCreateWithoutStudentInput[] | StudentPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutStudentInput | StudentPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentPaymentCreateManyStudentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutStudentInput | StudentPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DisciplinaryRecordCreateWithoutStudentInput, DisciplinaryRecordUncheckedCreateWithoutStudentInput> | DisciplinaryRecordCreateWithoutStudentInput[] | DisciplinaryRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DisciplinaryRecordCreateOrConnectWithoutStudentInput | DisciplinaryRecordCreateOrConnectWithoutStudentInput[]
    upsert?: DisciplinaryRecordUpsertWithWhereUniqueWithoutStudentInput | DisciplinaryRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DisciplinaryRecordCreateManyStudentInputEnvelope
    set?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    disconnect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    delete?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    connect?: DisciplinaryRecordWhereUniqueInput | DisciplinaryRecordWhereUniqueInput[]
    update?: DisciplinaryRecordUpdateWithWhereUniqueWithoutStudentInput | DisciplinaryRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DisciplinaryRecordUpdateManyWithWhereWithoutStudentInput | DisciplinaryRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
  }

  export type PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PaymentPlanCreateWithoutStudentInput, PaymentPlanUncheckedCreateWithoutStudentInput> | PaymentPlanCreateWithoutStudentInput[] | PaymentPlanUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutStudentInput | PaymentPlanCreateOrConnectWithoutStudentInput[]
    upsert?: PaymentPlanUpsertWithWhereUniqueWithoutStudentInput | PaymentPlanUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PaymentPlanCreateManyStudentInputEnvelope
    set?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    disconnect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    delete?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    update?: PaymentPlanUpdateWithWhereUniqueWithoutStudentInput | PaymentPlanUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PaymentPlanUpdateManyWithWhereWithoutStudentInput | PaymentPlanUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PaymentPlanScalarWhereInput | PaymentPlanScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<AcademicPeriodCreateWithoutEnrollmentsInput, AcademicPeriodUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutEnrollmentsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type AcademicPeriodUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutEnrollmentsInput, AcademicPeriodUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutEnrollmentsInput
    upsert?: AcademicPeriodUpsertWithoutEnrollmentsInput
    disconnect?: AcademicPeriodWhereInput | boolean
    delete?: AcademicPeriodWhereInput | boolean
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutEnrollmentsInput, AcademicPeriodUpdateWithoutEnrollmentsInput>, AcademicPeriodUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput
    connect?: StudentWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutStudentSubjectsInput = {
    create?: XOR<SubjectCreateWithoutStudentSubjectsInput, SubjectUncheckedCreateWithoutStudentSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentSubjectsInput
    connect?: SubjectWhereUniqueInput
  }

  export type VirtualClassroomCreateNestedOneWithoutStudentSubjectInput = {
    create?: XOR<VirtualClassroomCreateWithoutStudentSubjectInput, VirtualClassroomUncheckedCreateWithoutStudentSubjectInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutStudentSubjectInput
    connect?: VirtualClassroomWhereUniqueInput
  }

  export type GradeCreateNestedManyWithoutStudentSubjectInput = {
    create?: XOR<GradeCreateWithoutStudentSubjectInput, GradeUncheckedCreateWithoutStudentSubjectInput> | GradeCreateWithoutStudentSubjectInput[] | GradeUncheckedCreateWithoutStudentSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentSubjectInput | GradeCreateOrConnectWithoutStudentSubjectInput[]
    createMany?: GradeCreateManyStudentSubjectInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutStudentSubjectInput = {
    create?: XOR<GradeCreateWithoutStudentSubjectInput, GradeUncheckedCreateWithoutStudentSubjectInput> | GradeCreateWithoutStudentSubjectInput[] | GradeUncheckedCreateWithoutStudentSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentSubjectInput | GradeCreateOrConnectWithoutStudentSubjectInput[]
    createMany?: GradeCreateManyStudentSubjectInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StudentUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubjectsInput
    upsert?: StudentUpsertWithoutSubjectsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSubjectsInput, StudentUpdateWithoutSubjectsInput>, StudentUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutStudentSubjectsNestedInput = {
    create?: XOR<SubjectCreateWithoutStudentSubjectsInput, SubjectUncheckedCreateWithoutStudentSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutStudentSubjectsInput
    upsert?: SubjectUpsertWithoutStudentSubjectsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutStudentSubjectsInput, SubjectUpdateWithoutStudentSubjectsInput>, SubjectUncheckedUpdateWithoutStudentSubjectsInput>
  }

  export type VirtualClassroomUpdateOneWithoutStudentSubjectNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutStudentSubjectInput, VirtualClassroomUncheckedCreateWithoutStudentSubjectInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutStudentSubjectInput
    upsert?: VirtualClassroomUpsertWithoutStudentSubjectInput
    disconnect?: VirtualClassroomWhereInput | boolean
    delete?: VirtualClassroomWhereInput | boolean
    connect?: VirtualClassroomWhereUniqueInput
    update?: XOR<XOR<VirtualClassroomUpdateToOneWithWhereWithoutStudentSubjectInput, VirtualClassroomUpdateWithoutStudentSubjectInput>, VirtualClassroomUncheckedUpdateWithoutStudentSubjectInput>
  }

  export type GradeUpdateManyWithoutStudentSubjectNestedInput = {
    create?: XOR<GradeCreateWithoutStudentSubjectInput, GradeUncheckedCreateWithoutStudentSubjectInput> | GradeCreateWithoutStudentSubjectInput[] | GradeUncheckedCreateWithoutStudentSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentSubjectInput | GradeCreateOrConnectWithoutStudentSubjectInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentSubjectInput | GradeUpsertWithWhereUniqueWithoutStudentSubjectInput[]
    createMany?: GradeCreateManyStudentSubjectInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentSubjectInput | GradeUpdateWithWhereUniqueWithoutStudentSubjectInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentSubjectInput | GradeUpdateManyWithWhereWithoutStudentSubjectInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutStudentSubjectNestedInput = {
    create?: XOR<GradeCreateWithoutStudentSubjectInput, GradeUncheckedCreateWithoutStudentSubjectInput> | GradeCreateWithoutStudentSubjectInput[] | GradeUncheckedCreateWithoutStudentSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentSubjectInput | GradeCreateOrConnectWithoutStudentSubjectInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentSubjectInput | GradeUpsertWithWhereUniqueWithoutStudentSubjectInput[]
    createMany?: GradeCreateManyStudentSubjectInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentSubjectInput | GradeUpdateWithWhereUniqueWithoutStudentSubjectInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentSubjectInput | GradeUpdateManyWithWhereWithoutStudentSubjectInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type StudentSubjectCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentSubjectCreateWithoutGradesInput, StudentSubjectUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutGradesInput
    connect?: StudentSubjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGradesInput = {
    create?: XOR<UserCreateWithoutGradesInput, UserUncheckedCreateWithoutGradesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGradeTypeFieldUpdateOperationsInput = {
    set?: $Enums.GradeType
  }

  export type StudentSubjectUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutGradesInput, StudentSubjectUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutGradesInput
    upsert?: StudentSubjectUpsertWithoutGradesInput
    connect?: StudentSubjectWhereUniqueInput
    update?: XOR<XOR<StudentSubjectUpdateToOneWithWhereWithoutGradesInput, StudentSubjectUpdateWithoutGradesInput>, StudentSubjectUncheckedUpdateWithoutGradesInput>
  }

  export type UserUpdateOneWithoutGradesNestedInput = {
    create?: XOR<UserCreateWithoutGradesInput, UserUncheckedCreateWithoutGradesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradesInput
    upsert?: UserUpsertWithoutGradesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradesInput, UserUpdateWithoutGradesInput>, UserUncheckedUpdateWithoutGradesInput>
  }

  export type StudentCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendancesInput
    connect?: StudentWhereUniqueInput
  }

  export type VirtualClassroomCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<VirtualClassroomCreateWithoutAttendancesInput, VirtualClassroomUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAttendancesInput
    connect?: VirtualClassroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type StudentUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendancesInput
    upsert?: StudentUpsertWithoutAttendancesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendancesInput, StudentUpdateWithoutAttendancesInput>, StudentUncheckedUpdateWithoutAttendancesInput>
  }

  export type VirtualClassroomUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutAttendancesInput, VirtualClassroomUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAttendancesInput
    upsert?: VirtualClassroomUpsertWithoutAttendancesInput
    connect?: VirtualClassroomWhereUniqueInput
    update?: XOR<XOR<VirtualClassroomUpdateToOneWithWhereWithoutAttendancesInput, VirtualClassroomUpdateWithoutAttendancesInput>, VirtualClassroomUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentCreateNestedOneWithoutDisciplinaryRecordInput = {
    create?: XOR<StudentCreateWithoutDisciplinaryRecordInput, StudentUncheckedCreateWithoutDisciplinaryRecordInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDisciplinaryRecordInput
    connect?: StudentWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutDisciplinaryRecordInput = {
    create?: XOR<SubjectCreateWithoutDisciplinaryRecordInput, SubjectUncheckedCreateWithoutDisciplinaryRecordInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutDisciplinaryRecordInput
    connect?: SubjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisciplinaryRecordInput = {
    create?: XOR<UserCreateWithoutDisciplinaryRecordInput, UserUncheckedCreateWithoutDisciplinaryRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisciplinaryRecordInput
    connect?: UserWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutDisciplinaryRecordNestedInput = {
    create?: XOR<StudentCreateWithoutDisciplinaryRecordInput, StudentUncheckedCreateWithoutDisciplinaryRecordInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDisciplinaryRecordInput
    upsert?: StudentUpsertWithoutDisciplinaryRecordInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutDisciplinaryRecordInput, StudentUpdateWithoutDisciplinaryRecordInput>, StudentUncheckedUpdateWithoutDisciplinaryRecordInput>
  }

  export type SubjectUpdateOneWithoutDisciplinaryRecordNestedInput = {
    create?: XOR<SubjectCreateWithoutDisciplinaryRecordInput, SubjectUncheckedCreateWithoutDisciplinaryRecordInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutDisciplinaryRecordInput
    upsert?: SubjectUpsertWithoutDisciplinaryRecordInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutDisciplinaryRecordInput, SubjectUpdateWithoutDisciplinaryRecordInput>, SubjectUncheckedUpdateWithoutDisciplinaryRecordInput>
  }

  export type UserUpdateOneWithoutDisciplinaryRecordNestedInput = {
    create?: XOR<UserCreateWithoutDisciplinaryRecordInput, UserUncheckedCreateWithoutDisciplinaryRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisciplinaryRecordInput
    upsert?: UserUpsertWithoutDisciplinaryRecordInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisciplinaryRecordInput, UserUpdateWithoutDisciplinaryRecordInput>, UserUncheckedUpdateWithoutDisciplinaryRecordInput>
  }

  export type UserCreateNestedOneWithoutTutorProfileInput = {
    create?: XOR<UserCreateWithoutTutorProfileInput, UserUncheckedCreateWithoutTutorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutTutorProfileInput = {
    create?: XOR<InstitutionCreateWithoutTutorProfileInput, InstitutionUncheckedCreateWithoutTutorProfileInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutTutorProfileInput
    connect?: InstitutionWhereUniqueInput
  }

  export type TutorStudentCreateNestedManyWithoutTutorInput = {
    create?: XOR<TutorStudentCreateWithoutTutorInput, TutorStudentUncheckedCreateWithoutTutorInput> | TutorStudentCreateWithoutTutorInput[] | TutorStudentUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutTutorInput | TutorStudentCreateOrConnectWithoutTutorInput[]
    createMany?: TutorStudentCreateManyTutorInputEnvelope
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
  }

  export type TutorStudentUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<TutorStudentCreateWithoutTutorInput, TutorStudentUncheckedCreateWithoutTutorInput> | TutorStudentCreateWithoutTutorInput[] | TutorStudentUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutTutorInput | TutorStudentCreateOrConnectWithoutTutorInput[]
    createMany?: TutorStudentCreateManyTutorInputEnvelope
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTutorProfileNestedInput = {
    create?: XOR<UserCreateWithoutTutorProfileInput, UserUncheckedCreateWithoutTutorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTutorProfileInput
    upsert?: UserUpsertWithoutTutorProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTutorProfileInput, UserUpdateWithoutTutorProfileInput>, UserUncheckedUpdateWithoutTutorProfileInput>
  }

  export type InstitutionUpdateOneRequiredWithoutTutorProfileNestedInput = {
    create?: XOR<InstitutionCreateWithoutTutorProfileInput, InstitutionUncheckedCreateWithoutTutorProfileInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutTutorProfileInput
    upsert?: InstitutionUpsertWithoutTutorProfileInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutTutorProfileInput, InstitutionUpdateWithoutTutorProfileInput>, InstitutionUncheckedUpdateWithoutTutorProfileInput>
  }

  export type TutorStudentUpdateManyWithoutTutorNestedInput = {
    create?: XOR<TutorStudentCreateWithoutTutorInput, TutorStudentUncheckedCreateWithoutTutorInput> | TutorStudentCreateWithoutTutorInput[] | TutorStudentUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutTutorInput | TutorStudentCreateOrConnectWithoutTutorInput[]
    upsert?: TutorStudentUpsertWithWhereUniqueWithoutTutorInput | TutorStudentUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: TutorStudentCreateManyTutorInputEnvelope
    set?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    disconnect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    delete?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    update?: TutorStudentUpdateWithWhereUniqueWithoutTutorInput | TutorStudentUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: TutorStudentUpdateManyWithWhereWithoutTutorInput | TutorStudentUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: TutorStudentScalarWhereInput | TutorStudentScalarWhereInput[]
  }

  export type TutorStudentUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<TutorStudentCreateWithoutTutorInput, TutorStudentUncheckedCreateWithoutTutorInput> | TutorStudentCreateWithoutTutorInput[] | TutorStudentUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: TutorStudentCreateOrConnectWithoutTutorInput | TutorStudentCreateOrConnectWithoutTutorInput[]
    upsert?: TutorStudentUpsertWithWhereUniqueWithoutTutorInput | TutorStudentUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: TutorStudentCreateManyTutorInputEnvelope
    set?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    disconnect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    delete?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    connect?: TutorStudentWhereUniqueInput | TutorStudentWhereUniqueInput[]
    update?: TutorStudentUpdateWithWhereUniqueWithoutTutorInput | TutorStudentUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: TutorStudentUpdateManyWithWhereWithoutTutorInput | TutorStudentUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: TutorStudentScalarWhereInput | TutorStudentScalarWhereInput[]
  }

  export type TutorProfileCreateNestedOneWithoutTutorAssignmentsInput = {
    create?: XOR<TutorProfileCreateWithoutTutorAssignmentsInput, TutorProfileUncheckedCreateWithoutTutorAssignmentsInput>
    connectOrCreate?: TutorProfileCreateOrConnectWithoutTutorAssignmentsInput
    connect?: TutorProfileWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutTutorAssignmentsInput = {
    create?: XOR<StudentCreateWithoutTutorAssignmentsInput, StudentUncheckedCreateWithoutTutorAssignmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTutorAssignmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type TutorProfileUpdateOneRequiredWithoutTutorAssignmentsNestedInput = {
    create?: XOR<TutorProfileCreateWithoutTutorAssignmentsInput, TutorProfileUncheckedCreateWithoutTutorAssignmentsInput>
    connectOrCreate?: TutorProfileCreateOrConnectWithoutTutorAssignmentsInput
    upsert?: TutorProfileUpsertWithoutTutorAssignmentsInput
    connect?: TutorProfileWhereUniqueInput
    update?: XOR<XOR<TutorProfileUpdateToOneWithWhereWithoutTutorAssignmentsInput, TutorProfileUpdateWithoutTutorAssignmentsInput>, TutorProfileUncheckedUpdateWithoutTutorAssignmentsInput>
  }

  export type StudentUpdateOneRequiredWithoutTutorAssignmentsNestedInput = {
    create?: XOR<StudentCreateWithoutTutorAssignmentsInput, StudentUncheckedCreateWithoutTutorAssignmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTutorAssignmentsInput
    upsert?: StudentUpsertWithoutTutorAssignmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTutorAssignmentsInput, StudentUpdateWithoutTutorAssignmentsInput>, StudentUncheckedUpdateWithoutTutorAssignmentsInput>
  }

  export type StudentCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCertificateInput = {
    create?: XOR<CourseCreateWithoutCertificateInput, CourseUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificateInput
    connect?: CourseWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutCertificateInput = {
    create?: XOR<SubjectCreateWithoutCertificateInput, SubjectUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCertificateInput
    connect?: SubjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCertificateInput = {
    create?: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificateInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCertificateTypeFieldUpdateOperationsInput = {
    set?: $Enums.CertificateType
  }

  export type StudentUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    upsert?: StudentUpsertWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCertificatesInput, StudentUpdateWithoutCertificatesInput>, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateOneWithoutCertificateNestedInput = {
    create?: XOR<CourseCreateWithoutCertificateInput, CourseUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificateInput
    upsert?: CourseUpsertWithoutCertificateInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCertificateInput, CourseUpdateWithoutCertificateInput>, CourseUncheckedUpdateWithoutCertificateInput>
  }

  export type SubjectUpdateOneWithoutCertificateNestedInput = {
    create?: XOR<SubjectCreateWithoutCertificateInput, SubjectUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCertificateInput
    upsert?: SubjectUpsertWithoutCertificateInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutCertificateInput, SubjectUpdateWithoutCertificateInput>, SubjectUncheckedUpdateWithoutCertificateInput>
  }

  export type UserUpdateOneWithoutCertificateNestedInput = {
    create?: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificateInput
    upsert?: UserUpsertWithoutCertificateInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificateInput, UserUpdateWithoutCertificateInput>, UserUncheckedUpdateWithoutCertificateInput>
  }

  export type InstitutionCreateNestedOneWithoutFeeSchedulesInput = {
    create?: XOR<InstitutionCreateWithoutFeeSchedulesInput, InstitutionUncheckedCreateWithoutFeeSchedulesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutFeeSchedulesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type CareerCreateNestedOneWithoutFeeScheduleInput = {
    create?: XOR<CareerCreateWithoutFeeScheduleInput, CareerUncheckedCreateWithoutFeeScheduleInput>
    connectOrCreate?: CareerCreateOrConnectWithoutFeeScheduleInput
    connect?: CareerWhereUniqueInput
  }

  export type FeeInstallmentCreateNestedManyWithoutFeeScheduleInput = {
    create?: XOR<FeeInstallmentCreateWithoutFeeScheduleInput, FeeInstallmentUncheckedCreateWithoutFeeScheduleInput> | FeeInstallmentCreateWithoutFeeScheduleInput[] | FeeInstallmentUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: FeeInstallmentCreateOrConnectWithoutFeeScheduleInput | FeeInstallmentCreateOrConnectWithoutFeeScheduleInput[]
    createMany?: FeeInstallmentCreateManyFeeScheduleInputEnvelope
    connect?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
  }

  export type PaymentPlanCreateNestedManyWithoutFeeScheduleInput = {
    create?: XOR<PaymentPlanCreateWithoutFeeScheduleInput, PaymentPlanUncheckedCreateWithoutFeeScheduleInput> | PaymentPlanCreateWithoutFeeScheduleInput[] | PaymentPlanUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutFeeScheduleInput | PaymentPlanCreateOrConnectWithoutFeeScheduleInput[]
    createMany?: PaymentPlanCreateManyFeeScheduleInputEnvelope
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
  }

  export type FeeInstallmentUncheckedCreateNestedManyWithoutFeeScheduleInput = {
    create?: XOR<FeeInstallmentCreateWithoutFeeScheduleInput, FeeInstallmentUncheckedCreateWithoutFeeScheduleInput> | FeeInstallmentCreateWithoutFeeScheduleInput[] | FeeInstallmentUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: FeeInstallmentCreateOrConnectWithoutFeeScheduleInput | FeeInstallmentCreateOrConnectWithoutFeeScheduleInput[]
    createMany?: FeeInstallmentCreateManyFeeScheduleInputEnvelope
    connect?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
  }

  export type PaymentPlanUncheckedCreateNestedManyWithoutFeeScheduleInput = {
    create?: XOR<PaymentPlanCreateWithoutFeeScheduleInput, PaymentPlanUncheckedCreateWithoutFeeScheduleInput> | PaymentPlanCreateWithoutFeeScheduleInput[] | PaymentPlanUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutFeeScheduleInput | PaymentPlanCreateOrConnectWithoutFeeScheduleInput[]
    createMany?: PaymentPlanCreateManyFeeScheduleInputEnvelope
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
  }

  export type InstitutionUpdateOneRequiredWithoutFeeSchedulesNestedInput = {
    create?: XOR<InstitutionCreateWithoutFeeSchedulesInput, InstitutionUncheckedCreateWithoutFeeSchedulesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutFeeSchedulesInput
    upsert?: InstitutionUpsertWithoutFeeSchedulesInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutFeeSchedulesInput, InstitutionUpdateWithoutFeeSchedulesInput>, InstitutionUncheckedUpdateWithoutFeeSchedulesInput>
  }

  export type CareerUpdateOneWithoutFeeScheduleNestedInput = {
    create?: XOR<CareerCreateWithoutFeeScheduleInput, CareerUncheckedCreateWithoutFeeScheduleInput>
    connectOrCreate?: CareerCreateOrConnectWithoutFeeScheduleInput
    upsert?: CareerUpsertWithoutFeeScheduleInput
    disconnect?: CareerWhereInput | boolean
    delete?: CareerWhereInput | boolean
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutFeeScheduleInput, CareerUpdateWithoutFeeScheduleInput>, CareerUncheckedUpdateWithoutFeeScheduleInput>
  }

  export type FeeInstallmentUpdateManyWithoutFeeScheduleNestedInput = {
    create?: XOR<FeeInstallmentCreateWithoutFeeScheduleInput, FeeInstallmentUncheckedCreateWithoutFeeScheduleInput> | FeeInstallmentCreateWithoutFeeScheduleInput[] | FeeInstallmentUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: FeeInstallmentCreateOrConnectWithoutFeeScheduleInput | FeeInstallmentCreateOrConnectWithoutFeeScheduleInput[]
    upsert?: FeeInstallmentUpsertWithWhereUniqueWithoutFeeScheduleInput | FeeInstallmentUpsertWithWhereUniqueWithoutFeeScheduleInput[]
    createMany?: FeeInstallmentCreateManyFeeScheduleInputEnvelope
    set?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    disconnect?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    delete?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    connect?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    update?: FeeInstallmentUpdateWithWhereUniqueWithoutFeeScheduleInput | FeeInstallmentUpdateWithWhereUniqueWithoutFeeScheduleInput[]
    updateMany?: FeeInstallmentUpdateManyWithWhereWithoutFeeScheduleInput | FeeInstallmentUpdateManyWithWhereWithoutFeeScheduleInput[]
    deleteMany?: FeeInstallmentScalarWhereInput | FeeInstallmentScalarWhereInput[]
  }

  export type PaymentPlanUpdateManyWithoutFeeScheduleNestedInput = {
    create?: XOR<PaymentPlanCreateWithoutFeeScheduleInput, PaymentPlanUncheckedCreateWithoutFeeScheduleInput> | PaymentPlanCreateWithoutFeeScheduleInput[] | PaymentPlanUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutFeeScheduleInput | PaymentPlanCreateOrConnectWithoutFeeScheduleInput[]
    upsert?: PaymentPlanUpsertWithWhereUniqueWithoutFeeScheduleInput | PaymentPlanUpsertWithWhereUniqueWithoutFeeScheduleInput[]
    createMany?: PaymentPlanCreateManyFeeScheduleInputEnvelope
    set?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    disconnect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    delete?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    update?: PaymentPlanUpdateWithWhereUniqueWithoutFeeScheduleInput | PaymentPlanUpdateWithWhereUniqueWithoutFeeScheduleInput[]
    updateMany?: PaymentPlanUpdateManyWithWhereWithoutFeeScheduleInput | PaymentPlanUpdateManyWithWhereWithoutFeeScheduleInput[]
    deleteMany?: PaymentPlanScalarWhereInput | PaymentPlanScalarWhereInput[]
  }

  export type FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleNestedInput = {
    create?: XOR<FeeInstallmentCreateWithoutFeeScheduleInput, FeeInstallmentUncheckedCreateWithoutFeeScheduleInput> | FeeInstallmentCreateWithoutFeeScheduleInput[] | FeeInstallmentUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: FeeInstallmentCreateOrConnectWithoutFeeScheduleInput | FeeInstallmentCreateOrConnectWithoutFeeScheduleInput[]
    upsert?: FeeInstallmentUpsertWithWhereUniqueWithoutFeeScheduleInput | FeeInstallmentUpsertWithWhereUniqueWithoutFeeScheduleInput[]
    createMany?: FeeInstallmentCreateManyFeeScheduleInputEnvelope
    set?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    disconnect?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    delete?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    connect?: FeeInstallmentWhereUniqueInput | FeeInstallmentWhereUniqueInput[]
    update?: FeeInstallmentUpdateWithWhereUniqueWithoutFeeScheduleInput | FeeInstallmentUpdateWithWhereUniqueWithoutFeeScheduleInput[]
    updateMany?: FeeInstallmentUpdateManyWithWhereWithoutFeeScheduleInput | FeeInstallmentUpdateManyWithWhereWithoutFeeScheduleInput[]
    deleteMany?: FeeInstallmentScalarWhereInput | FeeInstallmentScalarWhereInput[]
  }

  export type PaymentPlanUncheckedUpdateManyWithoutFeeScheduleNestedInput = {
    create?: XOR<PaymentPlanCreateWithoutFeeScheduleInput, PaymentPlanUncheckedCreateWithoutFeeScheduleInput> | PaymentPlanCreateWithoutFeeScheduleInput[] | PaymentPlanUncheckedCreateWithoutFeeScheduleInput[]
    connectOrCreate?: PaymentPlanCreateOrConnectWithoutFeeScheduleInput | PaymentPlanCreateOrConnectWithoutFeeScheduleInput[]
    upsert?: PaymentPlanUpsertWithWhereUniqueWithoutFeeScheduleInput | PaymentPlanUpsertWithWhereUniqueWithoutFeeScheduleInput[]
    createMany?: PaymentPlanCreateManyFeeScheduleInputEnvelope
    set?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    disconnect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    delete?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    connect?: PaymentPlanWhereUniqueInput | PaymentPlanWhereUniqueInput[]
    update?: PaymentPlanUpdateWithWhereUniqueWithoutFeeScheduleInput | PaymentPlanUpdateWithWhereUniqueWithoutFeeScheduleInput[]
    updateMany?: PaymentPlanUpdateManyWithWhereWithoutFeeScheduleInput | PaymentPlanUpdateManyWithWhereWithoutFeeScheduleInput[]
    deleteMany?: PaymentPlanScalarWhereInput | PaymentPlanScalarWhereInput[]
  }

  export type FeeScheduleCreateNestedOneWithoutInstallmentsListInput = {
    create?: XOR<FeeScheduleCreateWithoutInstallmentsListInput, FeeScheduleUncheckedCreateWithoutInstallmentsListInput>
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutInstallmentsListInput
    connect?: FeeScheduleWhereUniqueInput
  }

  export type StudentPaymentCreateNestedManyWithoutFeeInstallmentInput = {
    create?: XOR<StudentPaymentCreateWithoutFeeInstallmentInput, StudentPaymentUncheckedCreateWithoutFeeInstallmentInput> | StudentPaymentCreateWithoutFeeInstallmentInput[] | StudentPaymentUncheckedCreateWithoutFeeInstallmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutFeeInstallmentInput | StudentPaymentCreateOrConnectWithoutFeeInstallmentInput[]
    createMany?: StudentPaymentCreateManyFeeInstallmentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type StudentPaymentUncheckedCreateNestedManyWithoutFeeInstallmentInput = {
    create?: XOR<StudentPaymentCreateWithoutFeeInstallmentInput, StudentPaymentUncheckedCreateWithoutFeeInstallmentInput> | StudentPaymentCreateWithoutFeeInstallmentInput[] | StudentPaymentUncheckedCreateWithoutFeeInstallmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutFeeInstallmentInput | StudentPaymentCreateOrConnectWithoutFeeInstallmentInput[]
    createMany?: StudentPaymentCreateManyFeeInstallmentInputEnvelope
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
  }

  export type FeeScheduleUpdateOneRequiredWithoutInstallmentsListNestedInput = {
    create?: XOR<FeeScheduleCreateWithoutInstallmentsListInput, FeeScheduleUncheckedCreateWithoutInstallmentsListInput>
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutInstallmentsListInput
    upsert?: FeeScheduleUpsertWithoutInstallmentsListInput
    connect?: FeeScheduleWhereUniqueInput
    update?: XOR<XOR<FeeScheduleUpdateToOneWithWhereWithoutInstallmentsListInput, FeeScheduleUpdateWithoutInstallmentsListInput>, FeeScheduleUncheckedUpdateWithoutInstallmentsListInput>
  }

  export type StudentPaymentUpdateManyWithoutFeeInstallmentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutFeeInstallmentInput, StudentPaymentUncheckedCreateWithoutFeeInstallmentInput> | StudentPaymentCreateWithoutFeeInstallmentInput[] | StudentPaymentUncheckedCreateWithoutFeeInstallmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutFeeInstallmentInput | StudentPaymentCreateOrConnectWithoutFeeInstallmentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutFeeInstallmentInput | StudentPaymentUpsertWithWhereUniqueWithoutFeeInstallmentInput[]
    createMany?: StudentPaymentCreateManyFeeInstallmentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutFeeInstallmentInput | StudentPaymentUpdateWithWhereUniqueWithoutFeeInstallmentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutFeeInstallmentInput | StudentPaymentUpdateManyWithWhereWithoutFeeInstallmentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type StudentPaymentUncheckedUpdateManyWithoutFeeInstallmentNestedInput = {
    create?: XOR<StudentPaymentCreateWithoutFeeInstallmentInput, StudentPaymentUncheckedCreateWithoutFeeInstallmentInput> | StudentPaymentCreateWithoutFeeInstallmentInput[] | StudentPaymentUncheckedCreateWithoutFeeInstallmentInput[]
    connectOrCreate?: StudentPaymentCreateOrConnectWithoutFeeInstallmentInput | StudentPaymentCreateOrConnectWithoutFeeInstallmentInput[]
    upsert?: StudentPaymentUpsertWithWhereUniqueWithoutFeeInstallmentInput | StudentPaymentUpsertWithWhereUniqueWithoutFeeInstallmentInput[]
    createMany?: StudentPaymentCreateManyFeeInstallmentInputEnvelope
    set?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    disconnect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    delete?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    connect?: StudentPaymentWhereUniqueInput | StudentPaymentWhereUniqueInput[]
    update?: StudentPaymentUpdateWithWhereUniqueWithoutFeeInstallmentInput | StudentPaymentUpdateWithWhereUniqueWithoutFeeInstallmentInput[]
    updateMany?: StudentPaymentUpdateManyWithWhereWithoutFeeInstallmentInput | StudentPaymentUpdateManyWithWhereWithoutFeeInstallmentInput[]
    deleteMany?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentsInput
    connect?: StudentWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutStudentPaymentsInput = {
    create?: XOR<InstitutionCreateWithoutStudentPaymentsInput, InstitutionUncheckedCreateWithoutStudentPaymentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutStudentPaymentsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type FeeInstallmentCreateNestedOneWithoutStudentPaymentsInput = {
    create?: XOR<FeeInstallmentCreateWithoutStudentPaymentsInput, FeeInstallmentUncheckedCreateWithoutStudentPaymentsInput>
    connectOrCreate?: FeeInstallmentCreateOrConnectWithoutStudentPaymentsInput
    connect?: FeeInstallmentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentsInput
    upsert?: StudentUpsertWithoutPaymentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPaymentsInput, StudentUpdateWithoutPaymentsInput>, StudentUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstitutionUpdateOneRequiredWithoutStudentPaymentsNestedInput = {
    create?: XOR<InstitutionCreateWithoutStudentPaymentsInput, InstitutionUncheckedCreateWithoutStudentPaymentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutStudentPaymentsInput
    upsert?: InstitutionUpsertWithoutStudentPaymentsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutStudentPaymentsInput, InstitutionUpdateWithoutStudentPaymentsInput>, InstitutionUncheckedUpdateWithoutStudentPaymentsInput>
  }

  export type FeeInstallmentUpdateOneWithoutStudentPaymentsNestedInput = {
    create?: XOR<FeeInstallmentCreateWithoutStudentPaymentsInput, FeeInstallmentUncheckedCreateWithoutStudentPaymentsInput>
    connectOrCreate?: FeeInstallmentCreateOrConnectWithoutStudentPaymentsInput
    upsert?: FeeInstallmentUpsertWithoutStudentPaymentsInput
    disconnect?: FeeInstallmentWhereInput | boolean
    delete?: FeeInstallmentWhereInput | boolean
    connect?: FeeInstallmentWhereUniqueInput
    update?: XOR<XOR<FeeInstallmentUpdateToOneWithWhereWithoutStudentPaymentsInput, FeeInstallmentUpdateWithoutStudentPaymentsInput>, FeeInstallmentUncheckedUpdateWithoutStudentPaymentsInput>
  }

  export type StudentCreateNestedOneWithoutPaymentPlanInput = {
    create?: XOR<StudentCreateWithoutPaymentPlanInput, StudentUncheckedCreateWithoutPaymentPlanInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentPlanInput
    connect?: StudentWhereUniqueInput
  }

  export type FeeScheduleCreateNestedOneWithoutPaymentPlanInput = {
    create?: XOR<FeeScheduleCreateWithoutPaymentPlanInput, FeeScheduleUncheckedCreateWithoutPaymentPlanInput>
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutPaymentPlanInput
    connect?: FeeScheduleWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutPaymentPlanNestedInput = {
    create?: XOR<StudentCreateWithoutPaymentPlanInput, StudentUncheckedCreateWithoutPaymentPlanInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPaymentPlanInput
    upsert?: StudentUpsertWithoutPaymentPlanInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPaymentPlanInput, StudentUpdateWithoutPaymentPlanInput>, StudentUncheckedUpdateWithoutPaymentPlanInput>
  }

  export type FeeScheduleUpdateOneRequiredWithoutPaymentPlanNestedInput = {
    create?: XOR<FeeScheduleCreateWithoutPaymentPlanInput, FeeScheduleUncheckedCreateWithoutPaymentPlanInput>
    connectOrCreate?: FeeScheduleCreateOrConnectWithoutPaymentPlanInput
    upsert?: FeeScheduleUpsertWithoutPaymentPlanInput
    connect?: FeeScheduleWhereUniqueInput
    update?: XOR<XOR<FeeScheduleUpdateToOneWithWhereWithoutPaymentPlanInput, FeeScheduleUpdateWithoutPaymentPlanInput>, FeeScheduleUncheckedUpdateWithoutPaymentPlanInput>
  }

  export type InstitutionCreateNestedOneWithoutAiAgentsInput = {
    create?: XOR<InstitutionCreateWithoutAiAgentsInput, InstitutionUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAiAgentsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type AIConversationCreateNestedManyWithoutAgentInput = {
    create?: XOR<AIConversationCreateWithoutAgentInput, AIConversationUncheckedCreateWithoutAgentInput> | AIConversationCreateWithoutAgentInput[] | AIConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutAgentInput | AIConversationCreateOrConnectWithoutAgentInput[]
    createMany?: AIConversationCreateManyAgentInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type VirtualClassroomCreateNestedManyWithoutAiagentInput = {
    create?: XOR<VirtualClassroomCreateWithoutAiagentInput, VirtualClassroomUncheckedCreateWithoutAiagentInput> | VirtualClassroomCreateWithoutAiagentInput[] | VirtualClassroomUncheckedCreateWithoutAiagentInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAiagentInput | VirtualClassroomCreateOrConnectWithoutAiagentInput[]
    createMany?: VirtualClassroomCreateManyAiagentInputEnvelope
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
  }

  export type AIConversationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AIConversationCreateWithoutAgentInput, AIConversationUncheckedCreateWithoutAgentInput> | AIConversationCreateWithoutAgentInput[] | AIConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutAgentInput | AIConversationCreateOrConnectWithoutAgentInput[]
    createMany?: AIConversationCreateManyAgentInputEnvelope
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
  }

  export type VirtualClassroomUncheckedCreateNestedManyWithoutAiagentInput = {
    create?: XOR<VirtualClassroomCreateWithoutAiagentInput, VirtualClassroomUncheckedCreateWithoutAiagentInput> | VirtualClassroomCreateWithoutAiagentInput[] | VirtualClassroomUncheckedCreateWithoutAiagentInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAiagentInput | VirtualClassroomCreateOrConnectWithoutAiagentInput[]
    createMany?: VirtualClassroomCreateManyAiagentInputEnvelope
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InstitutionUpdateOneRequiredWithoutAiAgentsNestedInput = {
    create?: XOR<InstitutionCreateWithoutAiAgentsInput, InstitutionUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAiAgentsInput
    upsert?: InstitutionUpsertWithoutAiAgentsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutAiAgentsInput, InstitutionUpdateWithoutAiAgentsInput>, InstitutionUncheckedUpdateWithoutAiAgentsInput>
  }

  export type AIConversationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AIConversationCreateWithoutAgentInput, AIConversationUncheckedCreateWithoutAgentInput> | AIConversationCreateWithoutAgentInput[] | AIConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutAgentInput | AIConversationCreateOrConnectWithoutAgentInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutAgentInput | AIConversationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AIConversationCreateManyAgentInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutAgentInput | AIConversationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutAgentInput | AIConversationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type VirtualClassroomUpdateManyWithoutAiagentNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutAiagentInput, VirtualClassroomUncheckedCreateWithoutAiagentInput> | VirtualClassroomCreateWithoutAiagentInput[] | VirtualClassroomUncheckedCreateWithoutAiagentInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAiagentInput | VirtualClassroomCreateOrConnectWithoutAiagentInput[]
    upsert?: VirtualClassroomUpsertWithWhereUniqueWithoutAiagentInput | VirtualClassroomUpsertWithWhereUniqueWithoutAiagentInput[]
    createMany?: VirtualClassroomCreateManyAiagentInputEnvelope
    set?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    disconnect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    delete?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    update?: VirtualClassroomUpdateWithWhereUniqueWithoutAiagentInput | VirtualClassroomUpdateWithWhereUniqueWithoutAiagentInput[]
    updateMany?: VirtualClassroomUpdateManyWithWhereWithoutAiagentInput | VirtualClassroomUpdateManyWithWhereWithoutAiagentInput[]
    deleteMany?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
  }

  export type AIConversationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AIConversationCreateWithoutAgentInput, AIConversationUncheckedCreateWithoutAgentInput> | AIConversationCreateWithoutAgentInput[] | AIConversationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AIConversationCreateOrConnectWithoutAgentInput | AIConversationCreateOrConnectWithoutAgentInput[]
    upsert?: AIConversationUpsertWithWhereUniqueWithoutAgentInput | AIConversationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AIConversationCreateManyAgentInputEnvelope
    set?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    disconnect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    delete?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    connect?: AIConversationWhereUniqueInput | AIConversationWhereUniqueInput[]
    update?: AIConversationUpdateWithWhereUniqueWithoutAgentInput | AIConversationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AIConversationUpdateManyWithWhereWithoutAgentInput | AIConversationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
  }

  export type VirtualClassroomUncheckedUpdateManyWithoutAiagentNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutAiagentInput, VirtualClassroomUncheckedCreateWithoutAiagentInput> | VirtualClassroomCreateWithoutAiagentInput[] | VirtualClassroomUncheckedCreateWithoutAiagentInput[]
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAiagentInput | VirtualClassroomCreateOrConnectWithoutAiagentInput[]
    upsert?: VirtualClassroomUpsertWithWhereUniqueWithoutAiagentInput | VirtualClassroomUpsertWithWhereUniqueWithoutAiagentInput[]
    createMany?: VirtualClassroomCreateManyAiagentInputEnvelope
    set?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    disconnect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    delete?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    connect?: VirtualClassroomWhereUniqueInput | VirtualClassroomWhereUniqueInput[]
    update?: VirtualClassroomUpdateWithWhereUniqueWithoutAiagentInput | VirtualClassroomUpdateWithWhereUniqueWithoutAiagentInput[]
    updateMany?: VirtualClassroomUpdateManyWithWhereWithoutAiagentInput | VirtualClassroomUpdateManyWithWhereWithoutAiagentInput[]
    deleteMany?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAIConversationInput = {
    create?: XOR<UserCreateWithoutAIConversationInput, UserUncheckedCreateWithoutAIConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAIConversationInput
    connect?: UserWhereUniqueInput
  }

  export type AIAgentCreateNestedOneWithoutConversationsInput = {
    create?: XOR<AIAgentCreateWithoutConversationsInput, AIAgentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutConversationsInput
    connect?: AIAgentWhereUniqueInput
  }

  export type AIMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<AIMessageCreateWithoutConversationInput, AIMessageUncheckedCreateWithoutConversationInput> | AIMessageCreateWithoutConversationInput[] | AIMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AIMessageCreateOrConnectWithoutConversationInput | AIMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AIMessageCreateManyConversationInputEnvelope
    connect?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
  }

  export type AIMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<AIMessageCreateWithoutConversationInput, AIMessageUncheckedCreateWithoutConversationInput> | AIMessageCreateWithoutConversationInput[] | AIMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AIMessageCreateOrConnectWithoutConversationInput | AIMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AIMessageCreateManyConversationInputEnvelope
    connect?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAIConversationNestedInput = {
    create?: XOR<UserCreateWithoutAIConversationInput, UserUncheckedCreateWithoutAIConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAIConversationInput
    upsert?: UserUpsertWithoutAIConversationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAIConversationInput, UserUpdateWithoutAIConversationInput>, UserUncheckedUpdateWithoutAIConversationInput>
  }

  export type AIAgentUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<AIAgentCreateWithoutConversationsInput, AIAgentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: AIAgentCreateOrConnectWithoutConversationsInput
    upsert?: AIAgentUpsertWithoutConversationsInput
    connect?: AIAgentWhereUniqueInput
    update?: XOR<XOR<AIAgentUpdateToOneWithWhereWithoutConversationsInput, AIAgentUpdateWithoutConversationsInput>, AIAgentUncheckedUpdateWithoutConversationsInput>
  }

  export type AIMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AIMessageCreateWithoutConversationInput, AIMessageUncheckedCreateWithoutConversationInput> | AIMessageCreateWithoutConversationInput[] | AIMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AIMessageCreateOrConnectWithoutConversationInput | AIMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AIMessageUpsertWithWhereUniqueWithoutConversationInput | AIMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AIMessageCreateManyConversationInputEnvelope
    set?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    disconnect?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    delete?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    connect?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    update?: AIMessageUpdateWithWhereUniqueWithoutConversationInput | AIMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AIMessageUpdateManyWithWhereWithoutConversationInput | AIMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AIMessageScalarWhereInput | AIMessageScalarWhereInput[]
  }

  export type AIMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AIMessageCreateWithoutConversationInput, AIMessageUncheckedCreateWithoutConversationInput> | AIMessageCreateWithoutConversationInput[] | AIMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AIMessageCreateOrConnectWithoutConversationInput | AIMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AIMessageUpsertWithWhereUniqueWithoutConversationInput | AIMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AIMessageCreateManyConversationInputEnvelope
    set?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    disconnect?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    delete?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    connect?: AIMessageWhereUniqueInput | AIMessageWhereUniqueInput[]
    update?: AIMessageUpdateWithWhereUniqueWithoutConversationInput | AIMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AIMessageUpdateManyWithWhereWithoutConversationInput | AIMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AIMessageScalarWhereInput | AIMessageScalarWhereInput[]
  }

  export type AIConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AIConversationCreateWithoutMessagesInput, AIConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AIConversationCreateOrConnectWithoutMessagesInput
    connect?: AIConversationWhereUniqueInput
  }

  export type AIConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AIConversationCreateWithoutMessagesInput, AIConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AIConversationCreateOrConnectWithoutMessagesInput
    upsert?: AIConversationUpsertWithoutMessagesInput
    connect?: AIConversationWhereUniqueInput
    update?: XOR<XOR<AIConversationUpdateToOneWithWhereWithoutMessagesInput, AIConversationUpdateWithoutMessagesInput>, AIConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutAiUsagesInput = {
    create?: XOR<UserCreateWithoutAiUsagesInput, UserUncheckedCreateWithoutAiUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutAiUsageLogsInput = {
    create?: XOR<InstitutionCreateWithoutAiUsageLogsInput, InstitutionUncheckedCreateWithoutAiUsageLogsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAiUsageLogsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type VirtualClassroomCreateNestedOneWithoutAiUsagesInput = {
    create?: XOR<VirtualClassroomCreateWithoutAiUsagesInput, VirtualClassroomUncheckedCreateWithoutAiUsagesInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAiUsagesInput
    connect?: VirtualClassroomWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiUsagesNestedInput = {
    create?: XOR<UserCreateWithoutAiUsagesInput, UserUncheckedCreateWithoutAiUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiUsagesInput
    upsert?: UserUpsertWithoutAiUsagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiUsagesInput, UserUpdateWithoutAiUsagesInput>, UserUncheckedUpdateWithoutAiUsagesInput>
  }

  export type InstitutionUpdateOneRequiredWithoutAiUsageLogsNestedInput = {
    create?: XOR<InstitutionCreateWithoutAiUsageLogsInput, InstitutionUncheckedCreateWithoutAiUsageLogsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAiUsageLogsInput
    upsert?: InstitutionUpsertWithoutAiUsageLogsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutAiUsageLogsInput, InstitutionUpdateWithoutAiUsageLogsInput>, InstitutionUncheckedUpdateWithoutAiUsageLogsInput>
  }

  export type VirtualClassroomUpdateOneWithoutAiUsagesNestedInput = {
    create?: XOR<VirtualClassroomCreateWithoutAiUsagesInput, VirtualClassroomUncheckedCreateWithoutAiUsagesInput>
    connectOrCreate?: VirtualClassroomCreateOrConnectWithoutAiUsagesInput
    upsert?: VirtualClassroomUpsertWithoutAiUsagesInput
    disconnect?: VirtualClassroomWhereInput | boolean
    delete?: VirtualClassroomWhereInput | boolean
    connect?: VirtualClassroomWhereUniqueInput
    update?: XOR<XOR<VirtualClassroomUpdateToOneWithWhereWithoutAiUsagesInput, VirtualClassroomUpdateWithoutAiUsagesInput>, VirtualClassroomUncheckedUpdateWithoutAiUsagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPreferenceInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    upsert?: UserUpsertWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferenceInput, UserUpdateWithoutNotificationPreferenceInput>, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type AnnouncementCreatetargetRolesInput = {
    set: string[]
  }

  export type InstitutionCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<InstitutionCreateWithoutAnnouncementsInput, InstitutionUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAnnouncementsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnouncementInput = {
    create?: XOR<UserCreateWithoutAnnouncementInput, UserUncheckedCreateWithoutAnnouncementInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementInput
    connect?: UserWhereUniqueInput
  }

  export type AnnouncementUpdatetargetRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutionUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<InstitutionCreateWithoutAnnouncementsInput, InstitutionUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAnnouncementsInput
    upsert?: InstitutionUpsertWithoutAnnouncementsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutAnnouncementsInput, InstitutionUpdateWithoutAnnouncementsInput>, InstitutionUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateOneWithoutAnnouncementNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementInput, UserUncheckedCreateWithoutAnnouncementInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementInput
    upsert?: UserUpsertWithoutAnnouncementInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementInput, UserUpdateWithoutAnnouncementInput>, UserUncheckedUpdateWithoutAnnouncementInput>
  }

  export type InstitutionCreateNestedOneWithoutBackupsInput = {
    create?: XOR<InstitutionCreateWithoutBackupsInput, InstitutionUncheckedCreateWithoutBackupsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutBackupsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDataBackupsInput = {
    create?: XOR<UserCreateWithoutDataBackupsInput, UserUncheckedCreateWithoutDataBackupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataBackupsInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionUpdateOneRequiredWithoutBackupsNestedInput = {
    create?: XOR<InstitutionCreateWithoutBackupsInput, InstitutionUncheckedCreateWithoutBackupsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutBackupsInput
    upsert?: InstitutionUpsertWithoutBackupsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutBackupsInput, InstitutionUpdateWithoutBackupsInput>, InstitutionUncheckedUpdateWithoutBackupsInput>
  }

  export type UserUpdateOneWithoutDataBackupsNestedInput = {
    create?: XOR<UserCreateWithoutDataBackupsInput, UserUncheckedCreateWithoutDataBackupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataBackupsInput
    upsert?: UserUpsertWithoutDataBackupsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataBackupsInput, UserUpdateWithoutDataBackupsInput>, UserUncheckedUpdateWithoutDataBackupsInput>
  }

  export type InstitutionCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<InstitutionCreateWithoutTemplatesInput, InstitutionUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutTemplatesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<UserCreateWithoutTemplatesInput, UserUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<InstitutionCreateWithoutTemplatesInput, InstitutionUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutTemplatesInput
    upsert?: InstitutionUpsertWithoutTemplatesInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutTemplatesInput, InstitutionUpdateWithoutTemplatesInput>, InstitutionUncheckedUpdateWithoutTemplatesInput>
  }

  export type UserUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutTemplatesInput, UserUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplatesInput
    upsert?: UserUpsertWithoutTemplatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTemplatesInput, UserUpdateWithoutTemplatesInput>, UserUncheckedUpdateWithoutTemplatesInput>
  }

  export type InstitutionCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<InstitutionCreateWithoutIntegrationsInput, InstitutionUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutIntegrationsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type InstitutionUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<InstitutionCreateWithoutIntegrationsInput, InstitutionUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutIntegrationsInput
    upsert?: InstitutionUpsertWithoutIntegrationsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutIntegrationsInput, InstitutionUpdateWithoutIntegrationsInput>, InstitutionUncheckedUpdateWithoutIntegrationsInput>
  }

  export type ApiClientCreatescopesInput = {
    set: string[]
  }

  export type InstitutionCreateNestedOneWithoutApiClientsInput = {
    create?: XOR<InstitutionCreateWithoutApiClientsInput, InstitutionUncheckedCreateWithoutApiClientsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutApiClientsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type ApiUsageLogCreateNestedManyWithoutApiClientInput = {
    create?: XOR<ApiUsageLogCreateWithoutApiClientInput, ApiUsageLogUncheckedCreateWithoutApiClientInput> | ApiUsageLogCreateWithoutApiClientInput[] | ApiUsageLogUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutApiClientInput | ApiUsageLogCreateOrConnectWithoutApiClientInput[]
    createMany?: ApiUsageLogCreateManyApiClientInputEnvelope
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
  }

  export type ApiKeyRotationCreateNestedManyWithoutApiClientInput = {
    create?: XOR<ApiKeyRotationCreateWithoutApiClientInput, ApiKeyRotationUncheckedCreateWithoutApiClientInput> | ApiKeyRotationCreateWithoutApiClientInput[] | ApiKeyRotationUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiKeyRotationCreateOrConnectWithoutApiClientInput | ApiKeyRotationCreateOrConnectWithoutApiClientInput[]
    createMany?: ApiKeyRotationCreateManyApiClientInputEnvelope
    connect?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
  }

  export type ApiUsageLogUncheckedCreateNestedManyWithoutApiClientInput = {
    create?: XOR<ApiUsageLogCreateWithoutApiClientInput, ApiUsageLogUncheckedCreateWithoutApiClientInput> | ApiUsageLogCreateWithoutApiClientInput[] | ApiUsageLogUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutApiClientInput | ApiUsageLogCreateOrConnectWithoutApiClientInput[]
    createMany?: ApiUsageLogCreateManyApiClientInputEnvelope
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
  }

  export type ApiKeyRotationUncheckedCreateNestedManyWithoutApiClientInput = {
    create?: XOR<ApiKeyRotationCreateWithoutApiClientInput, ApiKeyRotationUncheckedCreateWithoutApiClientInput> | ApiKeyRotationCreateWithoutApiClientInput[] | ApiKeyRotationUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiKeyRotationCreateOrConnectWithoutApiClientInput | ApiKeyRotationCreateOrConnectWithoutApiClientInput[]
    createMany?: ApiKeyRotationCreateManyApiClientInputEnvelope
    connect?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
  }

  export type ApiClientUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutionUpdateOneWithoutApiClientsNestedInput = {
    create?: XOR<InstitutionCreateWithoutApiClientsInput, InstitutionUncheckedCreateWithoutApiClientsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutApiClientsInput
    upsert?: InstitutionUpsertWithoutApiClientsInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutApiClientsInput, InstitutionUpdateWithoutApiClientsInput>, InstitutionUncheckedUpdateWithoutApiClientsInput>
  }

  export type ApiUsageLogUpdateManyWithoutApiClientNestedInput = {
    create?: XOR<ApiUsageLogCreateWithoutApiClientInput, ApiUsageLogUncheckedCreateWithoutApiClientInput> | ApiUsageLogCreateWithoutApiClientInput[] | ApiUsageLogUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutApiClientInput | ApiUsageLogCreateOrConnectWithoutApiClientInput[]
    upsert?: ApiUsageLogUpsertWithWhereUniqueWithoutApiClientInput | ApiUsageLogUpsertWithWhereUniqueWithoutApiClientInput[]
    createMany?: ApiUsageLogCreateManyApiClientInputEnvelope
    set?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    disconnect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    delete?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    update?: ApiUsageLogUpdateWithWhereUniqueWithoutApiClientInput | ApiUsageLogUpdateWithWhereUniqueWithoutApiClientInput[]
    updateMany?: ApiUsageLogUpdateManyWithWhereWithoutApiClientInput | ApiUsageLogUpdateManyWithWhereWithoutApiClientInput[]
    deleteMany?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
  }

  export type ApiKeyRotationUpdateManyWithoutApiClientNestedInput = {
    create?: XOR<ApiKeyRotationCreateWithoutApiClientInput, ApiKeyRotationUncheckedCreateWithoutApiClientInput> | ApiKeyRotationCreateWithoutApiClientInput[] | ApiKeyRotationUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiKeyRotationCreateOrConnectWithoutApiClientInput | ApiKeyRotationCreateOrConnectWithoutApiClientInput[]
    upsert?: ApiKeyRotationUpsertWithWhereUniqueWithoutApiClientInput | ApiKeyRotationUpsertWithWhereUniqueWithoutApiClientInput[]
    createMany?: ApiKeyRotationCreateManyApiClientInputEnvelope
    set?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    disconnect?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    delete?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    connect?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    update?: ApiKeyRotationUpdateWithWhereUniqueWithoutApiClientInput | ApiKeyRotationUpdateWithWhereUniqueWithoutApiClientInput[]
    updateMany?: ApiKeyRotationUpdateManyWithWhereWithoutApiClientInput | ApiKeyRotationUpdateManyWithWhereWithoutApiClientInput[]
    deleteMany?: ApiKeyRotationScalarWhereInput | ApiKeyRotationScalarWhereInput[]
  }

  export type ApiUsageLogUncheckedUpdateManyWithoutApiClientNestedInput = {
    create?: XOR<ApiUsageLogCreateWithoutApiClientInput, ApiUsageLogUncheckedCreateWithoutApiClientInput> | ApiUsageLogCreateWithoutApiClientInput[] | ApiUsageLogUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutApiClientInput | ApiUsageLogCreateOrConnectWithoutApiClientInput[]
    upsert?: ApiUsageLogUpsertWithWhereUniqueWithoutApiClientInput | ApiUsageLogUpsertWithWhereUniqueWithoutApiClientInput[]
    createMany?: ApiUsageLogCreateManyApiClientInputEnvelope
    set?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    disconnect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    delete?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    update?: ApiUsageLogUpdateWithWhereUniqueWithoutApiClientInput | ApiUsageLogUpdateWithWhereUniqueWithoutApiClientInput[]
    updateMany?: ApiUsageLogUpdateManyWithWhereWithoutApiClientInput | ApiUsageLogUpdateManyWithWhereWithoutApiClientInput[]
    deleteMany?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
  }

  export type ApiKeyRotationUncheckedUpdateManyWithoutApiClientNestedInput = {
    create?: XOR<ApiKeyRotationCreateWithoutApiClientInput, ApiKeyRotationUncheckedCreateWithoutApiClientInput> | ApiKeyRotationCreateWithoutApiClientInput[] | ApiKeyRotationUncheckedCreateWithoutApiClientInput[]
    connectOrCreate?: ApiKeyRotationCreateOrConnectWithoutApiClientInput | ApiKeyRotationCreateOrConnectWithoutApiClientInput[]
    upsert?: ApiKeyRotationUpsertWithWhereUniqueWithoutApiClientInput | ApiKeyRotationUpsertWithWhereUniqueWithoutApiClientInput[]
    createMany?: ApiKeyRotationCreateManyApiClientInputEnvelope
    set?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    disconnect?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    delete?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    connect?: ApiKeyRotationWhereUniqueInput | ApiKeyRotationWhereUniqueInput[]
    update?: ApiKeyRotationUpdateWithWhereUniqueWithoutApiClientInput | ApiKeyRotationUpdateWithWhereUniqueWithoutApiClientInput[]
    updateMany?: ApiKeyRotationUpdateManyWithWhereWithoutApiClientInput | ApiKeyRotationUpdateManyWithWhereWithoutApiClientInput[]
    deleteMany?: ApiKeyRotationScalarWhereInput | ApiKeyRotationScalarWhereInput[]
  }

  export type ApiClientCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ApiClientCreateWithoutUsageLogsInput, ApiClientUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiClientCreateOrConnectWithoutUsageLogsInput
    connect?: ApiClientWhereUniqueInput
  }

  export type ApiClientUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<ApiClientCreateWithoutUsageLogsInput, ApiClientUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiClientCreateOrConnectWithoutUsageLogsInput
    upsert?: ApiClientUpsertWithoutUsageLogsInput
    connect?: ApiClientWhereUniqueInput
    update?: XOR<XOR<ApiClientUpdateToOneWithWhereWithoutUsageLogsInput, ApiClientUpdateWithoutUsageLogsInput>, ApiClientUncheckedUpdateWithoutUsageLogsInput>
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type InstitutionCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<InstitutionCreateWithoutWebhooksInput, InstitutionUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutWebhooksInput
    connect?: InstitutionWhereUniqueInput
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutionUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<InstitutionCreateWithoutWebhooksInput, InstitutionUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutWebhooksInput
    upsert?: InstitutionUpsertWithoutWebhooksInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutWebhooksInput, InstitutionUpdateWithoutWebhooksInput>, InstitutionUncheckedUpdateWithoutWebhooksInput>
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
  }

  export type WebhookUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookUpsertWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutDeliveriesInput, WebhookUpdateWithoutDeliveriesInput>, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ApiClientCreateNestedOneWithoutRotationsInput = {
    create?: XOR<ApiClientCreateWithoutRotationsInput, ApiClientUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: ApiClientCreateOrConnectWithoutRotationsInput
    connect?: ApiClientWhereUniqueInput
  }

  export type ApiClientUpdateOneRequiredWithoutRotationsNestedInput = {
    create?: XOR<ApiClientCreateWithoutRotationsInput, ApiClientUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: ApiClientCreateOrConnectWithoutRotationsInput
    upsert?: ApiClientUpsertWithoutRotationsInput
    connect?: ApiClientWhereUniqueInput
    update?: XOR<XOR<ApiClientUpdateToOneWithWhereWithoutRotationsInput, ApiClientUpdateWithoutRotationsInput>, ApiClientUncheckedUpdateWithoutRotationsInput>
  }

  export type UserCreateNestedOneWithoutDashboardsInput = {
    create?: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDashboardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDashboardsNestedInput = {
    create?: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDashboardsInput
    upsert?: UserUpsertWithoutDashboardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDashboardsInput, UserUpdateWithoutDashboardsInput>, UserUncheckedUpdateWithoutDashboardsInput>
  }

  export type TeacherCreatespecialtiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type InstitutionCreateNestedOneWithoutInstitutionLogsInput = {
    create?: XOR<InstitutionCreateWithoutInstitutionLogsInput, InstitutionUncheckedCreateWithoutInstitutionLogsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutInstitutionLogsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionUpdateOneRequiredWithoutInstitutionLogsNestedInput = {
    create?: XOR<InstitutionCreateWithoutInstitutionLogsInput, InstitutionUncheckedCreateWithoutInstitutionLogsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutInstitutionLogsInput
    upsert?: InstitutionUpsertWithoutInstitutionLogsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutInstitutionLogsInput, InstitutionUpdateWithoutInstitutionLogsInput>, InstitutionUncheckedUpdateWithoutInstitutionLogsInput>
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type NestedEnumPolicyEffectFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyEffect | EnumPolicyEffectFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyEffectFilter<$PrismaModel> | $Enums.PolicyEffect
  }

  export type NestedEnumPolicyEffectWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyEffect | EnumPolicyEffectFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyEffect[] | ListEnumPolicyEffectFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyEffectWithAggregatesFilter<$PrismaModel> | $Enums.PolicyEffect
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPolicyEffectFilter<$PrismaModel>
    _max?: NestedEnumPolicyEffectFilter<$PrismaModel>
  }

  export type NestedEnumLevelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelType | EnumLevelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelTypeFilter<$PrismaModel> | $Enums.LevelType
  }

  export type NestedEnumLevelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelType | EnumLevelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelType[] | ListEnumLevelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelTypeWithAggregatesFilter<$PrismaModel> | $Enums.LevelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelTypeFilter<$PrismaModel>
    _max?: NestedEnumLevelTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumGradeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeFilter<$PrismaModel> | $Enums.GradeType
  }

  export type NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GradeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGradeTypeFilter<$PrismaModel>
    _max?: NestedEnumGradeTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumCertificateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeFilter<$PrismaModel> | $Enums.CertificateType
  }

  export type NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificateTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificateTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InstitutionCreateWithoutPlanInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutPlanInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutPlanInput, InstitutionUncheckedCreateWithoutPlanInput>
  }

  export type InstitutionCreateManyPlanInputEnvelope = {
    data: InstitutionCreateManyPlanInput | InstitutionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionSubscriptionCreateWithoutPlanInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutSubscriptionsInput
    payments?: InstitutionPaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type InstitutionSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    institutionId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    payments?: InstitutionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type InstitutionSubscriptionCreateOrConnectWithoutPlanInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    create: XOR<InstitutionSubscriptionCreateWithoutPlanInput, InstitutionSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type InstitutionSubscriptionCreateManyPlanInputEnvelope = {
    data: InstitutionSubscriptionCreateManyPlanInput | InstitutionSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithWhereUniqueWithoutPlanInput = {
    where: InstitutionWhereUniqueInput
    update: XOR<InstitutionUpdateWithoutPlanInput, InstitutionUncheckedUpdateWithoutPlanInput>
    create: XOR<InstitutionCreateWithoutPlanInput, InstitutionUncheckedCreateWithoutPlanInput>
  }

  export type InstitutionUpdateWithWhereUniqueWithoutPlanInput = {
    where: InstitutionWhereUniqueInput
    data: XOR<InstitutionUpdateWithoutPlanInput, InstitutionUncheckedUpdateWithoutPlanInput>
  }

  export type InstitutionUpdateManyWithWhereWithoutPlanInput = {
    where: InstitutionScalarWhereInput
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyWithoutPlanInput>
  }

  export type InstitutionScalarWhereInput = {
    AND?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
    OR?: InstitutionScalarWhereInput[]
    NOT?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    slug?: StringFilter<"Institution"> | string
    contactEmail?: StringFilter<"Institution"> | string
    phone?: StringNullableFilter<"Institution"> | string | null
    address?: JsonNullableFilter<"Institution">
    planId?: StringNullableFilter<"Institution"> | string | null
    settings?: JsonNullableFilter<"Institution">
    status?: StringNullableFilter<"Institution"> | string | null
    createdAt?: DateTimeFilter<"Institution"> | Date | string
  }

  export type InstitutionSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    update: XOR<InstitutionSubscriptionUpdateWithoutPlanInput, InstitutionSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<InstitutionSubscriptionCreateWithoutPlanInput, InstitutionSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type InstitutionSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    data: XOR<InstitutionSubscriptionUpdateWithoutPlanInput, InstitutionSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type InstitutionSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: InstitutionSubscriptionScalarWhereInput
    data: XOR<InstitutionSubscriptionUpdateManyMutationInput, InstitutionSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type InstitutionSubscriptionScalarWhereInput = {
    AND?: InstitutionSubscriptionScalarWhereInput | InstitutionSubscriptionScalarWhereInput[]
    OR?: InstitutionSubscriptionScalarWhereInput[]
    NOT?: InstitutionSubscriptionScalarWhereInput | InstitutionSubscriptionScalarWhereInput[]
    id?: StringFilter<"InstitutionSubscription"> | string
    institutionId?: StringFilter<"InstitutionSubscription"> | string
    planId?: StringFilter<"InstitutionSubscription"> | string
    startDate?: DateTimeFilter<"InstitutionSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"InstitutionSubscription"> | Date | string | null
    status?: EnumSubscriptionStatusFilter<"InstitutionSubscription"> | $Enums.SubscriptionStatus
    autoRenew?: BoolFilter<"InstitutionSubscription"> | boolean
    billingCycle?: StringNullableFilter<"InstitutionSubscription"> | string | null
    createdAt?: DateTimeFilter<"InstitutionSubscription"> | Date | string
  }

  export type PlanCreateWithoutInstitutionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    InstitutionSubscription?: InstitutionSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutInstitutionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    InstitutionSubscription?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutInstitutionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutInstitutionsInput, PlanUncheckedCreateWithoutInstitutionsInput>
  }

  export type UserCreateWithoutInstitutionInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutInstitutionInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutInstitutionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstitutionInput, UserUncheckedCreateWithoutInstitutionInput>
  }

  export type UserCreateManyInstitutionInputEnvelope = {
    data: UserCreateManyInstitutionInput | UserCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutInstitutionInput = {
    id?: string
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutInstitutionInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutInstitutionInput, RoleUncheckedCreateWithoutInstitutionInput>
  }

  export type RoleCreateManyInstitutionInputEnvelope = {
    data: RoleCreateManyInstitutionInput | RoleCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type CareerCreateWithoutInstitutionInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCareersInput
    courses?: CourseCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodCreateNestedManyWithoutCareerInput
    students?: StudentCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput
    students?: StudentUncheckedCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutInstitutionInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutInstitutionInput, CareerUncheckedCreateWithoutInstitutionInput>
  }

  export type CareerCreateManyInstitutionInputEnvelope = {
    data: CareerCreateManyInstitutionInput | CareerCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionSubscriptionCreateWithoutInstitutionInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    plan: PlanCreateNestedOneWithoutInstitutionSubscriptionInput
    payments?: InstitutionPaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput = {
    id?: string
    planId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    payments?: InstitutionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type InstitutionSubscriptionCreateOrConnectWithoutInstitutionInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    create: XOR<InstitutionSubscriptionCreateWithoutInstitutionInput, InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionSubscriptionCreateManyInstitutionInputEnvelope = {
    data: InstitutionSubscriptionCreateManyInstitutionInput | InstitutionSubscriptionCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionPaymentCreateWithoutInstitutionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
    subscription?: InstitutionSubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type InstitutionPaymentUncheckedCreateWithoutInstitutionInput = {
    id?: string
    subscriptionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
  }

  export type InstitutionPaymentCreateOrConnectWithoutInstitutionInput = {
    where: InstitutionPaymentWhereUniqueInput
    create: XOR<InstitutionPaymentCreateWithoutInstitutionInput, InstitutionPaymentUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionPaymentCreateManyInstitutionInputEnvelope = {
    data: InstitutionPaymentCreateManyInstitutionInput | InstitutionPaymentCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionLogCreateWithoutInstitutionInput = {
    id?: string
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type InstitutionLogUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId?: string | null
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InstitutionLogCreateOrConnectWithoutInstitutionInput = {
    where: InstitutionLogWhereUniqueInput
    create: XOR<InstitutionLogCreateWithoutInstitutionInput, InstitutionLogUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionLogCreateManyInstitutionInputEnvelope = {
    data: InstitutionLogCreateManyInstitutionInput | InstitutionLogCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type AIUsageLogCreateWithoutInstitutionInput = {
    id?: string
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiUsagesInput
    classroom?: VirtualClassroomCreateNestedOneWithoutAiUsagesInput
  }

  export type AIUsageLogUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId: string
    classroomId?: string | null
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AIUsageLogCreateOrConnectWithoutInstitutionInput = {
    where: AIUsageLogWhereUniqueInput
    create: XOR<AIUsageLogCreateWithoutInstitutionInput, AIUsageLogUncheckedCreateWithoutInstitutionInput>
  }

  export type AIUsageLogCreateManyInstitutionInputEnvelope = {
    data: AIUsageLogCreateManyInstitutionInput | AIUsageLogCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutInstitutionInput = {
    id?: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type TemplateCreateOrConnectWithoutInstitutionInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutInstitutionInput, TemplateUncheckedCreateWithoutInstitutionInput>
  }

  export type TemplateCreateManyInstitutionInputEnvelope = {
    data: TemplateCreateManyInstitutionInput | TemplateCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutInstitutionInput = {
    id?: string
    name: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutInstitutionInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutInstitutionInput, IntegrationUncheckedCreateWithoutInstitutionInput>
  }

  export type IntegrationCreateManyInstitutionInputEnvelope = {
    data: IntegrationCreateManyInstitutionInput | IntegrationCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type ApiClientCreateWithoutInstitutionInput = {
    id?: string
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    usageLogs?: ApiUsageLogCreateNestedManyWithoutApiClientInput
    rotations?: ApiKeyRotationCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientUncheckedCreateWithoutInstitutionInput = {
    id?: string
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    usageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutApiClientInput
    rotations?: ApiKeyRotationUncheckedCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientCreateOrConnectWithoutInstitutionInput = {
    where: ApiClientWhereUniqueInput
    create: XOR<ApiClientCreateWithoutInstitutionInput, ApiClientUncheckedCreateWithoutInstitutionInput>
  }

  export type ApiClientCreateManyInstitutionInputEnvelope = {
    data: ApiClientCreateManyInstitutionInput | ApiClientCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutInstitutionInput = {
    id?: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateWithoutInstitutionInput = {
    id?: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutInstitutionInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutInstitutionInput, AnnouncementUncheckedCreateWithoutInstitutionInput>
  }

  export type AnnouncementCreateManyInstitutionInputEnvelope = {
    data: AnnouncementCreateManyInstitutionInput | AnnouncementCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type DataBackupCreateWithoutInstitutionInput = {
    id?: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutDataBackupsInput
  }

  export type DataBackupUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type DataBackupCreateOrConnectWithoutInstitutionInput = {
    where: DataBackupWhereUniqueInput
    create: XOR<DataBackupCreateWithoutInstitutionInput, DataBackupUncheckedCreateWithoutInstitutionInput>
  }

  export type DataBackupCreateManyInstitutionInputEnvelope = {
    data: DataBackupCreateManyInstitutionInput | DataBackupCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type FeeScheduleCreateWithoutInstitutionInput = {
    id?: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    career?: CareerCreateNestedOneWithoutFeeScheduleInput
    installmentsList?: FeeInstallmentCreateNestedManyWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleUncheckedCreateWithoutInstitutionInput = {
    id?: string
    careerId?: string | null
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    installmentsList?: FeeInstallmentUncheckedCreateNestedManyWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleCreateOrConnectWithoutInstitutionInput = {
    where: FeeScheduleWhereUniqueInput
    create: XOR<FeeScheduleCreateWithoutInstitutionInput, FeeScheduleUncheckedCreateWithoutInstitutionInput>
  }

  export type FeeScheduleCreateManyInstitutionInputEnvelope = {
    data: FeeScheduleCreateManyInstitutionInput | FeeScheduleCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type ABACPolicyCreateWithoutInstitutionInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: $Enums.PolicyEffect
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ABACPolicyUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: $Enums.PolicyEffect
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ABACPolicyCreateOrConnectWithoutInstitutionInput = {
    where: ABACPolicyWhereUniqueInput
    create: XOR<ABACPolicyCreateWithoutInstitutionInput, ABACPolicyUncheckedCreateWithoutInstitutionInput>
  }

  export type ABACPolicyCreateManyInstitutionInputEnvelope = {
    data: ABACPolicyCreateManyInstitutionInput | ABACPolicyCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutInstitutionInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInstitutionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput>
  }

  export type StudentCreateManyInstitutionInputEnvelope = {
    data: StudentCreateManyInstitutionInput | StudentCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type TutorProfileCreateWithoutInstitutionInput = {
    id?: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTutorProfileInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutTutorInput
  }

  export type TutorProfileUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorProfileCreateOrConnectWithoutInstitutionInput = {
    where: TutorProfileWhereUniqueInput
    create: XOR<TutorProfileCreateWithoutInstitutionInput, TutorProfileUncheckedCreateWithoutInstitutionInput>
  }

  export type TutorProfileCreateManyInstitutionInputEnvelope = {
    data: TutorProfileCreateManyInstitutionInput | TutorProfileCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type StudentPaymentCreateWithoutInstitutionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutPaymentsInput
    feeInstallment?: FeeInstallmentCreateNestedOneWithoutStudentPaymentsInput
  }

  export type StudentPaymentUncheckedCreateWithoutInstitutionInput = {
    id?: string
    studentId: string
    feeInstallmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudentPaymentCreateOrConnectWithoutInstitutionInput = {
    where: StudentPaymentWhereUniqueInput
    create: XOR<StudentPaymentCreateWithoutInstitutionInput, StudentPaymentUncheckedCreateWithoutInstitutionInput>
  }

  export type StudentPaymentCreateManyInstitutionInputEnvelope = {
    data: StudentPaymentCreateManyInstitutionInput | StudentPaymentCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type AIAgentCreateWithoutInstitutionInput = {
    id?: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    conversations?: AIConversationCreateNestedManyWithoutAgentInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutAiagentInput
  }

  export type AIAgentUncheckedCreateWithoutInstitutionInput = {
    id?: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    conversations?: AIConversationUncheckedCreateNestedManyWithoutAgentInput
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutAiagentInput
  }

  export type AIAgentCreateOrConnectWithoutInstitutionInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutInstitutionInput, AIAgentUncheckedCreateWithoutInstitutionInput>
  }

  export type AIAgentCreateManyInstitutionInputEnvelope = {
    data: AIAgentCreateManyInstitutionInput | AIAgentCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutInstitutionInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookCreateOrConnectWithoutInstitutionInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutInstitutionInput, WebhookUncheckedCreateWithoutInstitutionInput>
  }

  export type WebhookCreateManyInstitutionInputEnvelope = {
    data: WebhookCreateManyInstitutionInput | WebhookCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithoutInstitutionsInput = {
    update: XOR<PlanUpdateWithoutInstitutionsInput, PlanUncheckedUpdateWithoutInstitutionsInput>
    create: XOR<PlanCreateWithoutInstitutionsInput, PlanUncheckedCreateWithoutInstitutionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutInstitutionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutInstitutionsInput, PlanUncheckedUpdateWithoutInstitutionsInput>
  }

  export type PlanUpdateWithoutInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InstitutionSubscription?: InstitutionSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InstitutionSubscription?: InstitutionSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutInstitutionInput, UserUncheckedUpdateWithoutInstitutionInput>
    create: XOR<UserCreateWithoutInstitutionInput, UserUncheckedCreateWithoutInstitutionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutInstitutionInput, UserUncheckedUpdateWithoutInstitutionInput>
  }

  export type UserUpdateManyWithWhereWithoutInstitutionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    institutionId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    ci?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    attributes?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type RoleUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutInstitutionInput, RoleUncheckedUpdateWithoutInstitutionInput>
    create: XOR<RoleCreateWithoutInstitutionInput, RoleUncheckedCreateWithoutInstitutionInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutInstitutionInput, RoleUncheckedUpdateWithoutInstitutionInput>
  }

  export type RoleUpdateManyWithWhereWithoutInstitutionInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    institutionId?: StringNullableFilter<"Role"> | string | null
    name?: EnumRoleNameFilter<"Role"> | $Enums.RoleName
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type CareerUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: CareerWhereUniqueInput
    update: XOR<CareerUpdateWithoutInstitutionInput, CareerUncheckedUpdateWithoutInstitutionInput>
    create: XOR<CareerCreateWithoutInstitutionInput, CareerUncheckedCreateWithoutInstitutionInput>
  }

  export type CareerUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: CareerWhereUniqueInput
    data: XOR<CareerUpdateWithoutInstitutionInput, CareerUncheckedUpdateWithoutInstitutionInput>
  }

  export type CareerUpdateManyWithWhereWithoutInstitutionInput = {
    where: CareerScalarWhereInput
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type CareerScalarWhereInput = {
    AND?: CareerScalarWhereInput | CareerScalarWhereInput[]
    OR?: CareerScalarWhereInput[]
    NOT?: CareerScalarWhereInput | CareerScalarWhereInput[]
    id?: StringFilter<"Career"> | string
    institutionId?: StringFilter<"Career"> | string
    name?: StringFilter<"Career"> | string
    code?: StringNullableFilter<"Career"> | string | null
    level?: EnumLevelTypeFilter<"Career"> | $Enums.LevelType
    description?: StringNullableFilter<"Career"> | string | null
    createdById?: StringNullableFilter<"Career"> | string | null
    createdAt?: DateTimeFilter<"Career"> | Date | string
  }

  export type InstitutionSubscriptionUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    update: XOR<InstitutionSubscriptionUpdateWithoutInstitutionInput, InstitutionSubscriptionUncheckedUpdateWithoutInstitutionInput>
    create: XOR<InstitutionSubscriptionCreateWithoutInstitutionInput, InstitutionSubscriptionUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionSubscriptionUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    data: XOR<InstitutionSubscriptionUpdateWithoutInstitutionInput, InstitutionSubscriptionUncheckedUpdateWithoutInstitutionInput>
  }

  export type InstitutionSubscriptionUpdateManyWithWhereWithoutInstitutionInput = {
    where: InstitutionSubscriptionScalarWhereInput
    data: XOR<InstitutionSubscriptionUpdateManyMutationInput, InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type InstitutionPaymentUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: InstitutionPaymentWhereUniqueInput
    update: XOR<InstitutionPaymentUpdateWithoutInstitutionInput, InstitutionPaymentUncheckedUpdateWithoutInstitutionInput>
    create: XOR<InstitutionPaymentCreateWithoutInstitutionInput, InstitutionPaymentUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionPaymentUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: InstitutionPaymentWhereUniqueInput
    data: XOR<InstitutionPaymentUpdateWithoutInstitutionInput, InstitutionPaymentUncheckedUpdateWithoutInstitutionInput>
  }

  export type InstitutionPaymentUpdateManyWithWhereWithoutInstitutionInput = {
    where: InstitutionPaymentScalarWhereInput
    data: XOR<InstitutionPaymentUpdateManyMutationInput, InstitutionPaymentUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type InstitutionPaymentScalarWhereInput = {
    AND?: InstitutionPaymentScalarWhereInput | InstitutionPaymentScalarWhereInput[]
    OR?: InstitutionPaymentScalarWhereInput[]
    NOT?: InstitutionPaymentScalarWhereInput | InstitutionPaymentScalarWhereInput[]
    id?: StringFilter<"InstitutionPayment"> | string
    institutionId?: StringFilter<"InstitutionPayment"> | string
    subscriptionId?: StringNullableFilter<"InstitutionPayment"> | string | null
    amount?: DecimalFilter<"InstitutionPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"InstitutionPayment"> | string
    method?: EnumPaymentMethodFilter<"InstitutionPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"InstitutionPayment"> | $Enums.PaymentStatus
    gatewayData?: JsonNullableFilter<"InstitutionPayment">
    reference?: StringNullableFilter<"InstitutionPayment"> | string | null
    createdAt?: DateTimeFilter<"InstitutionPayment"> | Date | string
  }

  export type InstitutionLogUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: InstitutionLogWhereUniqueInput
    update: XOR<InstitutionLogUpdateWithoutInstitutionInput, InstitutionLogUncheckedUpdateWithoutInstitutionInput>
    create: XOR<InstitutionLogCreateWithoutInstitutionInput, InstitutionLogUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionLogUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: InstitutionLogWhereUniqueInput
    data: XOR<InstitutionLogUpdateWithoutInstitutionInput, InstitutionLogUncheckedUpdateWithoutInstitutionInput>
  }

  export type InstitutionLogUpdateManyWithWhereWithoutInstitutionInput = {
    where: InstitutionLogScalarWhereInput
    data: XOR<InstitutionLogUpdateManyMutationInput, InstitutionLogUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type InstitutionLogScalarWhereInput = {
    AND?: InstitutionLogScalarWhereInput | InstitutionLogScalarWhereInput[]
    OR?: InstitutionLogScalarWhereInput[]
    NOT?: InstitutionLogScalarWhereInput | InstitutionLogScalarWhereInput[]
    id?: StringFilter<"InstitutionLog"> | string
    institutionId?: StringFilter<"InstitutionLog"> | string
    userId?: StringNullableFilter<"InstitutionLog"> | string | null
    module?: StringNullableFilter<"InstitutionLog"> | string | null
    action?: StringFilter<"InstitutionLog"> | string
    data?: JsonNullableFilter<"InstitutionLog">
    ip?: StringNullableFilter<"InstitutionLog"> | string | null
    userAgent?: StringNullableFilter<"InstitutionLog"> | string | null
    createdAt?: DateTimeFilter<"InstitutionLog"> | Date | string
  }

  export type AIUsageLogUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: AIUsageLogWhereUniqueInput
    update: XOR<AIUsageLogUpdateWithoutInstitutionInput, AIUsageLogUncheckedUpdateWithoutInstitutionInput>
    create: XOR<AIUsageLogCreateWithoutInstitutionInput, AIUsageLogUncheckedCreateWithoutInstitutionInput>
  }

  export type AIUsageLogUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: AIUsageLogWhereUniqueInput
    data: XOR<AIUsageLogUpdateWithoutInstitutionInput, AIUsageLogUncheckedUpdateWithoutInstitutionInput>
  }

  export type AIUsageLogUpdateManyWithWhereWithoutInstitutionInput = {
    where: AIUsageLogScalarWhereInput
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type AIUsageLogScalarWhereInput = {
    AND?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
    OR?: AIUsageLogScalarWhereInput[]
    NOT?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
    id?: StringFilter<"AIUsageLog"> | string
    userId?: StringFilter<"AIUsageLog"> | string
    institutionId?: StringFilter<"AIUsageLog"> | string
    classroomId?: StringNullableFilter<"AIUsageLog"> | string | null
    promptSummary?: StringNullableFilter<"AIUsageLog"> | string | null
    responseSummary?: StringNullableFilter<"AIUsageLog"> | string | null
    tokensUsed?: IntNullableFilter<"AIUsageLog"> | number | null
    cost?: DecimalNullableFilter<"AIUsageLog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
  }

  export type TemplateUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutInstitutionInput, TemplateUncheckedUpdateWithoutInstitutionInput>
    create: XOR<TemplateCreateWithoutInstitutionInput, TemplateUncheckedCreateWithoutInstitutionInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutInstitutionInput, TemplateUncheckedUpdateWithoutInstitutionInput>
  }

  export type TemplateUpdateManyWithWhereWithoutInstitutionInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type TemplateScalarWhereInput = {
    AND?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    OR?: TemplateScalarWhereInput[]
    NOT?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    id?: StringFilter<"Template"> | string
    institutionId?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    type?: StringFilter<"Template"> | string
    body?: StringFilter<"Template"> | string
    metadata?: JsonNullableFilter<"Template">
    createdById?: StringNullableFilter<"Template"> | string | null
    createdAt?: DateTimeFilter<"Template"> | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutInstitutionInput, IntegrationUncheckedUpdateWithoutInstitutionInput>
    create: XOR<IntegrationCreateWithoutInstitutionInput, IntegrationUncheckedCreateWithoutInstitutionInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutInstitutionInput, IntegrationUncheckedUpdateWithoutInstitutionInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutInstitutionInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    institutionId?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonNullableFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type ApiClientUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: ApiClientWhereUniqueInput
    update: XOR<ApiClientUpdateWithoutInstitutionInput, ApiClientUncheckedUpdateWithoutInstitutionInput>
    create: XOR<ApiClientCreateWithoutInstitutionInput, ApiClientUncheckedCreateWithoutInstitutionInput>
  }

  export type ApiClientUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: ApiClientWhereUniqueInput
    data: XOR<ApiClientUpdateWithoutInstitutionInput, ApiClientUncheckedUpdateWithoutInstitutionInput>
  }

  export type ApiClientUpdateManyWithWhereWithoutInstitutionInput = {
    where: ApiClientScalarWhereInput
    data: XOR<ApiClientUpdateManyMutationInput, ApiClientUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type ApiClientScalarWhereInput = {
    AND?: ApiClientScalarWhereInput | ApiClientScalarWhereInput[]
    OR?: ApiClientScalarWhereInput[]
    NOT?: ApiClientScalarWhereInput | ApiClientScalarWhereInput[]
    id?: StringFilter<"ApiClient"> | string
    institutionId?: StringNullableFilter<"ApiClient"> | string | null
    clientId?: StringFilter<"ApiClient"> | string
    clientName?: StringFilter<"ApiClient"> | string
    clientType?: StringFilter<"ApiClient"> | string
    apiKeyHash?: StringFilter<"ApiClient"> | string
    scopes?: StringNullableListFilter<"ApiClient">
    isActive?: BoolFilter<"ApiClient"> | boolean
    createdAt?: DateTimeFilter<"ApiClient"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutInstitutionInput, AnnouncementUncheckedUpdateWithoutInstitutionInput>
    create: XOR<AnnouncementCreateWithoutInstitutionInput, AnnouncementUncheckedCreateWithoutInstitutionInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutInstitutionInput, AnnouncementUncheckedUpdateWithoutInstitutionInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutInstitutionInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    institutionId?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    body?: StringFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    startsAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    createdById?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type DataBackupUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: DataBackupWhereUniqueInput
    update: XOR<DataBackupUpdateWithoutInstitutionInput, DataBackupUncheckedUpdateWithoutInstitutionInput>
    create: XOR<DataBackupCreateWithoutInstitutionInput, DataBackupUncheckedCreateWithoutInstitutionInput>
  }

  export type DataBackupUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: DataBackupWhereUniqueInput
    data: XOR<DataBackupUpdateWithoutInstitutionInput, DataBackupUncheckedUpdateWithoutInstitutionInput>
  }

  export type DataBackupUpdateManyWithWhereWithoutInstitutionInput = {
    where: DataBackupScalarWhereInput
    data: XOR<DataBackupUpdateManyMutationInput, DataBackupUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type DataBackupScalarWhereInput = {
    AND?: DataBackupScalarWhereInput | DataBackupScalarWhereInput[]
    OR?: DataBackupScalarWhereInput[]
    NOT?: DataBackupScalarWhereInput | DataBackupScalarWhereInput[]
    id?: StringFilter<"DataBackup"> | string
    institutionId?: StringFilter<"DataBackup"> | string
    name?: StringFilter<"DataBackup"> | string
    description?: StringNullableFilter<"DataBackup"> | string | null
    storageUrl?: StringFilter<"DataBackup"> | string
    sizeBytes?: IntNullableFilter<"DataBackup"> | number | null
    createdById?: StringNullableFilter<"DataBackup"> | string | null
    createdAt?: DateTimeFilter<"DataBackup"> | Date | string
  }

  export type FeeScheduleUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: FeeScheduleWhereUniqueInput
    update: XOR<FeeScheduleUpdateWithoutInstitutionInput, FeeScheduleUncheckedUpdateWithoutInstitutionInput>
    create: XOR<FeeScheduleCreateWithoutInstitutionInput, FeeScheduleUncheckedCreateWithoutInstitutionInput>
  }

  export type FeeScheduleUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: FeeScheduleWhereUniqueInput
    data: XOR<FeeScheduleUpdateWithoutInstitutionInput, FeeScheduleUncheckedUpdateWithoutInstitutionInput>
  }

  export type FeeScheduleUpdateManyWithWhereWithoutInstitutionInput = {
    where: FeeScheduleScalarWhereInput
    data: XOR<FeeScheduleUpdateManyMutationInput, FeeScheduleUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type FeeScheduleScalarWhereInput = {
    AND?: FeeScheduleScalarWhereInput | FeeScheduleScalarWhereInput[]
    OR?: FeeScheduleScalarWhereInput[]
    NOT?: FeeScheduleScalarWhereInput | FeeScheduleScalarWhereInput[]
    id?: StringFilter<"FeeSchedule"> | string
    institutionId?: StringFilter<"FeeSchedule"> | string
    careerId?: StringNullableFilter<"FeeSchedule"> | string | null
    name?: StringFilter<"FeeSchedule"> | string
    totalAmount?: DecimalFilter<"FeeSchedule"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"FeeSchedule"> | string
    installments?: IntFilter<"FeeSchedule"> | number
    frequency?: StringNullableFilter<"FeeSchedule"> | string | null
    metadata?: JsonNullableFilter<"FeeSchedule">
    createdAt?: DateTimeFilter<"FeeSchedule"> | Date | string
  }

  export type ABACPolicyUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: ABACPolicyWhereUniqueInput
    update: XOR<ABACPolicyUpdateWithoutInstitutionInput, ABACPolicyUncheckedUpdateWithoutInstitutionInput>
    create: XOR<ABACPolicyCreateWithoutInstitutionInput, ABACPolicyUncheckedCreateWithoutInstitutionInput>
  }

  export type ABACPolicyUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: ABACPolicyWhereUniqueInput
    data: XOR<ABACPolicyUpdateWithoutInstitutionInput, ABACPolicyUncheckedUpdateWithoutInstitutionInput>
  }

  export type ABACPolicyUpdateManyWithWhereWithoutInstitutionInput = {
    where: ABACPolicyScalarWhereInput
    data: XOR<ABACPolicyUpdateManyMutationInput, ABACPolicyUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type ABACPolicyScalarWhereInput = {
    AND?: ABACPolicyScalarWhereInput | ABACPolicyScalarWhereInput[]
    OR?: ABACPolicyScalarWhereInput[]
    NOT?: ABACPolicyScalarWhereInput | ABACPolicyScalarWhereInput[]
    id?: StringFilter<"ABACPolicy"> | string
    institutionId?: StringNullableFilter<"ABACPolicy"> | string | null
    name?: StringFilter<"ABACPolicy"> | string
    description?: StringNullableFilter<"ABACPolicy"> | string | null
    resource?: StringFilter<"ABACPolicy"> | string
    action?: StringFilter<"ABACPolicy"> | string
    condition?: JsonNullableFilter<"ABACPolicy">
    effect?: EnumPolicyEffectFilter<"ABACPolicy"> | $Enums.PolicyEffect
    isActive?: BoolFilter<"ABACPolicy"> | boolean
    createdAt?: DateTimeFilter<"ABACPolicy"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutInstitutionInput, StudentUncheckedUpdateWithoutInstitutionInput>
    create: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutInstitutionInput, StudentUncheckedUpdateWithoutInstitutionInput>
  }

  export type StudentUpdateManyWithWhereWithoutInstitutionInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    studentNumber?: StringNullableFilter<"Student"> | string | null
    institutionId?: StringFilter<"Student"> | string
    careerId?: StringNullableFilter<"Student"> | string | null
    enrollmentDate?: DateTimeFilter<"Student"> | Date | string
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    metadata?: JsonNullableFilter<"Student">
    createdAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type TutorProfileUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: TutorProfileWhereUniqueInput
    update: XOR<TutorProfileUpdateWithoutInstitutionInput, TutorProfileUncheckedUpdateWithoutInstitutionInput>
    create: XOR<TutorProfileCreateWithoutInstitutionInput, TutorProfileUncheckedCreateWithoutInstitutionInput>
  }

  export type TutorProfileUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: TutorProfileWhereUniqueInput
    data: XOR<TutorProfileUpdateWithoutInstitutionInput, TutorProfileUncheckedUpdateWithoutInstitutionInput>
  }

  export type TutorProfileUpdateManyWithWhereWithoutInstitutionInput = {
    where: TutorProfileScalarWhereInput
    data: XOR<TutorProfileUpdateManyMutationInput, TutorProfileUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type TutorProfileScalarWhereInput = {
    AND?: TutorProfileScalarWhereInput | TutorProfileScalarWhereInput[]
    OR?: TutorProfileScalarWhereInput[]
    NOT?: TutorProfileScalarWhereInput | TutorProfileScalarWhereInput[]
    id?: StringFilter<"TutorProfile"> | string
    userId?: StringFilter<"TutorProfile"> | string
    institutionId?: StringFilter<"TutorProfile"> | string
    relationship?: StringNullableFilter<"TutorProfile"> | string | null
    phone?: StringNullableFilter<"TutorProfile"> | string | null
    address?: StringNullableFilter<"TutorProfile"> | string | null
    metadata?: JsonNullableFilter<"TutorProfile">
    createdAt?: DateTimeFilter<"TutorProfile"> | Date | string
  }

  export type StudentPaymentUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: StudentPaymentWhereUniqueInput
    update: XOR<StudentPaymentUpdateWithoutInstitutionInput, StudentPaymentUncheckedUpdateWithoutInstitutionInput>
    create: XOR<StudentPaymentCreateWithoutInstitutionInput, StudentPaymentUncheckedCreateWithoutInstitutionInput>
  }

  export type StudentPaymentUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: StudentPaymentWhereUniqueInput
    data: XOR<StudentPaymentUpdateWithoutInstitutionInput, StudentPaymentUncheckedUpdateWithoutInstitutionInput>
  }

  export type StudentPaymentUpdateManyWithWhereWithoutInstitutionInput = {
    where: StudentPaymentScalarWhereInput
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type StudentPaymentScalarWhereInput = {
    AND?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
    OR?: StudentPaymentScalarWhereInput[]
    NOT?: StudentPaymentScalarWhereInput | StudentPaymentScalarWhereInput[]
    id?: StringFilter<"StudentPayment"> | string
    studentId?: StringFilter<"StudentPayment"> | string
    institutionId?: StringFilter<"StudentPayment"> | string
    feeInstallmentId?: StringNullableFilter<"StudentPayment"> | string | null
    amount?: DecimalFilter<"StudentPayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"StudentPayment"> | string
    method?: EnumPaymentMethodFilter<"StudentPayment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"StudentPayment"> | $Enums.PaymentStatus
    reference?: StringNullableFilter<"StudentPayment"> | string | null
    gatewayData?: JsonNullableFilter<"StudentPayment">
    paidAt?: DateTimeNullableFilter<"StudentPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentPayment"> | Date | string
  }

  export type AIAgentUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: AIAgentWhereUniqueInput
    update: XOR<AIAgentUpdateWithoutInstitutionInput, AIAgentUncheckedUpdateWithoutInstitutionInput>
    create: XOR<AIAgentCreateWithoutInstitutionInput, AIAgentUncheckedCreateWithoutInstitutionInput>
  }

  export type AIAgentUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: AIAgentWhereUniqueInput
    data: XOR<AIAgentUpdateWithoutInstitutionInput, AIAgentUncheckedUpdateWithoutInstitutionInput>
  }

  export type AIAgentUpdateManyWithWhereWithoutInstitutionInput = {
    where: AIAgentScalarWhereInput
    data: XOR<AIAgentUpdateManyMutationInput, AIAgentUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type AIAgentScalarWhereInput = {
    AND?: AIAgentScalarWhereInput | AIAgentScalarWhereInput[]
    OR?: AIAgentScalarWhereInput[]
    NOT?: AIAgentScalarWhereInput | AIAgentScalarWhereInput[]
    id?: StringFilter<"AIAgent"> | string
    institutionId?: StringFilter<"AIAgent"> | string
    type?: StringFilter<"AIAgent"> | string
    name?: StringFilter<"AIAgent"> | string
    personality?: StringFilter<"AIAgent"> | string
    specialization?: StringNullableFilter<"AIAgent"> | string | null
    maxTokensPerCall?: IntFilter<"AIAgent"> | number
    temperature?: FloatFilter<"AIAgent"> | number
    systemPrompt?: StringFilter<"AIAgent"> | string
    isActive?: BoolFilter<"AIAgent"> | boolean
    createdAt?: DateTimeFilter<"AIAgent"> | Date | string
  }

  export type WebhookUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutInstitutionInput, WebhookUncheckedUpdateWithoutInstitutionInput>
    create: XOR<WebhookCreateWithoutInstitutionInput, WebhookUncheckedCreateWithoutInstitutionInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutInstitutionInput, WebhookUncheckedUpdateWithoutInstitutionInput>
  }

  export type WebhookUpdateManyWithWhereWithoutInstitutionInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: StringFilter<"Webhook"> | string
    institutionId?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type InstitutionCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutSubscriptionsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutSubscriptionsInput, InstitutionUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PlanCreateWithoutInstitutionSubscriptionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    institutions?: InstitutionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutInstitutionSubscriptionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    currency?: string
    studentLimit?: number
    teacherLimit?: number
    adminLimit?: number
    courseLimit?: number
    aiTeacherCallsMonthly?: number
    aiStudentMinutesMonthly?: number
    certificateMonthly?: number
    virtualClassroomLimit?: number
    storageMB?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    institutions?: InstitutionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutInstitutionSubscriptionInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutInstitutionSubscriptionInput, PlanUncheckedCreateWithoutInstitutionSubscriptionInput>
  }

  export type InstitutionPaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutInstitutionPaymentsInput
  }

  export type InstitutionPaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    institutionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
  }

  export type InstitutionPaymentCreateOrConnectWithoutSubscriptionInput = {
    where: InstitutionPaymentWhereUniqueInput
    create: XOR<InstitutionPaymentCreateWithoutSubscriptionInput, InstitutionPaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type InstitutionPaymentCreateManySubscriptionInputEnvelope = {
    data: InstitutionPaymentCreateManySubscriptionInput | InstitutionPaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutSubscriptionsInput = {
    update: XOR<InstitutionUpdateWithoutSubscriptionsInput, InstitutionUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<InstitutionCreateWithoutSubscriptionsInput, InstitutionUncheckedCreateWithoutSubscriptionsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutSubscriptionsInput, InstitutionUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InstitutionUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type PlanUpsertWithoutInstitutionSubscriptionInput = {
    update: XOR<PlanUpdateWithoutInstitutionSubscriptionInput, PlanUncheckedUpdateWithoutInstitutionSubscriptionInput>
    create: XOR<PlanCreateWithoutInstitutionSubscriptionInput, PlanUncheckedCreateWithoutInstitutionSubscriptionInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutInstitutionSubscriptionInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutInstitutionSubscriptionInput, PlanUncheckedUpdateWithoutInstitutionSubscriptionInput>
  }

  export type PlanUpdateWithoutInstitutionSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutInstitutionSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    studentLimit?: IntFieldUpdateOperationsInput | number
    teacherLimit?: IntFieldUpdateOperationsInput | number
    adminLimit?: IntFieldUpdateOperationsInput | number
    courseLimit?: IntFieldUpdateOperationsInput | number
    aiTeacherCallsMonthly?: IntFieldUpdateOperationsInput | number
    aiStudentMinutesMonthly?: IntFieldUpdateOperationsInput | number
    certificateMonthly?: IntFieldUpdateOperationsInput | number
    virtualClassroomLimit?: IntFieldUpdateOperationsInput | number
    storageMB?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type InstitutionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InstitutionPaymentWhereUniqueInput
    update: XOR<InstitutionPaymentUpdateWithoutSubscriptionInput, InstitutionPaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InstitutionPaymentCreateWithoutSubscriptionInput, InstitutionPaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type InstitutionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InstitutionPaymentWhereUniqueInput
    data: XOR<InstitutionPaymentUpdateWithoutSubscriptionInput, InstitutionPaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InstitutionPaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InstitutionPaymentScalarWhereInput
    data: XOR<InstitutionPaymentUpdateManyMutationInput, InstitutionPaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type InstitutionCreateWithoutInstitutionPaymentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutInstitutionPaymentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutInstitutionPaymentsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutInstitutionPaymentsInput, InstitutionUncheckedCreateWithoutInstitutionPaymentsInput>
  }

  export type InstitutionSubscriptionCreateWithoutPaymentsInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutInstitutionSubscriptionInput
  }

  export type InstitutionSubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    institutionId: string
    planId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
  }

  export type InstitutionSubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: InstitutionSubscriptionWhereUniqueInput
    create: XOR<InstitutionSubscriptionCreateWithoutPaymentsInput, InstitutionSubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type InstitutionUpsertWithoutInstitutionPaymentsInput = {
    update: XOR<InstitutionUpdateWithoutInstitutionPaymentsInput, InstitutionUncheckedUpdateWithoutInstitutionPaymentsInput>
    create: XOR<InstitutionCreateWithoutInstitutionPaymentsInput, InstitutionUncheckedCreateWithoutInstitutionPaymentsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutInstitutionPaymentsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutInstitutionPaymentsInput, InstitutionUncheckedUpdateWithoutInstitutionPaymentsInput>
  }

  export type InstitutionUpdateWithoutInstitutionPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutInstitutionPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionSubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<InstitutionSubscriptionUpdateWithoutPaymentsInput, InstitutionSubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InstitutionSubscriptionCreateWithoutPaymentsInput, InstitutionSubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: InstitutionSubscriptionWhereInput
  }

  export type InstitutionSubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InstitutionSubscriptionWhereInput
    data: XOR<InstitutionSubscriptionUpdateWithoutPaymentsInput, InstitutionSubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstitutionSubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutInstitutionSubscriptionNestedInput
  }

  export type InstitutionSubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutUsersInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    specialties?: TeacherCreatespecialtiesInput | string[]
    hireDate?: Date | string | null
    createdAt?: Date | string
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    specialties?: TeacherCreatespecialtiesInput | string[]
    hireDate?: Date | string | null
    createdAt?: Date | string
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TutorProfileCreateWithoutUserInput = {
    id?: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutTutorProfileInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutTutorInput
  }

  export type TutorProfileUncheckedCreateWithoutUserInput = {
    id?: string
    institutionId: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorProfileCreateOrConnectWithoutUserInput = {
    where: TutorProfileWhereUniqueInput
    create: XOR<TutorProfileCreateWithoutUserInput, TutorProfileUncheckedCreateWithoutUserInput>
  }

  export type DashboardConfigCreateWithoutUserInput = {
    id?: string
    type: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DashboardConfigUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DashboardConfigCreateOrConnectWithoutUserInput = {
    where: DashboardConfigWhereUniqueInput
    create: XOR<DashboardConfigCreateWithoutUserInput, DashboardConfigUncheckedCreateWithoutUserInput>
  }

  export type DashboardConfigCreateManyUserInputEnvelope = {
    data: DashboardConfigCreateManyUserInput | DashboardConfigCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIUsageLogCreateWithoutUserInput = {
    id?: string
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutAiUsageLogsInput
    classroom?: VirtualClassroomCreateNestedOneWithoutAiUsagesInput
  }

  export type AIUsageLogUncheckedCreateWithoutUserInput = {
    id?: string
    institutionId: string
    classroomId?: string | null
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AIUsageLogCreateOrConnectWithoutUserInput = {
    where: AIUsageLogWhereUniqueInput
    create: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput>
  }

  export type AIUsageLogCreateManyUserInputEnvelope = {
    data: AIUsageLogCreateManyUserInput | AIUsageLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionLogCreateWithoutUserInput = {
    id?: string
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutInstitutionLogsInput
  }

  export type InstitutionLogUncheckedCreateWithoutUserInput = {
    id?: string
    institutionId: string
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InstitutionLogCreateOrConnectWithoutUserInput = {
    where: InstitutionLogWhereUniqueInput
    create: XOR<InstitutionLogCreateWithoutUserInput, InstitutionLogUncheckedCreateWithoutUserInput>
  }

  export type InstitutionLogCreateManyUserInputEnvelope = {
    data: InstitutionLogCreateManyUserInput | InstitutionLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientId: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutRecipientInput = {
    id?: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutRecipientInput = {
    id?: string
    senderId: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageCreateManyRecipientInputEnvelope = {
    data: MessageCreateManyRecipientInput | MessageCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    title: string
    body: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    title: string
    body: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type CareerCreateWithoutCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutCareersInput
    courses?: CourseCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodCreateNestedManyWithoutCareerInput
    students?: StudentCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutCreatedByInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput
    students?: StudentUncheckedCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutCreatedByInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutCreatedByInput, CareerUncheckedCreateWithoutCreatedByInput>
  }

  export type CareerCreateManyCreatedByInputEnvelope = {
    data: CareerCreateManyCreatedByInput | CareerCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCreatedByInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutCoursesInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCoursesInput
    subjects?: SubjectCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    certificate?: CertificateCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatedByInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatedByInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput>
  }

  export type CourseCreateManyCreatedByInputEnvelope = {
    data: CourseCreateManyCreatedByInput | CourseCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LessonPlanCreateWithoutCreatedByInput = {
    id?: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    classroom: VirtualClassroomCreateNestedOneWithoutLessonPlansInput
  }

  export type LessonPlanUncheckedCreateWithoutCreatedByInput = {
    id?: string
    classroomId: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LessonPlanCreateOrConnectWithoutCreatedByInput = {
    where: LessonPlanWhereUniqueInput
    create: XOR<LessonPlanCreateWithoutCreatedByInput, LessonPlanUncheckedCreateWithoutCreatedByInput>
  }

  export type LessonPlanCreateManyCreatedByInputEnvelope = {
    data: LessonPlanCreateManyCreatedByInput | LessonPlanCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type VirtualClassroomCreateWithoutTeacherInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutTeacherInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutTeacherInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutTeacherInput, VirtualClassroomUncheckedCreateWithoutTeacherInput>
  }

  export type VirtualClassroomCreateManyTeacherInputEnvelope = {
    data: VirtualClassroomCreateManyTeacherInput | VirtualClassroomCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdAt?: Date | string
    studentSubject: StudentSubjectCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutCreatedByInput = {
    id?: string
    studentSubjectId: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutCreatedByInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutCreatedByInput, GradeUncheckedCreateWithoutCreatedByInput>
  }

  export type GradeCreateManyCreatedByInputEnvelope = {
    data: GradeCreateManyCreatedByInput | GradeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutNotedByInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
    classroom: VirtualClassroomCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutNotedByInput = {
    id?: string
    studentId: string
    classroomId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutNotedByInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutNotedByInput, AttendanceUncheckedCreateWithoutNotedByInput>
  }

  export type AttendanceCreateManyNotedByInputEnvelope = {
    data: AttendanceCreateManyNotedByInput | AttendanceCreateManyNotedByInput[]
    skipDuplicates?: boolean
  }

  export type DisciplinaryRecordCreateWithoutRecordedByInput = {
    id?: string
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
    student: StudentCreateNestedOneWithoutDisciplinaryRecordInput
    subject?: SubjectCreateNestedOneWithoutDisciplinaryRecordInput
  }

  export type DisciplinaryRecordUncheckedCreateWithoutRecordedByInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type DisciplinaryRecordCreateOrConnectWithoutRecordedByInput = {
    where: DisciplinaryRecordWhereUniqueInput
    create: XOR<DisciplinaryRecordCreateWithoutRecordedByInput, DisciplinaryRecordUncheckedCreateWithoutRecordedByInput>
  }

  export type DisciplinaryRecordCreateManyRecordedByInputEnvelope = {
    data: DisciplinaryRecordCreateManyRecordedByInput | DisciplinaryRecordCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutIssuedByInput = {
    id?: string
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student: StudentCreateNestedOneWithoutCertificatesInput
    course?: CourseCreateNestedOneWithoutCertificateInput
    subject?: SubjectCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutIssuedByInput = {
    id?: string
    studentId: string
    courseId?: string | null
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateCreateOrConnectWithoutIssuedByInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutIssuedByInput, CertificateUncheckedCreateWithoutIssuedByInput>
  }

  export type CertificateCreateManyIssuedByInputEnvelope = {
    data: CertificateCreateManyIssuedByInput | CertificateCreateManyIssuedByInput[]
    skipDuplicates?: boolean
  }

  export type AIConversationCreateWithoutUserInput = {
    id?: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    agent: AIAgentCreateNestedOneWithoutConversationsInput
    messages?: AIMessageCreateNestedManyWithoutConversationInput
  }

  export type AIConversationUncheckedCreateWithoutUserInput = {
    id?: string
    agentId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    messages?: AIMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AIConversationCreateOrConnectWithoutUserInput = {
    where: AIConversationWhereUniqueInput
    create: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput>
  }

  export type AIConversationCreateManyUserInputEnvelope = {
    data: AIConversationCreateManyUserInput | AIConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceCreateManyUserInputEnvelope = {
    data: NotificationPreferenceCreateManyUserInput | NotificationPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutCreatedByInput = {
    id?: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateWithoutCreatedByInput = {
    id?: string
    institutionId: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput>
  }

  export type AnnouncementCreateManyCreatedByInputEnvelope = {
    data: AnnouncementCreateManyCreatedByInput | AnnouncementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DataBackupCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutBackupsInput
  }

  export type DataBackupUncheckedCreateWithoutCreatedByInput = {
    id?: string
    institutionId: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdAt?: Date | string
  }

  export type DataBackupCreateOrConnectWithoutCreatedByInput = {
    where: DataBackupWhereUniqueInput
    create: XOR<DataBackupCreateWithoutCreatedByInput, DataBackupUncheckedCreateWithoutCreatedByInput>
  }

  export type DataBackupCreateManyCreatedByInputEnvelope = {
    data: DataBackupCreateManyCreatedByInput | DataBackupCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    institutionId: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TemplateCreateOrConnectWithoutCreatedByInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutCreatedByInput, TemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type TemplateCreateManyCreatedByInputEnvelope = {
    data: TemplateCreateManyCreatedByInput | TemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutUsersInput = {
    update: XOR<InstitutionUpdateWithoutUsersInput, InstitutionUncheckedUpdateWithoutUsersInput>
    create: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutUsersInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutUsersInput, InstitutionUncheckedUpdateWithoutUsersInput>
  }

  export type InstitutionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: TeacherUpdatespecialtiesInput | string[]
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: TeacherUpdatespecialtiesInput | string[]
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorProfileUpsertWithoutUserInput = {
    update: XOR<TutorProfileUpdateWithoutUserInput, TutorProfileUncheckedUpdateWithoutUserInput>
    create: XOR<TutorProfileCreateWithoutUserInput, TutorProfileUncheckedCreateWithoutUserInput>
    where?: TutorProfileWhereInput
  }

  export type TutorProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: TutorProfileWhereInput
    data: XOR<TutorProfileUpdateWithoutUserInput, TutorProfileUncheckedUpdateWithoutUserInput>
  }

  export type TutorProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutTutorProfileNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutTutorNestedInput
  }

  export type TutorProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type DashboardConfigUpsertWithWhereUniqueWithoutUserInput = {
    where: DashboardConfigWhereUniqueInput
    update: XOR<DashboardConfigUpdateWithoutUserInput, DashboardConfigUncheckedUpdateWithoutUserInput>
    create: XOR<DashboardConfigCreateWithoutUserInput, DashboardConfigUncheckedCreateWithoutUserInput>
  }

  export type DashboardConfigUpdateWithWhereUniqueWithoutUserInput = {
    where: DashboardConfigWhereUniqueInput
    data: XOR<DashboardConfigUpdateWithoutUserInput, DashboardConfigUncheckedUpdateWithoutUserInput>
  }

  export type DashboardConfigUpdateManyWithWhereWithoutUserInput = {
    where: DashboardConfigScalarWhereInput
    data: XOR<DashboardConfigUpdateManyMutationInput, DashboardConfigUncheckedUpdateManyWithoutUserInput>
  }

  export type DashboardConfigScalarWhereInput = {
    AND?: DashboardConfigScalarWhereInput | DashboardConfigScalarWhereInput[]
    OR?: DashboardConfigScalarWhereInput[]
    NOT?: DashboardConfigScalarWhereInput | DashboardConfigScalarWhereInput[]
    id?: StringFilter<"DashboardConfig"> | string
    userId?: StringFilter<"DashboardConfig"> | string
    type?: StringFilter<"DashboardConfig"> | string
    config?: JsonFilter<"DashboardConfig">
    updatedAt?: DateTimeFilter<"DashboardConfig"> | Date | string
  }

  export type AIUsageLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AIUsageLogWhereUniqueInput
    update: XOR<AIUsageLogUpdateWithoutUserInput, AIUsageLogUncheckedUpdateWithoutUserInput>
    create: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput>
  }

  export type AIUsageLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AIUsageLogWhereUniqueInput
    data: XOR<AIUsageLogUpdateWithoutUserInput, AIUsageLogUncheckedUpdateWithoutUserInput>
  }

  export type AIUsageLogUpdateManyWithWhereWithoutUserInput = {
    where: AIUsageLogScalarWhereInput
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    isPrimary?: BoolFilter<"UserRole"> | boolean
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type InstitutionLogUpsertWithWhereUniqueWithoutUserInput = {
    where: InstitutionLogWhereUniqueInput
    update: XOR<InstitutionLogUpdateWithoutUserInput, InstitutionLogUncheckedUpdateWithoutUserInput>
    create: XOR<InstitutionLogCreateWithoutUserInput, InstitutionLogUncheckedCreateWithoutUserInput>
  }

  export type InstitutionLogUpdateWithWhereUniqueWithoutUserInput = {
    where: InstitutionLogWhereUniqueInput
    data: XOR<InstitutionLogUpdateWithoutUserInput, InstitutionLogUncheckedUpdateWithoutUserInput>
  }

  export type InstitutionLogUpdateManyWithWhereWithoutUserInput = {
    where: InstitutionLogScalarWhereInput
    data: XOR<InstitutionLogUpdateManyMutationInput, InstitutionLogUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    subject?: StringNullableFilter<"Message"> | string | null
    body?: StringFilter<"Message"> | string
    attachments?: JsonNullableFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    meta?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pushSent?: BoolFilter<"Notification"> | boolean
    emailSent?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CareerUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CareerWhereUniqueInput
    update: XOR<CareerUpdateWithoutCreatedByInput, CareerUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CareerCreateWithoutCreatedByInput, CareerUncheckedCreateWithoutCreatedByInput>
  }

  export type CareerUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CareerWhereUniqueInput
    data: XOR<CareerUpdateWithoutCreatedByInput, CareerUncheckedUpdateWithoutCreatedByInput>
  }

  export type CareerUpdateManyWithWhereWithoutCreatedByInput = {
    where: CareerScalarWhereInput
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatedByInput, CourseUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CourseCreateWithoutCreatedByInput, CourseUncheckedCreateWithoutCreatedByInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatedByInput, CourseUncheckedUpdateWithoutCreatedByInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatedByInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    careerId?: StringFilter<"Course"> | string
    academicPeriodId?: StringNullableFilter<"Course"> | string | null
    name?: StringFilter<"Course"> | string
    code?: StringNullableFilter<"Course"> | string | null
    description?: StringNullableFilter<"Course"> | string | null
    credits?: IntNullableFilter<"Course"> | number | null
    durationSemesters?: IntNullableFilter<"Course"> | number | null
    createdById?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type LessonPlanUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LessonPlanWhereUniqueInput
    update: XOR<LessonPlanUpdateWithoutCreatedByInput, LessonPlanUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LessonPlanCreateWithoutCreatedByInput, LessonPlanUncheckedCreateWithoutCreatedByInput>
  }

  export type LessonPlanUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LessonPlanWhereUniqueInput
    data: XOR<LessonPlanUpdateWithoutCreatedByInput, LessonPlanUncheckedUpdateWithoutCreatedByInput>
  }

  export type LessonPlanUpdateManyWithWhereWithoutCreatedByInput = {
    where: LessonPlanScalarWhereInput
    data: XOR<LessonPlanUpdateManyMutationInput, LessonPlanUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LessonPlanScalarWhereInput = {
    AND?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
    OR?: LessonPlanScalarWhereInput[]
    NOT?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
    id?: StringFilter<"LessonPlan"> | string
    classroomId?: StringFilter<"LessonPlan"> | string
    date?: DateTimeFilter<"LessonPlan"> | Date | string
    topic?: StringFilter<"LessonPlan"> | string
    aiSuggestions?: JsonNullableFilter<"LessonPlan">
    createdById?: StringNullableFilter<"LessonPlan"> | string | null
    createdAt?: DateTimeFilter<"LessonPlan"> | Date | string
  }

  export type VirtualClassroomUpsertWithWhereUniqueWithoutTeacherInput = {
    where: VirtualClassroomWhereUniqueInput
    update: XOR<VirtualClassroomUpdateWithoutTeacherInput, VirtualClassroomUncheckedUpdateWithoutTeacherInput>
    create: XOR<VirtualClassroomCreateWithoutTeacherInput, VirtualClassroomUncheckedCreateWithoutTeacherInput>
  }

  export type VirtualClassroomUpdateWithWhereUniqueWithoutTeacherInput = {
    where: VirtualClassroomWhereUniqueInput
    data: XOR<VirtualClassroomUpdateWithoutTeacherInput, VirtualClassroomUncheckedUpdateWithoutTeacherInput>
  }

  export type VirtualClassroomUpdateManyWithWhereWithoutTeacherInput = {
    where: VirtualClassroomScalarWhereInput
    data: XOR<VirtualClassroomUpdateManyMutationInput, VirtualClassroomUncheckedUpdateManyWithoutTeacherInput>
  }

  export type VirtualClassroomScalarWhereInput = {
    AND?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
    OR?: VirtualClassroomScalarWhereInput[]
    NOT?: VirtualClassroomScalarWhereInput | VirtualClassroomScalarWhereInput[]
    id?: StringFilter<"VirtualClassroom"> | string
    subjectId?: StringFilter<"VirtualClassroom"> | string
    code?: StringNullableFilter<"VirtualClassroom"> | string | null
    title?: StringNullableFilter<"VirtualClassroom"> | string | null
    teacherId?: StringNullableFilter<"VirtualClassroom"> | string | null
    aiEnabled?: BoolFilter<"VirtualClassroom"> | boolean
    aiConfig?: JsonNullableFilter<"VirtualClassroom">
    createdAt?: DateTimeFilter<"VirtualClassroom"> | Date | string
    aiagentId?: StringNullableFilter<"VirtualClassroom"> | string | null
  }

  export type GradeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutCreatedByInput, GradeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<GradeCreateWithoutCreatedByInput, GradeUncheckedCreateWithoutCreatedByInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutCreatedByInput, GradeUncheckedUpdateWithoutCreatedByInput>
  }

  export type GradeUpdateManyWithWhereWithoutCreatedByInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    studentSubjectId?: StringFilter<"Grade"> | string
    type?: EnumGradeTypeFilter<"Grade"> | $Enums.GradeType
    weight?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFilter<"Grade"> | Decimal | DecimalJsLike | number | string
    comments?: StringNullableFilter<"Grade"> | string | null
    createdById?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutNotedByInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutNotedByInput, AttendanceUncheckedUpdateWithoutNotedByInput>
    create: XOR<AttendanceCreateWithoutNotedByInput, AttendanceUncheckedCreateWithoutNotedByInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutNotedByInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutNotedByInput, AttendanceUncheckedUpdateWithoutNotedByInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutNotedByInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutNotedByInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    classroomId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    notedById?: StringNullableFilter<"Attendance"> | string | null
    note?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type DisciplinaryRecordUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: DisciplinaryRecordWhereUniqueInput
    update: XOR<DisciplinaryRecordUpdateWithoutRecordedByInput, DisciplinaryRecordUncheckedUpdateWithoutRecordedByInput>
    create: XOR<DisciplinaryRecordCreateWithoutRecordedByInput, DisciplinaryRecordUncheckedCreateWithoutRecordedByInput>
  }

  export type DisciplinaryRecordUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: DisciplinaryRecordWhereUniqueInput
    data: XOR<DisciplinaryRecordUpdateWithoutRecordedByInput, DisciplinaryRecordUncheckedUpdateWithoutRecordedByInput>
  }

  export type DisciplinaryRecordUpdateManyWithWhereWithoutRecordedByInput = {
    where: DisciplinaryRecordScalarWhereInput
    data: XOR<DisciplinaryRecordUpdateManyMutationInput, DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type DisciplinaryRecordScalarWhereInput = {
    AND?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
    OR?: DisciplinaryRecordScalarWhereInput[]
    NOT?: DisciplinaryRecordScalarWhereInput | DisciplinaryRecordScalarWhereInput[]
    id?: StringFilter<"DisciplinaryRecord"> | string
    studentId?: StringFilter<"DisciplinaryRecord"> | string
    subjectId?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    recordedById?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    type?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    description?: StringFilter<"DisciplinaryRecord"> | string
    actionTaken?: StringNullableFilter<"DisciplinaryRecord"> | string | null
    date?: DateTimeFilter<"DisciplinaryRecord"> | Date | string
    seenByTutor?: BoolFilter<"DisciplinaryRecord"> | boolean
  }

  export type CertificateUpsertWithWhereUniqueWithoutIssuedByInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutIssuedByInput, CertificateUncheckedUpdateWithoutIssuedByInput>
    create: XOR<CertificateCreateWithoutIssuedByInput, CertificateUncheckedCreateWithoutIssuedByInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutIssuedByInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutIssuedByInput, CertificateUncheckedUpdateWithoutIssuedByInput>
  }

  export type CertificateUpdateManyWithWhereWithoutIssuedByInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutIssuedByInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    studentId?: StringFilter<"Certificate"> | string
    courseId?: StringNullableFilter<"Certificate"> | string | null
    subjectId?: StringNullableFilter<"Certificate"> | string | null
    type?: EnumCertificateTypeFilter<"Certificate"> | $Enums.CertificateType
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    fileUrl?: StringNullableFilter<"Certificate"> | string | null
    issuedById?: StringNullableFilter<"Certificate"> | string | null
    metadata?: JsonNullableFilter<"Certificate">
  }

  export type AIConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: AIConversationWhereUniqueInput
    update: XOR<AIConversationUpdateWithoutUserInput, AIConversationUncheckedUpdateWithoutUserInput>
    create: XOR<AIConversationCreateWithoutUserInput, AIConversationUncheckedCreateWithoutUserInput>
  }

  export type AIConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: AIConversationWhereUniqueInput
    data: XOR<AIConversationUpdateWithoutUserInput, AIConversationUncheckedUpdateWithoutUserInput>
  }

  export type AIConversationUpdateManyWithWhereWithoutUserInput = {
    where: AIConversationScalarWhereInput
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type AIConversationScalarWhereInput = {
    AND?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
    OR?: AIConversationScalarWhereInput[]
    NOT?: AIConversationScalarWhereInput | AIConversationScalarWhereInput[]
    id?: StringFilter<"AIConversation"> | string
    userId?: StringFilter<"AIConversation"> | string
    agentId?: StringFilter<"AIConversation"> | string
    sessionId?: StringFilter<"AIConversation"> | string
    startedAt?: DateTimeFilter<"AIConversation"> | Date | string
    endedAt?: DateTimeNullableFilter<"AIConversation"> | Date | string | null
    totalTokens?: IntFilter<"AIConversation"> | number
    totalCost?: DecimalNullableFilter<"AIConversation"> | Decimal | DecimalJsLike | number | string | null
  }

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: NotificationPreferenceScalarWhereInput
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationPreferenceScalarWhereInput = {
    AND?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    OR?: NotificationPreferenceScalarWhereInput[]
    NOT?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    preferences?: JsonNullableFilter<"NotificationPreference">
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutCreatedByInput, AnnouncementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutCreatedByInput, AnnouncementUncheckedUpdateWithoutCreatedByInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutCreatedByInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DataBackupUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DataBackupWhereUniqueInput
    update: XOR<DataBackupUpdateWithoutCreatedByInput, DataBackupUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DataBackupCreateWithoutCreatedByInput, DataBackupUncheckedCreateWithoutCreatedByInput>
  }

  export type DataBackupUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DataBackupWhereUniqueInput
    data: XOR<DataBackupUpdateWithoutCreatedByInput, DataBackupUncheckedUpdateWithoutCreatedByInput>
  }

  export type DataBackupUpdateManyWithWhereWithoutCreatedByInput = {
    where: DataBackupScalarWhereInput
    data: XOR<DataBackupUpdateManyMutationInput, DataBackupUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutCreatedByInput, TemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TemplateCreateWithoutCreatedByInput, TemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutCreatedByInput, TemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type TemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InstitutionCreateWithoutRolesInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutRolesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutRolesInput, InstitutionUncheckedCreateWithoutRolesInput>
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutRolesInput = {
    update: XOR<InstitutionUpdateWithoutRolesInput, InstitutionUncheckedUpdateWithoutRolesInput>
    create: XOR<InstitutionCreateWithoutRolesInput, InstitutionUncheckedCreateWithoutRolesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutRolesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutRolesInput, InstitutionUncheckedUpdateWithoutRolesInput>
  }

  export type InstitutionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    institutionId?: string | null
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateWithoutABACPolicyInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutABACPolicyInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutABACPolicyInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutABACPolicyInput, InstitutionUncheckedCreateWithoutABACPolicyInput>
  }

  export type InstitutionUpsertWithoutABACPolicyInput = {
    update: XOR<InstitutionUpdateWithoutABACPolicyInput, InstitutionUncheckedUpdateWithoutABACPolicyInput>
    create: XOR<InstitutionCreateWithoutABACPolicyInput, InstitutionUncheckedCreateWithoutABACPolicyInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutABACPolicyInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutABACPolicyInput, InstitutionUncheckedUpdateWithoutABACPolicyInput>
  }

  export type InstitutionUpdateWithoutABACPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutABACPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateWithoutCareersInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutCareersInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutCareersInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutCareersInput, InstitutionUncheckedCreateWithoutCareersInput>
  }

  export type UserCreateWithoutCareersInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCareersInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCareersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCareersInput, UserUncheckedCreateWithoutCareersInput>
  }

  export type CourseCreateWithoutCareerInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCoursesInput
    createdBy?: UserCreateNestedOneWithoutCoursesInput
    subjects?: SubjectCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    certificate?: CertificateCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCareerInput = {
    id?: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCareerInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCareerInput, CourseUncheckedCreateWithoutCareerInput>
  }

  export type CourseCreateManyCareerInputEnvelope = {
    data: CourseCreateManyCareerInput | CourseCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type AcademicPeriodCreateWithoutCareerInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutAcademicPeriodInput
    enrollments?: EnrollmentCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutCareerInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicPeriodInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutCareerInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutCareerInput, AcademicPeriodUncheckedCreateWithoutCareerInput>
  }

  export type AcademicPeriodCreateManyCareerInputEnvelope = {
    data: AcademicPeriodCreateManyCareerInput | AcademicPeriodCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutCareerInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCareerInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCareerInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCareerInput, StudentUncheckedCreateWithoutCareerInput>
  }

  export type StudentCreateManyCareerInputEnvelope = {
    data: StudentCreateManyCareerInput | StudentCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type FeeScheduleCreateWithoutCareerInput = {
    id?: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutFeeSchedulesInput
    installmentsList?: FeeInstallmentCreateNestedManyWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleUncheckedCreateWithoutCareerInput = {
    id?: string
    institutionId: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    installmentsList?: FeeInstallmentUncheckedCreateNestedManyWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleCreateOrConnectWithoutCareerInput = {
    where: FeeScheduleWhereUniqueInput
    create: XOR<FeeScheduleCreateWithoutCareerInput, FeeScheduleUncheckedCreateWithoutCareerInput>
  }

  export type FeeScheduleCreateManyCareerInputEnvelope = {
    data: FeeScheduleCreateManyCareerInput | FeeScheduleCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutCareersInput = {
    update: XOR<InstitutionUpdateWithoutCareersInput, InstitutionUncheckedUpdateWithoutCareersInput>
    create: XOR<InstitutionCreateWithoutCareersInput, InstitutionUncheckedCreateWithoutCareersInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutCareersInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutCareersInput, InstitutionUncheckedUpdateWithoutCareersInput>
  }

  export type InstitutionUpdateWithoutCareersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutCareersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserUpsertWithoutCareersInput = {
    update: XOR<UserUpdateWithoutCareersInput, UserUncheckedUpdateWithoutCareersInput>
    create: XOR<UserCreateWithoutCareersInput, UserUncheckedCreateWithoutCareersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCareersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCareersInput, UserUncheckedUpdateWithoutCareersInput>
  }

  export type UserUpdateWithoutCareersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCareersInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutCareerInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCareerInput, CourseUncheckedUpdateWithoutCareerInput>
    create: XOR<CourseCreateWithoutCareerInput, CourseUncheckedCreateWithoutCareerInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCareerInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCareerInput, CourseUncheckedUpdateWithoutCareerInput>
  }

  export type CourseUpdateManyWithWhereWithoutCareerInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCareerInput>
  }

  export type AcademicPeriodUpsertWithWhereUniqueWithoutCareerInput = {
    where: AcademicPeriodWhereUniqueInput
    update: XOR<AcademicPeriodUpdateWithoutCareerInput, AcademicPeriodUncheckedUpdateWithoutCareerInput>
    create: XOR<AcademicPeriodCreateWithoutCareerInput, AcademicPeriodUncheckedCreateWithoutCareerInput>
  }

  export type AcademicPeriodUpdateWithWhereUniqueWithoutCareerInput = {
    where: AcademicPeriodWhereUniqueInput
    data: XOR<AcademicPeriodUpdateWithoutCareerInput, AcademicPeriodUncheckedUpdateWithoutCareerInput>
  }

  export type AcademicPeriodUpdateManyWithWhereWithoutCareerInput = {
    where: AcademicPeriodScalarWhereInput
    data: XOR<AcademicPeriodUpdateManyMutationInput, AcademicPeriodUncheckedUpdateManyWithoutCareerInput>
  }

  export type AcademicPeriodScalarWhereInput = {
    AND?: AcademicPeriodScalarWhereInput | AcademicPeriodScalarWhereInput[]
    OR?: AcademicPeriodScalarWhereInput[]
    NOT?: AcademicPeriodScalarWhereInput | AcademicPeriodScalarWhereInput[]
    id?: StringFilter<"AcademicPeriod"> | string
    careerId?: StringFilter<"AcademicPeriod"> | string
    name?: StringFilter<"AcademicPeriod"> | string
    startDate?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endDate?: DateTimeFilter<"AcademicPeriod"> | Date | string
    isActive?: BoolFilter<"AcademicPeriod"> | boolean
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutCareerInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutCareerInput, StudentUncheckedUpdateWithoutCareerInput>
    create: XOR<StudentCreateWithoutCareerInput, StudentUncheckedCreateWithoutCareerInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutCareerInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutCareerInput, StudentUncheckedUpdateWithoutCareerInput>
  }

  export type StudentUpdateManyWithWhereWithoutCareerInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutCareerInput>
  }

  export type FeeScheduleUpsertWithWhereUniqueWithoutCareerInput = {
    where: FeeScheduleWhereUniqueInput
    update: XOR<FeeScheduleUpdateWithoutCareerInput, FeeScheduleUncheckedUpdateWithoutCareerInput>
    create: XOR<FeeScheduleCreateWithoutCareerInput, FeeScheduleUncheckedCreateWithoutCareerInput>
  }

  export type FeeScheduleUpdateWithWhereUniqueWithoutCareerInput = {
    where: FeeScheduleWhereUniqueInput
    data: XOR<FeeScheduleUpdateWithoutCareerInput, FeeScheduleUncheckedUpdateWithoutCareerInput>
  }

  export type FeeScheduleUpdateManyWithWhereWithoutCareerInput = {
    where: FeeScheduleScalarWhereInput
    data: XOR<FeeScheduleUpdateManyMutationInput, FeeScheduleUncheckedUpdateManyWithoutCareerInput>
  }

  export type CareerCreateWithoutPeriodsInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutCareersInput
    createdBy?: UserCreateNestedOneWithoutCareersInput
    courses?: CourseCreateNestedManyWithoutCareerInput
    students?: StudentCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutPeriodsInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCareerInput
    students?: StudentUncheckedCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutPeriodsInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutPeriodsInput, CareerUncheckedCreateWithoutPeriodsInput>
  }

  export type CourseCreateWithoutAcademicPeriodInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutCoursesInput
    createdBy?: UserCreateNestedOneWithoutCoursesInput
    subjects?: SubjectCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    certificate?: CertificateCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    careerId: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAcademicPeriodInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAcademicPeriodInput, CourseUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type CourseCreateManyAcademicPeriodInputEnvelope = {
    data: CourseCreateManyAcademicPeriodInput | CourseCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutAcademicPeriodInput = {
    id?: string
    enrolledAt?: Date | string
    status?: string | null
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    courseId: string
    enrolledAt?: Date | string
    status?: string | null
  }

  export type EnrollmentCreateOrConnectWithoutAcademicPeriodInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutAcademicPeriodInput, EnrollmentUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type EnrollmentCreateManyAcademicPeriodInputEnvelope = {
    data: EnrollmentCreateManyAcademicPeriodInput | EnrollmentCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type CareerUpsertWithoutPeriodsInput = {
    update: XOR<CareerUpdateWithoutPeriodsInput, CareerUncheckedUpdateWithoutPeriodsInput>
    create: XOR<CareerCreateWithoutPeriodsInput, CareerUncheckedCreateWithoutPeriodsInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutPeriodsInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutPeriodsInput, CareerUncheckedUpdateWithoutPeriodsInput>
  }

  export type CareerUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutCareersNestedInput
    createdBy?: UserUpdateOneWithoutCareersNestedInput
    courses?: CourseUpdateManyWithoutCareerNestedInput
    students?: StudentUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCareerNestedInput
    students?: StudentUncheckedUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutAcademicPeriodInput, CourseUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<CourseCreateWithoutAcademicPeriodInput, CourseUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutAcademicPeriodInput, CourseUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type CourseUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutAcademicPeriodInput, EnrollmentUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<EnrollmentCreateWithoutAcademicPeriodInput, EnrollmentUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutAcademicPeriodInput, EnrollmentUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    academicPeriodId?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    status?: StringNullableFilter<"Enrollment"> | string | null
  }

  export type CareerCreateWithoutCoursesInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutCareersInput
    createdBy?: UserCreateNestedOneWithoutCareersInput
    periods?: AcademicPeriodCreateNestedManyWithoutCareerInput
    students?: StudentCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutCoursesInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    periods?: AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput
    students?: StudentUncheckedCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutCoursesInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutCoursesInput, CareerUncheckedCreateWithoutCoursesInput>
  }

  export type AcademicPeriodCreateWithoutCoursesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutPeriodsInput
    enrollments?: EnrollmentCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutCoursesInput = {
    id?: string
    careerId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutCoursesInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutCoursesInput, AcademicPeriodUncheckedCreateWithoutCoursesInput>
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type SubjectCreateWithoutCourseInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    classrooms?: VirtualClassroomCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutSubjectInput
    certificate?: CertificateCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutCourseInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutSubjectInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutCourseInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput>
  }

  export type SubjectCreateManyCourseInputEnvelope = {
    data: SubjectCreateManyCourseInput | SubjectCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    id?: string
    enrolledAt?: Date | string
    status?: string | null
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    studentId: string
    academicPeriodId?: string | null
    enrolledAt?: Date | string
    status?: string | null
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutCourseInput = {
    id?: string
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student: StudentCreateNestedOneWithoutCertificatesInput
    subject?: SubjectCreateNestedOneWithoutCertificateInput
    issuedBy?: UserCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutCourseInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateCreateOrConnectWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateCreateManyCourseInputEnvelope = {
    data: CertificateCreateManyCourseInput | CertificateCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CareerUpsertWithoutCoursesInput = {
    update: XOR<CareerUpdateWithoutCoursesInput, CareerUncheckedUpdateWithoutCoursesInput>
    create: XOR<CareerCreateWithoutCoursesInput, CareerUncheckedCreateWithoutCoursesInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutCoursesInput, CareerUncheckedUpdateWithoutCoursesInput>
  }

  export type CareerUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutCareersNestedInput
    createdBy?: UserUpdateOneWithoutCareersNestedInput
    periods?: AcademicPeriodUpdateManyWithoutCareerNestedInput
    students?: StudentUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput
    students?: StudentUncheckedUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type AcademicPeriodUpsertWithoutCoursesInput = {
    update: XOR<AcademicPeriodUpdateWithoutCoursesInput, AcademicPeriodUncheckedUpdateWithoutCoursesInput>
    create: XOR<AcademicPeriodCreateWithoutCoursesInput, AcademicPeriodUncheckedCreateWithoutCoursesInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutCoursesInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutCoursesInput, AcademicPeriodUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademicPeriodUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutPeriodsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutCourseInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutCourseInput, SubjectUncheckedUpdateWithoutCourseInput>
    create: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutCourseInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutCourseInput, SubjectUncheckedUpdateWithoutCourseInput>
  }

  export type SubjectUpdateManyWithWhereWithoutCourseInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutCourseInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    courseId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    semester?: IntNullableFilter<"Subject"> | number | null
    credits?: IntNullableFilter<"Subject"> | number | null
    createdAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
  }

  export type CertificateUpdateManyWithWhereWithoutCourseInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutCoursesInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCoursesInput
    createdBy?: UserCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    certificate?: CertificateCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSubjectsInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSubjectsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSubjectsInput, CourseUncheckedCreateWithoutSubjectsInput>
  }

  export type VirtualClassroomCreateWithoutSubjectInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutSubjectInput = {
    id?: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutSubjectInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutSubjectInput, VirtualClassroomUncheckedCreateWithoutSubjectInput>
  }

  export type VirtualClassroomCreateManySubjectInputEnvelope = {
    data: VirtualClassroomCreateManySubjectInput | VirtualClassroomCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type StudentSubjectCreateWithoutSubjectInput = {
    id?: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutSubjectsInput
    classroom?: VirtualClassroomCreateNestedOneWithoutStudentSubjectInput
    grades?: GradeCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectCreateOrConnectWithoutSubjectInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type StudentSubjectCreateManySubjectInputEnvelope = {
    data: StudentSubjectCreateManySubjectInput | StudentSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type DisciplinaryRecordCreateWithoutSubjectInput = {
    id?: string
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
    student: StudentCreateNestedOneWithoutDisciplinaryRecordInput
    recordedBy?: UserCreateNestedOneWithoutDisciplinaryRecordInput
  }

  export type DisciplinaryRecordUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    recordedById?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type DisciplinaryRecordCreateOrConnectWithoutSubjectInput = {
    where: DisciplinaryRecordWhereUniqueInput
    create: XOR<DisciplinaryRecordCreateWithoutSubjectInput, DisciplinaryRecordUncheckedCreateWithoutSubjectInput>
  }

  export type DisciplinaryRecordCreateManySubjectInputEnvelope = {
    data: DisciplinaryRecordCreateManySubjectInput | DisciplinaryRecordCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutSubjectInput = {
    id?: string
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student: StudentCreateNestedOneWithoutCertificatesInput
    course?: CourseCreateNestedOneWithoutCertificateInput
    issuedBy?: UserCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    courseId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateCreateOrConnectWithoutSubjectInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutSubjectInput, CertificateUncheckedCreateWithoutSubjectInput>
  }

  export type CertificateCreateManySubjectInputEnvelope = {
    data: CertificateCreateManySubjectInput | CertificateCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutSubjectsInput = {
    update: XOR<CourseUpdateWithoutSubjectsInput, CourseUncheckedUpdateWithoutSubjectsInput>
    create: XOR<CourseCreateWithoutSubjectsInput, CourseUncheckedCreateWithoutSubjectsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSubjectsInput, CourseUncheckedUpdateWithoutSubjectsInput>
  }

  export type CourseUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutCoursesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCoursesNestedInput
    createdBy?: UserUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type VirtualClassroomUpsertWithWhereUniqueWithoutSubjectInput = {
    where: VirtualClassroomWhereUniqueInput
    update: XOR<VirtualClassroomUpdateWithoutSubjectInput, VirtualClassroomUncheckedUpdateWithoutSubjectInput>
    create: XOR<VirtualClassroomCreateWithoutSubjectInput, VirtualClassroomUncheckedCreateWithoutSubjectInput>
  }

  export type VirtualClassroomUpdateWithWhereUniqueWithoutSubjectInput = {
    where: VirtualClassroomWhereUniqueInput
    data: XOR<VirtualClassroomUpdateWithoutSubjectInput, VirtualClassroomUncheckedUpdateWithoutSubjectInput>
  }

  export type VirtualClassroomUpdateManyWithWhereWithoutSubjectInput = {
    where: VirtualClassroomScalarWhereInput
    data: XOR<VirtualClassroomUpdateManyMutationInput, VirtualClassroomUncheckedUpdateManyWithoutSubjectInput>
  }

  export type StudentSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: StudentSubjectWhereUniqueInput
    update: XOR<StudentSubjectUpdateWithoutSubjectInput, StudentSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<StudentSubjectCreateWithoutSubjectInput, StudentSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type StudentSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: StudentSubjectWhereUniqueInput
    data: XOR<StudentSubjectUpdateWithoutSubjectInput, StudentSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type StudentSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: StudentSubjectScalarWhereInput
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type StudentSubjectScalarWhereInput = {
    AND?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
    OR?: StudentSubjectScalarWhereInput[]
    NOT?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
    id?: StringFilter<"StudentSubject"> | string
    studentId?: StringFilter<"StudentSubject"> | string
    subjectId?: StringFilter<"StudentSubject"> | string
    classroomId?: StringNullableFilter<"StudentSubject"> | string | null
    semester?: IntNullableFilter<"StudentSubject"> | number | null
    year?: IntNullableFilter<"StudentSubject"> | number | null
    finalGrade?: DecimalNullableFilter<"StudentSubject"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"StudentSubject"> | string | null
    createdAt?: DateTimeFilter<"StudentSubject"> | Date | string
  }

  export type DisciplinaryRecordUpsertWithWhereUniqueWithoutSubjectInput = {
    where: DisciplinaryRecordWhereUniqueInput
    update: XOR<DisciplinaryRecordUpdateWithoutSubjectInput, DisciplinaryRecordUncheckedUpdateWithoutSubjectInput>
    create: XOR<DisciplinaryRecordCreateWithoutSubjectInput, DisciplinaryRecordUncheckedCreateWithoutSubjectInput>
  }

  export type DisciplinaryRecordUpdateWithWhereUniqueWithoutSubjectInput = {
    where: DisciplinaryRecordWhereUniqueInput
    data: XOR<DisciplinaryRecordUpdateWithoutSubjectInput, DisciplinaryRecordUncheckedUpdateWithoutSubjectInput>
  }

  export type DisciplinaryRecordUpdateManyWithWhereWithoutSubjectInput = {
    where: DisciplinaryRecordScalarWhereInput
    data: XOR<DisciplinaryRecordUpdateManyMutationInput, DisciplinaryRecordUncheckedUpdateManyWithoutSubjectInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutSubjectInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutSubjectInput, CertificateUncheckedUpdateWithoutSubjectInput>
    create: XOR<CertificateCreateWithoutSubjectInput, CertificateUncheckedCreateWithoutSubjectInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutSubjectInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutSubjectInput, CertificateUncheckedUpdateWithoutSubjectInput>
  }

  export type CertificateUpdateManyWithWhereWithoutSubjectInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SubjectCreateWithoutClassroomsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSubjectsInput
    studentSubjects?: StudentSubjectCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutSubjectInput
    certificate?: CertificateCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassroomsInput = {
    id?: string
    courseId: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    studentSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutSubjectInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassroomsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassroomsInput, SubjectUncheckedCreateWithoutClassroomsInput>
  }

  export type UserCreateWithoutVirtualClassroomsInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutVirtualClassroomsInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutVirtualClassroomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVirtualClassroomsInput, UserUncheckedCreateWithoutVirtualClassroomsInput>
  }

  export type AIAgentCreateWithoutClassroomsInput = {
    id?: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutAiAgentsInput
    conversations?: AIConversationCreateNestedManyWithoutAgentInput
  }

  export type AIAgentUncheckedCreateWithoutClassroomsInput = {
    id?: string
    institutionId: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    conversations?: AIConversationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AIAgentCreateOrConnectWithoutClassroomsInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutClassroomsInput, AIAgentUncheckedCreateWithoutClassroomsInput>
  }

  export type LessonPlanCreateWithoutClassroomInput = {
    id?: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutLessonPlansInput
  }

  export type LessonPlanUncheckedCreateWithoutClassroomInput = {
    id?: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type LessonPlanCreateOrConnectWithoutClassroomInput = {
    where: LessonPlanWhereUniqueInput
    create: XOR<LessonPlanCreateWithoutClassroomInput, LessonPlanUncheckedCreateWithoutClassroomInput>
  }

  export type LessonPlanCreateManyClassroomInputEnvelope = {
    data: LessonPlanCreateManyClassroomInput | LessonPlanCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutClassroomInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
    notedBy?: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutClassroomInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notedById?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutClassroomInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutClassroomInput, AttendanceUncheckedCreateWithoutClassroomInput>
  }

  export type AttendanceCreateManyClassroomInputEnvelope = {
    data: AttendanceCreateManyClassroomInput | AttendanceCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type AIUsageLogCreateWithoutClassroomInput = {
    id?: string
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiUsagesInput
    institution: InstitutionCreateNestedOneWithoutAiUsageLogsInput
  }

  export type AIUsageLogUncheckedCreateWithoutClassroomInput = {
    id?: string
    userId: string
    institutionId: string
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AIUsageLogCreateOrConnectWithoutClassroomInput = {
    where: AIUsageLogWhereUniqueInput
    create: XOR<AIUsageLogCreateWithoutClassroomInput, AIUsageLogUncheckedCreateWithoutClassroomInput>
  }

  export type AIUsageLogCreateManyClassroomInputEnvelope = {
    data: AIUsageLogCreateManyClassroomInput | AIUsageLogCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type StudentSubjectCreateWithoutClassroomInput = {
    id?: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutStudentSubjectsInput
    grades?: GradeCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectUncheckedCreateWithoutClassroomInput = {
    id?: string
    studentId: string
    subjectId: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectCreateOrConnectWithoutClassroomInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutClassroomInput, StudentSubjectUncheckedCreateWithoutClassroomInput>
  }

  export type StudentSubjectCreateManyClassroomInputEnvelope = {
    data: StudentSubjectCreateManyClassroomInput | StudentSubjectCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type SubjectUpsertWithoutClassroomsInput = {
    update: XOR<SubjectUpdateWithoutClassroomsInput, SubjectUncheckedUpdateWithoutClassroomsInput>
    create: XOR<SubjectCreateWithoutClassroomsInput, SubjectUncheckedCreateWithoutClassroomsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutClassroomsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutClassroomsInput, SubjectUncheckedUpdateWithoutClassroomsInput>
  }

  export type SubjectUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSubjectsNestedInput
    studentSubjects?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSubjects?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserUpsertWithoutVirtualClassroomsInput = {
    update: XOR<UserUpdateWithoutVirtualClassroomsInput, UserUncheckedUpdateWithoutVirtualClassroomsInput>
    create: XOR<UserCreateWithoutVirtualClassroomsInput, UserUncheckedCreateWithoutVirtualClassroomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVirtualClassroomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVirtualClassroomsInput, UserUncheckedUpdateWithoutVirtualClassroomsInput>
  }

  export type UserUpdateWithoutVirtualClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVirtualClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AIAgentUpsertWithoutClassroomsInput = {
    update: XOR<AIAgentUpdateWithoutClassroomsInput, AIAgentUncheckedUpdateWithoutClassroomsInput>
    create: XOR<AIAgentCreateWithoutClassroomsInput, AIAgentUncheckedCreateWithoutClassroomsInput>
    where?: AIAgentWhereInput
  }

  export type AIAgentUpdateToOneWithWhereWithoutClassroomsInput = {
    where?: AIAgentWhereInput
    data: XOR<AIAgentUpdateWithoutClassroomsInput, AIAgentUncheckedUpdateWithoutClassroomsInput>
  }

  export type AIAgentUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutAiAgentsNestedInput
    conversations?: AIConversationUpdateManyWithoutAgentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type LessonPlanUpsertWithWhereUniqueWithoutClassroomInput = {
    where: LessonPlanWhereUniqueInput
    update: XOR<LessonPlanUpdateWithoutClassroomInput, LessonPlanUncheckedUpdateWithoutClassroomInput>
    create: XOR<LessonPlanCreateWithoutClassroomInput, LessonPlanUncheckedCreateWithoutClassroomInput>
  }

  export type LessonPlanUpdateWithWhereUniqueWithoutClassroomInput = {
    where: LessonPlanWhereUniqueInput
    data: XOR<LessonPlanUpdateWithoutClassroomInput, LessonPlanUncheckedUpdateWithoutClassroomInput>
  }

  export type LessonPlanUpdateManyWithWhereWithoutClassroomInput = {
    where: LessonPlanScalarWhereInput
    data: XOR<LessonPlanUpdateManyMutationInput, LessonPlanUncheckedUpdateManyWithoutClassroomInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutClassroomInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutClassroomInput, AttendanceUncheckedUpdateWithoutClassroomInput>
    create: XOR<AttendanceCreateWithoutClassroomInput, AttendanceUncheckedCreateWithoutClassroomInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutClassroomInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutClassroomInput, AttendanceUncheckedUpdateWithoutClassroomInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutClassroomInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutClassroomInput>
  }

  export type AIUsageLogUpsertWithWhereUniqueWithoutClassroomInput = {
    where: AIUsageLogWhereUniqueInput
    update: XOR<AIUsageLogUpdateWithoutClassroomInput, AIUsageLogUncheckedUpdateWithoutClassroomInput>
    create: XOR<AIUsageLogCreateWithoutClassroomInput, AIUsageLogUncheckedCreateWithoutClassroomInput>
  }

  export type AIUsageLogUpdateWithWhereUniqueWithoutClassroomInput = {
    where: AIUsageLogWhereUniqueInput
    data: XOR<AIUsageLogUpdateWithoutClassroomInput, AIUsageLogUncheckedUpdateWithoutClassroomInput>
  }

  export type AIUsageLogUpdateManyWithWhereWithoutClassroomInput = {
    where: AIUsageLogScalarWhereInput
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyWithoutClassroomInput>
  }

  export type StudentSubjectUpsertWithWhereUniqueWithoutClassroomInput = {
    where: StudentSubjectWhereUniqueInput
    update: XOR<StudentSubjectUpdateWithoutClassroomInput, StudentSubjectUncheckedUpdateWithoutClassroomInput>
    create: XOR<StudentSubjectCreateWithoutClassroomInput, StudentSubjectUncheckedCreateWithoutClassroomInput>
  }

  export type StudentSubjectUpdateWithWhereUniqueWithoutClassroomInput = {
    where: StudentSubjectWhereUniqueInput
    data: XOR<StudentSubjectUpdateWithoutClassroomInput, StudentSubjectUncheckedUpdateWithoutClassroomInput>
  }

  export type StudentSubjectUpdateManyWithWhereWithoutClassroomInput = {
    where: StudentSubjectScalarWhereInput
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyWithoutClassroomInput>
  }

  export type VirtualClassroomCreateWithoutLessonPlansInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutLessonPlansInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutLessonPlansInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutLessonPlansInput, VirtualClassroomUncheckedCreateWithoutLessonPlansInput>
  }

  export type UserCreateWithoutLessonPlansInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutLessonPlansInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutLessonPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonPlansInput, UserUncheckedCreateWithoutLessonPlansInput>
  }

  export type VirtualClassroomUpsertWithoutLessonPlansInput = {
    update: XOR<VirtualClassroomUpdateWithoutLessonPlansInput, VirtualClassroomUncheckedUpdateWithoutLessonPlansInput>
    create: XOR<VirtualClassroomCreateWithoutLessonPlansInput, VirtualClassroomUncheckedCreateWithoutLessonPlansInput>
    where?: VirtualClassroomWhereInput
  }

  export type VirtualClassroomUpdateToOneWithWhereWithoutLessonPlansInput = {
    where?: VirtualClassroomWhereInput
    data: XOR<VirtualClassroomUpdateWithoutLessonPlansInput, VirtualClassroomUncheckedUpdateWithoutLessonPlansInput>
  }

  export type VirtualClassroomUpdateWithoutLessonPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutLessonPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserUpsertWithoutLessonPlansInput = {
    update: XOR<UserUpdateWithoutLessonPlansInput, UserUncheckedUpdateWithoutLessonPlansInput>
    create: XOR<UserCreateWithoutLessonPlansInput, UserUncheckedCreateWithoutLessonPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonPlansInput, UserUncheckedUpdateWithoutLessonPlansInput>
  }

  export type UserUpdateWithoutLessonPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type InstitutionCreateWithoutStudentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutStudentsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
  }

  export type CareerCreateWithoutStudentsInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutCareersInput
    createdBy?: UserCreateNestedOneWithoutCareersInput
    courses?: CourseCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutStudentsInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput
    feeSchedule?: FeeScheduleUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutStudentsInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutStudentsInput, CareerUncheckedCreateWithoutStudentsInput>
  }

  export type EnrollmentCreateWithoutStudentInput = {
    id?: string
    enrolledAt?: Date | string
    status?: string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    courseId: string
    academicPeriodId?: string | null
    enrolledAt?: Date | string
    status?: string | null
  }

  export type EnrollmentCreateOrConnectWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentCreateManyStudentInputEnvelope = {
    data: EnrollmentCreateManyStudentInput | EnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSubjectCreateWithoutStudentInput = {
    id?: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutStudentSubjectsInput
    classroom?: VirtualClassroomCreateNestedOneWithoutStudentSubjectInput
    grades?: GradeCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStudentSubjectInput
  }

  export type StudentSubjectCreateOrConnectWithoutStudentInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput>
  }

  export type StudentSubjectCreateManyStudentInputEnvelope = {
    data: StudentSubjectCreateManyStudentInput | StudentSubjectCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    createdAt?: Date | string
    classroom: VirtualClassroomCreateNestedOneWithoutAttendancesInput
    notedBy?: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    classroomId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notedById?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceCreateManyStudentInputEnvelope = {
    data: AttendanceCreateManyStudentInput | AttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TutorStudentCreateWithoutStudentInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    tutor: TutorProfileCreateNestedOneWithoutTutorAssignmentsInput
  }

  export type TutorStudentUncheckedCreateWithoutStudentInput = {
    id?: string
    tutorId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type TutorStudentCreateOrConnectWithoutStudentInput = {
    where: TutorStudentWhereUniqueInput
    create: XOR<TutorStudentCreateWithoutStudentInput, TutorStudentUncheckedCreateWithoutStudentInput>
  }

  export type TutorStudentCreateManyStudentInputEnvelope = {
    data: TutorStudentCreateManyStudentInput | TutorStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentPaymentCreateWithoutStudentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutStudentPaymentsInput
    feeInstallment?: FeeInstallmentCreateNestedOneWithoutStudentPaymentsInput
  }

  export type StudentPaymentUncheckedCreateWithoutStudentInput = {
    id?: string
    institutionId: string
    feeInstallmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudentPaymentCreateOrConnectWithoutStudentInput = {
    where: StudentPaymentWhereUniqueInput
    create: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentPaymentCreateManyStudentInputEnvelope = {
    data: StudentPaymentCreateManyStudentInput | StudentPaymentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutStudentInput = {
    id?: string
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    course?: CourseCreateNestedOneWithoutCertificateInput
    subject?: SubjectCreateNestedOneWithoutCertificateInput
    issuedBy?: UserCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutStudentInput = {
    id?: string
    courseId?: string | null
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateCreateOrConnectWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateCreateManyStudentInputEnvelope = {
    data: CertificateCreateManyStudentInput | CertificateCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type DisciplinaryRecordCreateWithoutStudentInput = {
    id?: string
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
    subject?: SubjectCreateNestedOneWithoutDisciplinaryRecordInput
    recordedBy?: UserCreateNestedOneWithoutDisciplinaryRecordInput
  }

  export type DisciplinaryRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId?: string | null
    recordedById?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type DisciplinaryRecordCreateOrConnectWithoutStudentInput = {
    where: DisciplinaryRecordWhereUniqueInput
    create: XOR<DisciplinaryRecordCreateWithoutStudentInput, DisciplinaryRecordUncheckedCreateWithoutStudentInput>
  }

  export type DisciplinaryRecordCreateManyStudentInputEnvelope = {
    data: DisciplinaryRecordCreateManyStudentInput | DisciplinaryRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentPlanCreateWithoutStudentInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    feeSchedule: FeeScheduleCreateNestedOneWithoutPaymentPlanInput
  }

  export type PaymentPlanUncheckedCreateWithoutStudentInput = {
    id?: string
    feeScheduleId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type PaymentPlanCreateOrConnectWithoutStudentInput = {
    where: PaymentPlanWhereUniqueInput
    create: XOR<PaymentPlanCreateWithoutStudentInput, PaymentPlanUncheckedCreateWithoutStudentInput>
  }

  export type PaymentPlanCreateManyStudentInputEnvelope = {
    data: PaymentPlanCreateManyStudentInput | PaymentPlanCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionUpsertWithoutStudentsInput = {
    update: XOR<InstitutionUpdateWithoutStudentsInput, InstitutionUncheckedUpdateWithoutStudentsInput>
    create: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutStudentsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutStudentsInput, InstitutionUncheckedUpdateWithoutStudentsInput>
  }

  export type InstitutionUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type CareerUpsertWithoutStudentsInput = {
    update: XOR<CareerUpdateWithoutStudentsInput, CareerUncheckedUpdateWithoutStudentsInput>
    create: XOR<CareerCreateWithoutStudentsInput, CareerUncheckedCreateWithoutStudentsInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutStudentsInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutStudentsInput, CareerUncheckedUpdateWithoutStudentsInput>
  }

  export type CareerUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutCareersNestedInput
    createdBy?: UserUpdateOneWithoutCareersNestedInput
    courses?: CourseUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSubjectUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSubjectWhereUniqueInput
    update: XOR<StudentSubjectUpdateWithoutStudentInput, StudentSubjectUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSubjectCreateWithoutStudentInput, StudentSubjectUncheckedCreateWithoutStudentInput>
  }

  export type StudentSubjectUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSubjectWhereUniqueInput
    data: XOR<StudentSubjectUpdateWithoutStudentInput, StudentSubjectUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSubjectUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSubjectScalarWhereInput
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type TutorStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: TutorStudentWhereUniqueInput
    update: XOR<TutorStudentUpdateWithoutStudentInput, TutorStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<TutorStudentCreateWithoutStudentInput, TutorStudentUncheckedCreateWithoutStudentInput>
  }

  export type TutorStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: TutorStudentWhereUniqueInput
    data: XOR<TutorStudentUpdateWithoutStudentInput, TutorStudentUncheckedUpdateWithoutStudentInput>
  }

  export type TutorStudentUpdateManyWithWhereWithoutStudentInput = {
    where: TutorStudentScalarWhereInput
    data: XOR<TutorStudentUpdateManyMutationInput, TutorStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type TutorStudentScalarWhereInput = {
    AND?: TutorStudentScalarWhereInput | TutorStudentScalarWhereInput[]
    OR?: TutorStudentScalarWhereInput[]
    NOT?: TutorStudentScalarWhereInput | TutorStudentScalarWhereInput[]
    id?: StringFilter<"TutorStudent"> | string
    tutorId?: StringFilter<"TutorStudent"> | string
    studentId?: StringFilter<"TutorStudent"> | string
    isPrimary?: BoolFilter<"TutorStudent"> | boolean
    assignedAt?: DateTimeFilter<"TutorStudent"> | Date | string
  }

  export type StudentPaymentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentPaymentWhereUniqueInput
    update: XOR<StudentPaymentUpdateWithoutStudentInput, StudentPaymentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentPaymentCreateWithoutStudentInput, StudentPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentPaymentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentPaymentWhereUniqueInput
    data: XOR<StudentPaymentUpdateWithoutStudentInput, StudentPaymentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentPaymentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentPaymentScalarWhereInput
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyWithoutStudentInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
  }

  export type CertificateUpdateManyWithWhereWithoutStudentInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutStudentInput>
  }

  export type DisciplinaryRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: DisciplinaryRecordWhereUniqueInput
    update: XOR<DisciplinaryRecordUpdateWithoutStudentInput, DisciplinaryRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<DisciplinaryRecordCreateWithoutStudentInput, DisciplinaryRecordUncheckedCreateWithoutStudentInput>
  }

  export type DisciplinaryRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: DisciplinaryRecordWhereUniqueInput
    data: XOR<DisciplinaryRecordUpdateWithoutStudentInput, DisciplinaryRecordUncheckedUpdateWithoutStudentInput>
  }

  export type DisciplinaryRecordUpdateManyWithWhereWithoutStudentInput = {
    where: DisciplinaryRecordScalarWhereInput
    data: XOR<DisciplinaryRecordUpdateManyMutationInput, DisciplinaryRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type PaymentPlanUpsertWithWhereUniqueWithoutStudentInput = {
    where: PaymentPlanWhereUniqueInput
    update: XOR<PaymentPlanUpdateWithoutStudentInput, PaymentPlanUncheckedUpdateWithoutStudentInput>
    create: XOR<PaymentPlanCreateWithoutStudentInput, PaymentPlanUncheckedCreateWithoutStudentInput>
  }

  export type PaymentPlanUpdateWithWhereUniqueWithoutStudentInput = {
    where: PaymentPlanWhereUniqueInput
    data: XOR<PaymentPlanUpdateWithoutStudentInput, PaymentPlanUncheckedUpdateWithoutStudentInput>
  }

  export type PaymentPlanUpdateManyWithWhereWithoutStudentInput = {
    where: PaymentPlanScalarWhereInput
    data: XOR<PaymentPlanUpdateManyMutationInput, PaymentPlanUncheckedUpdateManyWithoutStudentInput>
  }

  export type PaymentPlanScalarWhereInput = {
    AND?: PaymentPlanScalarWhereInput | PaymentPlanScalarWhereInput[]
    OR?: PaymentPlanScalarWhereInput[]
    NOT?: PaymentPlanScalarWhereInput | PaymentPlanScalarWhereInput[]
    id?: StringFilter<"PaymentPlan"> | string
    studentId?: StringFilter<"PaymentPlan"> | string
    feeScheduleId?: StringFilter<"PaymentPlan"> | string
    totalAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFilter<"PaymentPlan"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PaymentPlan"> | string
    createdAt?: DateTimeFilter<"PaymentPlan"> | Date | string
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutCoursesInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCoursesInput
    createdBy?: UserCreateNestedOneWithoutCoursesInput
    subjects?: SubjectCreateNestedManyWithoutCourseInput
    certificate?: CertificateCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCourseInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type AcademicPeriodCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutPeriodsInput
    courses?: CourseCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    careerId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutEnrollmentsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutEnrollmentsInput, AcademicPeriodUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutCoursesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCoursesNestedInput
    createdBy?: UserUpdateOneWithoutCoursesNestedInput
    subjects?: SubjectUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicPeriodUpsertWithoutEnrollmentsInput = {
    update: XOR<AcademicPeriodUpdateWithoutEnrollmentsInput, AcademicPeriodUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<AcademicPeriodCreateWithoutEnrollmentsInput, AcademicPeriodUncheckedCreateWithoutEnrollmentsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutEnrollmentsInput, AcademicPeriodUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type AcademicPeriodUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutPeriodsNestedInput
    courses?: CourseUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type StudentCreateWithoutSubjectsInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSubjectsInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSubjectsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutStudentSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSubjectsInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutSubjectInput
    certificate?: CertificateCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutStudentSubjectsInput = {
    id?: string
    courseId: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutSubjectInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutStudentSubjectsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutStudentSubjectsInput, SubjectUncheckedCreateWithoutStudentSubjectsInput>
  }

  export type VirtualClassroomCreateWithoutStudentSubjectInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutStudentSubjectInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutStudentSubjectInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutStudentSubjectInput, VirtualClassroomUncheckedCreateWithoutStudentSubjectInput>
  }

  export type GradeCreateWithoutStudentSubjectInput = {
    id?: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutStudentSubjectInput = {
    id?: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutStudentSubjectInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStudentSubjectInput, GradeUncheckedCreateWithoutStudentSubjectInput>
  }

  export type GradeCreateManyStudentSubjectInputEnvelope = {
    data: GradeCreateManyStudentSubjectInput | GradeCreateManyStudentSubjectInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutSubjectsInput = {
    update: XOR<StudentUpdateWithoutSubjectsInput, StudentUncheckedUpdateWithoutSubjectsInput>
    create: XOR<StudentCreateWithoutSubjectsInput, StudentUncheckedCreateWithoutSubjectsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSubjectsInput, StudentUncheckedUpdateWithoutSubjectsInput>
  }

  export type StudentUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutStudentSubjectsInput = {
    update: XOR<SubjectUpdateWithoutStudentSubjectsInput, SubjectUncheckedUpdateWithoutStudentSubjectsInput>
    create: XOR<SubjectCreateWithoutStudentSubjectsInput, SubjectUncheckedCreateWithoutStudentSubjectsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutStudentSubjectsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutStudentSubjectsInput, SubjectUncheckedUpdateWithoutStudentSubjectsInput>
  }

  export type SubjectUpdateWithoutStudentSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSubjectsNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutStudentSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type VirtualClassroomUpsertWithoutStudentSubjectInput = {
    update: XOR<VirtualClassroomUpdateWithoutStudentSubjectInput, VirtualClassroomUncheckedUpdateWithoutStudentSubjectInput>
    create: XOR<VirtualClassroomCreateWithoutStudentSubjectInput, VirtualClassroomUncheckedCreateWithoutStudentSubjectInput>
    where?: VirtualClassroomWhereInput
  }

  export type VirtualClassroomUpdateToOneWithWhereWithoutStudentSubjectInput = {
    where?: VirtualClassroomWhereInput
    data: XOR<VirtualClassroomUpdateWithoutStudentSubjectInput, VirtualClassroomUncheckedUpdateWithoutStudentSubjectInput>
  }

  export type VirtualClassroomUpdateWithoutStudentSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutStudentSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type GradeUpsertWithWhereUniqueWithoutStudentSubjectInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutStudentSubjectInput, GradeUncheckedUpdateWithoutStudentSubjectInput>
    create: XOR<GradeCreateWithoutStudentSubjectInput, GradeUncheckedCreateWithoutStudentSubjectInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutStudentSubjectInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutStudentSubjectInput, GradeUncheckedUpdateWithoutStudentSubjectInput>
  }

  export type GradeUpdateManyWithWhereWithoutStudentSubjectInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutStudentSubjectInput>
  }

  export type StudentSubjectCreateWithoutGradesInput = {
    id?: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutStudentSubjectsInput
    classroom?: VirtualClassroomCreateNestedOneWithoutStudentSubjectInput
  }

  export type StudentSubjectUncheckedCreateWithoutGradesInput = {
    id?: string
    studentId: string
    subjectId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type StudentSubjectCreateOrConnectWithoutGradesInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutGradesInput, StudentSubjectUncheckedCreateWithoutGradesInput>
  }

  export type UserCreateWithoutGradesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutGradesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutGradesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradesInput, UserUncheckedCreateWithoutGradesInput>
  }

  export type StudentSubjectUpsertWithoutGradesInput = {
    update: XOR<StudentSubjectUpdateWithoutGradesInput, StudentSubjectUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentSubjectCreateWithoutGradesInput, StudentSubjectUncheckedCreateWithoutGradesInput>
    where?: StudentSubjectWhereInput
  }

  export type StudentSubjectUpdateToOneWithWhereWithoutGradesInput = {
    where?: StudentSubjectWhereInput
    data: XOR<StudentSubjectUpdateWithoutGradesInput, StudentSubjectUncheckedUpdateWithoutGradesInput>
  }

  export type StudentSubjectUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutStudentSubjectsNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutGradesInput = {
    update: XOR<UserUpdateWithoutGradesInput, UserUncheckedUpdateWithoutGradesInput>
    create: XOR<UserCreateWithoutGradesInput, UserUncheckedCreateWithoutGradesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradesInput, UserUncheckedUpdateWithoutGradesInput>
  }

  export type UserUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type StudentCreateWithoutAttendancesInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendancesInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendancesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
  }

  export type VirtualClassroomCreateWithoutAttendancesInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutAttendancesInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutAttendancesInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutAttendancesInput, VirtualClassroomUncheckedCreateWithoutAttendancesInput>
  }

  export type UserCreateWithoutAttendancesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type StudentUpsertWithoutAttendancesInput = {
    update: XOR<StudentUpdateWithoutAttendancesInput, StudentUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendancesInput, StudentUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type VirtualClassroomUpsertWithoutAttendancesInput = {
    update: XOR<VirtualClassroomUpdateWithoutAttendancesInput, VirtualClassroomUncheckedUpdateWithoutAttendancesInput>
    create: XOR<VirtualClassroomCreateWithoutAttendancesInput, VirtualClassroomUncheckedCreateWithoutAttendancesInput>
    where?: VirtualClassroomWhereInput
  }

  export type VirtualClassroomUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: VirtualClassroomWhereInput
    data: XOR<VirtualClassroomUpdateWithoutAttendancesInput, VirtualClassroomUncheckedUpdateWithoutAttendancesInput>
  }

  export type VirtualClassroomUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type StudentCreateWithoutDisciplinaryRecordInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDisciplinaryRecordInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDisciplinaryRecordInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDisciplinaryRecordInput, StudentUncheckedCreateWithoutDisciplinaryRecordInput>
  }

  export type SubjectCreateWithoutDisciplinaryRecordInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSubjectsInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectCreateNestedManyWithoutSubjectInput
    certificate?: CertificateCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutDisciplinaryRecordInput = {
    id?: string
    courseId: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutDisciplinaryRecordInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutDisciplinaryRecordInput, SubjectUncheckedCreateWithoutDisciplinaryRecordInput>
  }

  export type UserCreateWithoutDisciplinaryRecordInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDisciplinaryRecordInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDisciplinaryRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisciplinaryRecordInput, UserUncheckedCreateWithoutDisciplinaryRecordInput>
  }

  export type StudentUpsertWithoutDisciplinaryRecordInput = {
    update: XOR<StudentUpdateWithoutDisciplinaryRecordInput, StudentUncheckedUpdateWithoutDisciplinaryRecordInput>
    create: XOR<StudentCreateWithoutDisciplinaryRecordInput, StudentUncheckedCreateWithoutDisciplinaryRecordInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutDisciplinaryRecordInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutDisciplinaryRecordInput, StudentUncheckedUpdateWithoutDisciplinaryRecordInput>
  }

  export type StudentUpdateWithoutDisciplinaryRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDisciplinaryRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutDisciplinaryRecordInput = {
    update: XOR<SubjectUpdateWithoutDisciplinaryRecordInput, SubjectUncheckedUpdateWithoutDisciplinaryRecordInput>
    create: XOR<SubjectCreateWithoutDisciplinaryRecordInput, SubjectUncheckedCreateWithoutDisciplinaryRecordInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutDisciplinaryRecordInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutDisciplinaryRecordInput, SubjectUncheckedUpdateWithoutDisciplinaryRecordInput>
  }

  export type SubjectUpdateWithoutDisciplinaryRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSubjectsNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutDisciplinaryRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserUpsertWithoutDisciplinaryRecordInput = {
    update: XOR<UserUpdateWithoutDisciplinaryRecordInput, UserUncheckedUpdateWithoutDisciplinaryRecordInput>
    create: XOR<UserCreateWithoutDisciplinaryRecordInput, UserUncheckedCreateWithoutDisciplinaryRecordInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisciplinaryRecordInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisciplinaryRecordInput, UserUncheckedUpdateWithoutDisciplinaryRecordInput>
  }

  export type UserUpdateWithoutDisciplinaryRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDisciplinaryRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutTutorProfileInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTutorProfileInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTutorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTutorProfileInput, UserUncheckedCreateWithoutTutorProfileInput>
  }

  export type InstitutionCreateWithoutTutorProfileInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutTutorProfileInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutTutorProfileInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutTutorProfileInput, InstitutionUncheckedCreateWithoutTutorProfileInput>
  }

  export type TutorStudentCreateWithoutTutorInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    student: StudentCreateNestedOneWithoutTutorAssignmentsInput
  }

  export type TutorStudentUncheckedCreateWithoutTutorInput = {
    id?: string
    studentId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type TutorStudentCreateOrConnectWithoutTutorInput = {
    where: TutorStudentWhereUniqueInput
    create: XOR<TutorStudentCreateWithoutTutorInput, TutorStudentUncheckedCreateWithoutTutorInput>
  }

  export type TutorStudentCreateManyTutorInputEnvelope = {
    data: TutorStudentCreateManyTutorInput | TutorStudentCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTutorProfileInput = {
    update: XOR<UserUpdateWithoutTutorProfileInput, UserUncheckedUpdateWithoutTutorProfileInput>
    create: XOR<UserCreateWithoutTutorProfileInput, UserUncheckedCreateWithoutTutorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTutorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTutorProfileInput, UserUncheckedUpdateWithoutTutorProfileInput>
  }

  export type UserUpdateWithoutTutorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTutorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionUpsertWithoutTutorProfileInput = {
    update: XOR<InstitutionUpdateWithoutTutorProfileInput, InstitutionUncheckedUpdateWithoutTutorProfileInput>
    create: XOR<InstitutionCreateWithoutTutorProfileInput, InstitutionUncheckedCreateWithoutTutorProfileInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutTutorProfileInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutTutorProfileInput, InstitutionUncheckedUpdateWithoutTutorProfileInput>
  }

  export type InstitutionUpdateWithoutTutorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutTutorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type TutorStudentUpsertWithWhereUniqueWithoutTutorInput = {
    where: TutorStudentWhereUniqueInput
    update: XOR<TutorStudentUpdateWithoutTutorInput, TutorStudentUncheckedUpdateWithoutTutorInput>
    create: XOR<TutorStudentCreateWithoutTutorInput, TutorStudentUncheckedCreateWithoutTutorInput>
  }

  export type TutorStudentUpdateWithWhereUniqueWithoutTutorInput = {
    where: TutorStudentWhereUniqueInput
    data: XOR<TutorStudentUpdateWithoutTutorInput, TutorStudentUncheckedUpdateWithoutTutorInput>
  }

  export type TutorStudentUpdateManyWithWhereWithoutTutorInput = {
    where: TutorStudentScalarWhereInput
    data: XOR<TutorStudentUpdateManyMutationInput, TutorStudentUncheckedUpdateManyWithoutTutorInput>
  }

  export type TutorProfileCreateWithoutTutorAssignmentsInput = {
    id?: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTutorProfileInput
    institution: InstitutionCreateNestedOneWithoutTutorProfileInput
  }

  export type TutorProfileUncheckedCreateWithoutTutorAssignmentsInput = {
    id?: string
    userId: string
    institutionId: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TutorProfileCreateOrConnectWithoutTutorAssignmentsInput = {
    where: TutorProfileWhereUniqueInput
    create: XOR<TutorProfileCreateWithoutTutorAssignmentsInput, TutorProfileUncheckedCreateWithoutTutorAssignmentsInput>
  }

  export type StudentCreateWithoutTutorAssignmentsInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutTutorAssignmentsInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTutorAssignmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTutorAssignmentsInput, StudentUncheckedCreateWithoutTutorAssignmentsInput>
  }

  export type TutorProfileUpsertWithoutTutorAssignmentsInput = {
    update: XOR<TutorProfileUpdateWithoutTutorAssignmentsInput, TutorProfileUncheckedUpdateWithoutTutorAssignmentsInput>
    create: XOR<TutorProfileCreateWithoutTutorAssignmentsInput, TutorProfileUncheckedCreateWithoutTutorAssignmentsInput>
    where?: TutorProfileWhereInput
  }

  export type TutorProfileUpdateToOneWithWhereWithoutTutorAssignmentsInput = {
    where?: TutorProfileWhereInput
    data: XOR<TutorProfileUpdateWithoutTutorAssignmentsInput, TutorProfileUncheckedUpdateWithoutTutorAssignmentsInput>
  }

  export type TutorProfileUpdateWithoutTutorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTutorProfileNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutTutorProfileNestedInput
  }

  export type TutorProfileUncheckedUpdateWithoutTutorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutTutorAssignmentsInput = {
    update: XOR<StudentUpdateWithoutTutorAssignmentsInput, StudentUncheckedUpdateWithoutTutorAssignmentsInput>
    create: XOR<StudentCreateWithoutTutorAssignmentsInput, StudentUncheckedCreateWithoutTutorAssignmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTutorAssignmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTutorAssignmentsInput, StudentUncheckedUpdateWithoutTutorAssignmentsInput>
  }

  export type StudentUpdateWithoutTutorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutTutorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutCertificatesInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCertificatesInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCertificatesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
  }

  export type CourseCreateWithoutCertificateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
    career: CareerCreateNestedOneWithoutCoursesInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCoursesInput
    createdBy?: UserCreateNestedOneWithoutCoursesInput
    subjects?: SubjectCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCertificateInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCertificateInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCertificateInput, CourseUncheckedCreateWithoutCertificateInput>
  }

  export type SubjectCreateWithoutCertificateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutSubjectsInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutCertificateInput = {
    id?: string
    courseId: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutSubjectInput
    studentSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutSubjectInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutCertificateInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCertificateInput, SubjectUncheckedCreateWithoutCertificateInput>
  }

  export type UserCreateWithoutCertificateInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCertificateInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCertificateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
  }

  export type StudentUpsertWithoutCertificatesInput = {
    update: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutCertificateInput = {
    update: XOR<CourseUpdateWithoutCertificateInput, CourseUncheckedUpdateWithoutCertificateInput>
    create: XOR<CourseCreateWithoutCertificateInput, CourseUncheckedCreateWithoutCertificateInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCertificateInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCertificateInput, CourseUncheckedUpdateWithoutCertificateInput>
  }

  export type CourseUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutCoursesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCoursesNestedInput
    createdBy?: UserUpdateOneWithoutCoursesNestedInput
    subjects?: SubjectUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type SubjectUpsertWithoutCertificateInput = {
    update: XOR<SubjectUpdateWithoutCertificateInput, SubjectUncheckedUpdateWithoutCertificateInput>
    create: XOR<SubjectCreateWithoutCertificateInput, SubjectUncheckedCreateWithoutCertificateInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutCertificateInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutCertificateInput, SubjectUncheckedUpdateWithoutCertificateInput>
  }

  export type SubjectUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSubjectsNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserUpsertWithoutCertificateInput = {
    update: XOR<UserUpdateWithoutCertificateInput, UserUncheckedUpdateWithoutCertificateInput>
    create: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificateInput, UserUncheckedUpdateWithoutCertificateInput>
  }

  export type UserUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateWithoutFeeSchedulesInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutFeeSchedulesInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutFeeSchedulesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutFeeSchedulesInput, InstitutionUncheckedCreateWithoutFeeSchedulesInput>
  }

  export type CareerCreateWithoutFeeScheduleInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutCareersInput
    createdBy?: UserCreateNestedOneWithoutCareersInput
    courses?: CourseCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodCreateNestedManyWithoutCareerInput
    students?: StudentCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutFeeScheduleInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCareerInput
    periods?: AcademicPeriodUncheckedCreateNestedManyWithoutCareerInput
    students?: StudentUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutFeeScheduleInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutFeeScheduleInput, CareerUncheckedCreateWithoutFeeScheduleInput>
  }

  export type FeeInstallmentCreateWithoutFeeScheduleInput = {
    id?: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    studentPayments?: StudentPaymentCreateNestedManyWithoutFeeInstallmentInput
  }

  export type FeeInstallmentUncheckedCreateWithoutFeeScheduleInput = {
    id?: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutFeeInstallmentInput
  }

  export type FeeInstallmentCreateOrConnectWithoutFeeScheduleInput = {
    where: FeeInstallmentWhereUniqueInput
    create: XOR<FeeInstallmentCreateWithoutFeeScheduleInput, FeeInstallmentUncheckedCreateWithoutFeeScheduleInput>
  }

  export type FeeInstallmentCreateManyFeeScheduleInputEnvelope = {
    data: FeeInstallmentCreateManyFeeScheduleInput | FeeInstallmentCreateManyFeeScheduleInput[]
    skipDuplicates?: boolean
  }

  export type PaymentPlanCreateWithoutFeeScheduleInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutPaymentPlanInput
  }

  export type PaymentPlanUncheckedCreateWithoutFeeScheduleInput = {
    id?: string
    studentId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type PaymentPlanCreateOrConnectWithoutFeeScheduleInput = {
    where: PaymentPlanWhereUniqueInput
    create: XOR<PaymentPlanCreateWithoutFeeScheduleInput, PaymentPlanUncheckedCreateWithoutFeeScheduleInput>
  }

  export type PaymentPlanCreateManyFeeScheduleInputEnvelope = {
    data: PaymentPlanCreateManyFeeScheduleInput | PaymentPlanCreateManyFeeScheduleInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutFeeSchedulesInput = {
    update: XOR<InstitutionUpdateWithoutFeeSchedulesInput, InstitutionUncheckedUpdateWithoutFeeSchedulesInput>
    create: XOR<InstitutionCreateWithoutFeeSchedulesInput, InstitutionUncheckedCreateWithoutFeeSchedulesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutFeeSchedulesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutFeeSchedulesInput, InstitutionUncheckedUpdateWithoutFeeSchedulesInput>
  }

  export type InstitutionUpdateWithoutFeeSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutFeeSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type CareerUpsertWithoutFeeScheduleInput = {
    update: XOR<CareerUpdateWithoutFeeScheduleInput, CareerUncheckedUpdateWithoutFeeScheduleInput>
    create: XOR<CareerCreateWithoutFeeScheduleInput, CareerUncheckedCreateWithoutFeeScheduleInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutFeeScheduleInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutFeeScheduleInput, CareerUncheckedUpdateWithoutFeeScheduleInput>
  }

  export type CareerUpdateWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutCareersNestedInput
    createdBy?: UserUpdateOneWithoutCareersNestedInput
    courses?: CourseUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUpdateManyWithoutCareerNestedInput
    students?: StudentUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput
    students?: StudentUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type FeeInstallmentUpsertWithWhereUniqueWithoutFeeScheduleInput = {
    where: FeeInstallmentWhereUniqueInput
    update: XOR<FeeInstallmentUpdateWithoutFeeScheduleInput, FeeInstallmentUncheckedUpdateWithoutFeeScheduleInput>
    create: XOR<FeeInstallmentCreateWithoutFeeScheduleInput, FeeInstallmentUncheckedCreateWithoutFeeScheduleInput>
  }

  export type FeeInstallmentUpdateWithWhereUniqueWithoutFeeScheduleInput = {
    where: FeeInstallmentWhereUniqueInput
    data: XOR<FeeInstallmentUpdateWithoutFeeScheduleInput, FeeInstallmentUncheckedUpdateWithoutFeeScheduleInput>
  }

  export type FeeInstallmentUpdateManyWithWhereWithoutFeeScheduleInput = {
    where: FeeInstallmentScalarWhereInput
    data: XOR<FeeInstallmentUpdateManyMutationInput, FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleInput>
  }

  export type FeeInstallmentScalarWhereInput = {
    AND?: FeeInstallmentScalarWhereInput | FeeInstallmentScalarWhereInput[]
    OR?: FeeInstallmentScalarWhereInput[]
    NOT?: FeeInstallmentScalarWhereInput | FeeInstallmentScalarWhereInput[]
    id?: StringFilter<"FeeInstallment"> | string
    feeScheduleId?: StringFilter<"FeeInstallment"> | string
    sequence?: IntFilter<"FeeInstallment"> | number
    dueDate?: DateTimeFilter<"FeeInstallment"> | Date | string
    amount?: DecimalFilter<"FeeInstallment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"FeeInstallment"> | Date | string
  }

  export type PaymentPlanUpsertWithWhereUniqueWithoutFeeScheduleInput = {
    where: PaymentPlanWhereUniqueInput
    update: XOR<PaymentPlanUpdateWithoutFeeScheduleInput, PaymentPlanUncheckedUpdateWithoutFeeScheduleInput>
    create: XOR<PaymentPlanCreateWithoutFeeScheduleInput, PaymentPlanUncheckedCreateWithoutFeeScheduleInput>
  }

  export type PaymentPlanUpdateWithWhereUniqueWithoutFeeScheduleInput = {
    where: PaymentPlanWhereUniqueInput
    data: XOR<PaymentPlanUpdateWithoutFeeScheduleInput, PaymentPlanUncheckedUpdateWithoutFeeScheduleInput>
  }

  export type PaymentPlanUpdateManyWithWhereWithoutFeeScheduleInput = {
    where: PaymentPlanScalarWhereInput
    data: XOR<PaymentPlanUpdateManyMutationInput, PaymentPlanUncheckedUpdateManyWithoutFeeScheduleInput>
  }

  export type FeeScheduleCreateWithoutInstallmentsListInput = {
    id?: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutFeeSchedulesInput
    career?: CareerCreateNestedOneWithoutFeeScheduleInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleUncheckedCreateWithoutInstallmentsListInput = {
    id?: string
    institutionId: string
    careerId?: string | null
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleCreateOrConnectWithoutInstallmentsListInput = {
    where: FeeScheduleWhereUniqueInput
    create: XOR<FeeScheduleCreateWithoutInstallmentsListInput, FeeScheduleUncheckedCreateWithoutInstallmentsListInput>
  }

  export type StudentPaymentCreateWithoutFeeInstallmentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutPaymentsInput
    institution: InstitutionCreateNestedOneWithoutStudentPaymentsInput
  }

  export type StudentPaymentUncheckedCreateWithoutFeeInstallmentInput = {
    id?: string
    studentId: string
    institutionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudentPaymentCreateOrConnectWithoutFeeInstallmentInput = {
    where: StudentPaymentWhereUniqueInput
    create: XOR<StudentPaymentCreateWithoutFeeInstallmentInput, StudentPaymentUncheckedCreateWithoutFeeInstallmentInput>
  }

  export type StudentPaymentCreateManyFeeInstallmentInputEnvelope = {
    data: StudentPaymentCreateManyFeeInstallmentInput | StudentPaymentCreateManyFeeInstallmentInput[]
    skipDuplicates?: boolean
  }

  export type FeeScheduleUpsertWithoutInstallmentsListInput = {
    update: XOR<FeeScheduleUpdateWithoutInstallmentsListInput, FeeScheduleUncheckedUpdateWithoutInstallmentsListInput>
    create: XOR<FeeScheduleCreateWithoutInstallmentsListInput, FeeScheduleUncheckedCreateWithoutInstallmentsListInput>
    where?: FeeScheduleWhereInput
  }

  export type FeeScheduleUpdateToOneWithWhereWithoutInstallmentsListInput = {
    where?: FeeScheduleWhereInput
    data: XOR<FeeScheduleUpdateWithoutInstallmentsListInput, FeeScheduleUncheckedUpdateWithoutInstallmentsListInput>
  }

  export type FeeScheduleUpdateWithoutInstallmentsListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutFeeSchedulesNestedInput
    career?: CareerUpdateOneWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateWithoutInstallmentsListInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutFeeScheduleNestedInput
  }

  export type StudentPaymentUpsertWithWhereUniqueWithoutFeeInstallmentInput = {
    where: StudentPaymentWhereUniqueInput
    update: XOR<StudentPaymentUpdateWithoutFeeInstallmentInput, StudentPaymentUncheckedUpdateWithoutFeeInstallmentInput>
    create: XOR<StudentPaymentCreateWithoutFeeInstallmentInput, StudentPaymentUncheckedCreateWithoutFeeInstallmentInput>
  }

  export type StudentPaymentUpdateWithWhereUniqueWithoutFeeInstallmentInput = {
    where: StudentPaymentWhereUniqueInput
    data: XOR<StudentPaymentUpdateWithoutFeeInstallmentInput, StudentPaymentUncheckedUpdateWithoutFeeInstallmentInput>
  }

  export type StudentPaymentUpdateManyWithWhereWithoutFeeInstallmentInput = {
    where: StudentPaymentScalarWhereInput
    data: XOR<StudentPaymentUpdateManyMutationInput, StudentPaymentUncheckedUpdateManyWithoutFeeInstallmentInput>
  }

  export type StudentCreateWithoutPaymentsInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
    paymentPlan?: PaymentPlanUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPaymentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
  }

  export type InstitutionCreateWithoutStudentPaymentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutStudentPaymentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutStudentPaymentsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutStudentPaymentsInput, InstitutionUncheckedCreateWithoutStudentPaymentsInput>
  }

  export type FeeInstallmentCreateWithoutStudentPaymentsInput = {
    id?: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    feeSchedule: FeeScheduleCreateNestedOneWithoutInstallmentsListInput
  }

  export type FeeInstallmentUncheckedCreateWithoutStudentPaymentsInput = {
    id?: string
    feeScheduleId: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type FeeInstallmentCreateOrConnectWithoutStudentPaymentsInput = {
    where: FeeInstallmentWhereUniqueInput
    create: XOR<FeeInstallmentCreateWithoutStudentPaymentsInput, FeeInstallmentUncheckedCreateWithoutStudentPaymentsInput>
  }

  export type StudentUpsertWithoutPaymentsInput = {
    update: XOR<StudentUpdateWithoutPaymentsInput, StudentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StudentCreateWithoutPaymentsInput, StudentUncheckedCreateWithoutPaymentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPaymentsInput, StudentUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type InstitutionUpsertWithoutStudentPaymentsInput = {
    update: XOR<InstitutionUpdateWithoutStudentPaymentsInput, InstitutionUncheckedUpdateWithoutStudentPaymentsInput>
    create: XOR<InstitutionCreateWithoutStudentPaymentsInput, InstitutionUncheckedCreateWithoutStudentPaymentsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutStudentPaymentsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutStudentPaymentsInput, InstitutionUncheckedUpdateWithoutStudentPaymentsInput>
  }

  export type InstitutionUpdateWithoutStudentPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutStudentPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type FeeInstallmentUpsertWithoutStudentPaymentsInput = {
    update: XOR<FeeInstallmentUpdateWithoutStudentPaymentsInput, FeeInstallmentUncheckedUpdateWithoutStudentPaymentsInput>
    create: XOR<FeeInstallmentCreateWithoutStudentPaymentsInput, FeeInstallmentUncheckedCreateWithoutStudentPaymentsInput>
    where?: FeeInstallmentWhereInput
  }

  export type FeeInstallmentUpdateToOneWithWhereWithoutStudentPaymentsInput = {
    where?: FeeInstallmentWhereInput
    data: XOR<FeeInstallmentUpdateWithoutStudentPaymentsInput, FeeInstallmentUncheckedUpdateWithoutStudentPaymentsInput>
  }

  export type FeeInstallmentUpdateWithoutStudentPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeSchedule?: FeeScheduleUpdateOneRequiredWithoutInstallmentsListNestedInput
  }

  export type FeeInstallmentUncheckedUpdateWithoutStudentPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutPaymentPlanInput = {
    id?: string
    studentNumber?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    career?: CareerCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPaymentPlanInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    subjects?: StudentSubjectUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    tutorAssignments?: TutorStudentUncheckedCreateNestedManyWithoutStudentInput
    payments?: StudentPaymentUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPaymentPlanInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPaymentPlanInput, StudentUncheckedCreateWithoutPaymentPlanInput>
  }

  export type FeeScheduleCreateWithoutPaymentPlanInput = {
    id?: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutFeeSchedulesInput
    career?: CareerCreateNestedOneWithoutFeeScheduleInput
    installmentsList?: FeeInstallmentCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleUncheckedCreateWithoutPaymentPlanInput = {
    id?: string
    institutionId: string
    careerId?: string | null
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    installmentsList?: FeeInstallmentUncheckedCreateNestedManyWithoutFeeScheduleInput
  }

  export type FeeScheduleCreateOrConnectWithoutPaymentPlanInput = {
    where: FeeScheduleWhereUniqueInput
    create: XOR<FeeScheduleCreateWithoutPaymentPlanInput, FeeScheduleUncheckedCreateWithoutPaymentPlanInput>
  }

  export type StudentUpsertWithoutPaymentPlanInput = {
    update: XOR<StudentUpdateWithoutPaymentPlanInput, StudentUncheckedUpdateWithoutPaymentPlanInput>
    create: XOR<StudentCreateWithoutPaymentPlanInput, StudentUncheckedCreateWithoutPaymentPlanInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPaymentPlanInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPaymentPlanInput, StudentUncheckedUpdateWithoutPaymentPlanInput>
  }

  export type StudentUpdateWithoutPaymentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPaymentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FeeScheduleUpsertWithoutPaymentPlanInput = {
    update: XOR<FeeScheduleUpdateWithoutPaymentPlanInput, FeeScheduleUncheckedUpdateWithoutPaymentPlanInput>
    create: XOR<FeeScheduleCreateWithoutPaymentPlanInput, FeeScheduleUncheckedCreateWithoutPaymentPlanInput>
    where?: FeeScheduleWhereInput
  }

  export type FeeScheduleUpdateToOneWithWhereWithoutPaymentPlanInput = {
    where?: FeeScheduleWhereInput
    data: XOR<FeeScheduleUpdateWithoutPaymentPlanInput, FeeScheduleUncheckedUpdateWithoutPaymentPlanInput>
  }

  export type FeeScheduleUpdateWithoutPaymentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutFeeSchedulesNestedInput
    career?: CareerUpdateOneWithoutFeeScheduleNestedInput
    installmentsList?: FeeInstallmentUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateWithoutPaymentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentsList?: FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleNestedInput
  }

  export type InstitutionCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutAiAgentsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutAiAgentsInput, InstitutionUncheckedCreateWithoutAiAgentsInput>
  }

  export type AIConversationCreateWithoutAgentInput = {
    id?: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutAIConversationInput
    messages?: AIMessageCreateNestedManyWithoutConversationInput
  }

  export type AIConversationUncheckedCreateWithoutAgentInput = {
    id?: string
    userId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    messages?: AIMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AIConversationCreateOrConnectWithoutAgentInput = {
    where: AIConversationWhereUniqueInput
    create: XOR<AIConversationCreateWithoutAgentInput, AIConversationUncheckedCreateWithoutAgentInput>
  }

  export type AIConversationCreateManyAgentInputEnvelope = {
    data: AIConversationCreateManyAgentInput | AIConversationCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type VirtualClassroomCreateWithoutAiagentInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutAiagentInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutAiagentInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutAiagentInput, VirtualClassroomUncheckedCreateWithoutAiagentInput>
  }

  export type VirtualClassroomCreateManyAiagentInputEnvelope = {
    data: VirtualClassroomCreateManyAiagentInput | VirtualClassroomCreateManyAiagentInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutAiAgentsInput = {
    update: XOR<InstitutionUpdateWithoutAiAgentsInput, InstitutionUncheckedUpdateWithoutAiAgentsInput>
    create: XOR<InstitutionCreateWithoutAiAgentsInput, InstitutionUncheckedCreateWithoutAiAgentsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutAiAgentsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutAiAgentsInput, InstitutionUncheckedUpdateWithoutAiAgentsInput>
  }

  export type InstitutionUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type AIConversationUpsertWithWhereUniqueWithoutAgentInput = {
    where: AIConversationWhereUniqueInput
    update: XOR<AIConversationUpdateWithoutAgentInput, AIConversationUncheckedUpdateWithoutAgentInput>
    create: XOR<AIConversationCreateWithoutAgentInput, AIConversationUncheckedCreateWithoutAgentInput>
  }

  export type AIConversationUpdateWithWhereUniqueWithoutAgentInput = {
    where: AIConversationWhereUniqueInput
    data: XOR<AIConversationUpdateWithoutAgentInput, AIConversationUncheckedUpdateWithoutAgentInput>
  }

  export type AIConversationUpdateManyWithWhereWithoutAgentInput = {
    where: AIConversationScalarWhereInput
    data: XOR<AIConversationUpdateManyMutationInput, AIConversationUncheckedUpdateManyWithoutAgentInput>
  }

  export type VirtualClassroomUpsertWithWhereUniqueWithoutAiagentInput = {
    where: VirtualClassroomWhereUniqueInput
    update: XOR<VirtualClassroomUpdateWithoutAiagentInput, VirtualClassroomUncheckedUpdateWithoutAiagentInput>
    create: XOR<VirtualClassroomCreateWithoutAiagentInput, VirtualClassroomUncheckedCreateWithoutAiagentInput>
  }

  export type VirtualClassroomUpdateWithWhereUniqueWithoutAiagentInput = {
    where: VirtualClassroomWhereUniqueInput
    data: XOR<VirtualClassroomUpdateWithoutAiagentInput, VirtualClassroomUncheckedUpdateWithoutAiagentInput>
  }

  export type VirtualClassroomUpdateManyWithWhereWithoutAiagentInput = {
    where: VirtualClassroomScalarWhereInput
    data: XOR<VirtualClassroomUpdateManyMutationInput, VirtualClassroomUncheckedUpdateManyWithoutAiagentInput>
  }

  export type UserCreateWithoutAIConversationInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAIConversationInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAIConversationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAIConversationInput, UserUncheckedCreateWithoutAIConversationInput>
  }

  export type AIAgentCreateWithoutConversationsInput = {
    id?: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutAiAgentsInput
    classrooms?: VirtualClassroomCreateNestedManyWithoutAiagentInput
  }

  export type AIAgentUncheckedCreateWithoutConversationsInput = {
    id?: string
    institutionId: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
    classrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutAiagentInput
  }

  export type AIAgentCreateOrConnectWithoutConversationsInput = {
    where: AIAgentWhereUniqueInput
    create: XOR<AIAgentCreateWithoutConversationsInput, AIAgentUncheckedCreateWithoutConversationsInput>
  }

  export type AIMessageCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    tokens?: number | null
    createdAt?: Date | string
  }

  export type AIMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    tokens?: number | null
    createdAt?: Date | string
  }

  export type AIMessageCreateOrConnectWithoutConversationInput = {
    where: AIMessageWhereUniqueInput
    create: XOR<AIMessageCreateWithoutConversationInput, AIMessageUncheckedCreateWithoutConversationInput>
  }

  export type AIMessageCreateManyConversationInputEnvelope = {
    data: AIMessageCreateManyConversationInput | AIMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAIConversationInput = {
    update: XOR<UserUpdateWithoutAIConversationInput, UserUncheckedUpdateWithoutAIConversationInput>
    create: XOR<UserCreateWithoutAIConversationInput, UserUncheckedCreateWithoutAIConversationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAIConversationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAIConversationInput, UserUncheckedUpdateWithoutAIConversationInput>
  }

  export type UserUpdateWithoutAIConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAIConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AIAgentUpsertWithoutConversationsInput = {
    update: XOR<AIAgentUpdateWithoutConversationsInput, AIAgentUncheckedUpdateWithoutConversationsInput>
    create: XOR<AIAgentCreateWithoutConversationsInput, AIAgentUncheckedCreateWithoutConversationsInput>
    where?: AIAgentWhereInput
  }

  export type AIAgentUpdateToOneWithWhereWithoutConversationsInput = {
    where?: AIAgentWhereInput
    data: XOR<AIAgentUpdateWithoutConversationsInput, AIAgentUncheckedUpdateWithoutConversationsInput>
  }

  export type AIAgentUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutAiAgentsNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutAiagentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutAiagentNestedInput
  }

  export type AIMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: AIMessageWhereUniqueInput
    update: XOR<AIMessageUpdateWithoutConversationInput, AIMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<AIMessageCreateWithoutConversationInput, AIMessageUncheckedCreateWithoutConversationInput>
  }

  export type AIMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: AIMessageWhereUniqueInput
    data: XOR<AIMessageUpdateWithoutConversationInput, AIMessageUncheckedUpdateWithoutConversationInput>
  }

  export type AIMessageUpdateManyWithWhereWithoutConversationInput = {
    where: AIMessageScalarWhereInput
    data: XOR<AIMessageUpdateManyMutationInput, AIMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type AIMessageScalarWhereInput = {
    AND?: AIMessageScalarWhereInput | AIMessageScalarWhereInput[]
    OR?: AIMessageScalarWhereInput[]
    NOT?: AIMessageScalarWhereInput | AIMessageScalarWhereInput[]
    id?: StringFilter<"AIMessage"> | string
    conversationId?: StringFilter<"AIMessage"> | string
    role?: StringFilter<"AIMessage"> | string
    content?: StringFilter<"AIMessage"> | string
    tokens?: IntNullableFilter<"AIMessage"> | number | null
    createdAt?: DateTimeFilter<"AIMessage"> | Date | string
  }

  export type AIConversationCreateWithoutMessagesInput = {
    id?: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutAIConversationInput
    agent: AIAgentCreateNestedOneWithoutConversationsInput
  }

  export type AIConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    agentId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type AIConversationCreateOrConnectWithoutMessagesInput = {
    where: AIConversationWhereUniqueInput
    create: XOR<AIConversationCreateWithoutMessagesInput, AIConversationUncheckedCreateWithoutMessagesInput>
  }

  export type AIConversationUpsertWithoutMessagesInput = {
    update: XOR<AIConversationUpdateWithoutMessagesInput, AIConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<AIConversationCreateWithoutMessagesInput, AIConversationUncheckedCreateWithoutMessagesInput>
    where?: AIConversationWhereInput
  }

  export type AIConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AIConversationWhereInput
    data: XOR<AIConversationUpdateWithoutMessagesInput, AIConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type AIConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutAIConversationNestedInput
    agent?: AIAgentUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type AIConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type UserCreateWithoutAiUsagesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAiUsagesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAiUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiUsagesInput, UserUncheckedCreateWithoutAiUsagesInput>
  }

  export type InstitutionCreateWithoutAiUsageLogsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutAiUsageLogsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutAiUsageLogsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutAiUsageLogsInput, InstitutionUncheckedCreateWithoutAiUsageLogsInput>
  }

  export type VirtualClassroomCreateWithoutAiUsagesInput = {
    id?: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutClassroomsInput
    teacher?: UserCreateNestedOneWithoutVirtualClassroomsInput
    aiagent?: AIAgentCreateNestedOneWithoutClassroomsInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomUncheckedCreateWithoutAiUsagesInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutClassroomInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassroomInput
    studentSubject?: StudentSubjectUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type VirtualClassroomCreateOrConnectWithoutAiUsagesInput = {
    where: VirtualClassroomWhereUniqueInput
    create: XOR<VirtualClassroomCreateWithoutAiUsagesInput, VirtualClassroomUncheckedCreateWithoutAiUsagesInput>
  }

  export type UserUpsertWithoutAiUsagesInput = {
    update: XOR<UserUpdateWithoutAiUsagesInput, UserUncheckedUpdateWithoutAiUsagesInput>
    create: XOR<UserCreateWithoutAiUsagesInput, UserUncheckedCreateWithoutAiUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiUsagesInput, UserUncheckedUpdateWithoutAiUsagesInput>
  }

  export type UserUpdateWithoutAiUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAiUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionUpsertWithoutAiUsageLogsInput = {
    update: XOR<InstitutionUpdateWithoutAiUsageLogsInput, InstitutionUncheckedUpdateWithoutAiUsageLogsInput>
    create: XOR<InstitutionCreateWithoutAiUsageLogsInput, InstitutionUncheckedCreateWithoutAiUsageLogsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutAiUsageLogsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutAiUsageLogsInput, InstitutionUncheckedUpdateWithoutAiUsageLogsInput>
  }

  export type InstitutionUpdateWithoutAiUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutAiUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type VirtualClassroomUpsertWithoutAiUsagesInput = {
    update: XOR<VirtualClassroomUpdateWithoutAiUsagesInput, VirtualClassroomUncheckedUpdateWithoutAiUsagesInput>
    create: XOR<VirtualClassroomCreateWithoutAiUsagesInput, VirtualClassroomUncheckedCreateWithoutAiUsagesInput>
    where?: VirtualClassroomWhereInput
  }

  export type VirtualClassroomUpdateToOneWithWhereWithoutAiUsagesInput = {
    where?: VirtualClassroomWhereInput
    data: XOR<VirtualClassroomUpdateWithoutAiUsagesInput, VirtualClassroomUncheckedUpdateWithoutAiUsagesInput>
  }

  export type VirtualClassroomUpdateWithoutAiUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutAiUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutNotificationPreferenceInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferenceInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
  }

  export type UserUpsertWithoutNotificationPreferenceInput = {
    update: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserUpdateWithoutNotificationPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutAnnouncementsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutAnnouncementsInput, InstitutionUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserCreateWithoutAnnouncementInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAnnouncementInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAnnouncementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementInput, UserUncheckedCreateWithoutAnnouncementInput>
  }

  export type InstitutionUpsertWithoutAnnouncementsInput = {
    update: XOR<InstitutionUpdateWithoutAnnouncementsInput, InstitutionUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<InstitutionCreateWithoutAnnouncementsInput, InstitutionUncheckedCreateWithoutAnnouncementsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutAnnouncementsInput, InstitutionUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type InstitutionUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserUpsertWithoutAnnouncementInput = {
    update: XOR<UserUpdateWithoutAnnouncementInput, UserUncheckedUpdateWithoutAnnouncementInput>
    create: XOR<UserCreateWithoutAnnouncementInput, UserUncheckedCreateWithoutAnnouncementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementInput, UserUncheckedUpdateWithoutAnnouncementInput>
  }

  export type UserUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateWithoutBackupsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutBackupsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutBackupsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutBackupsInput, InstitutionUncheckedCreateWithoutBackupsInput>
  }

  export type UserCreateWithoutDataBackupsInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDataBackupsInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDataBackupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataBackupsInput, UserUncheckedCreateWithoutDataBackupsInput>
  }

  export type InstitutionUpsertWithoutBackupsInput = {
    update: XOR<InstitutionUpdateWithoutBackupsInput, InstitutionUncheckedUpdateWithoutBackupsInput>
    create: XOR<InstitutionCreateWithoutBackupsInput, InstitutionUncheckedCreateWithoutBackupsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutBackupsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutBackupsInput, InstitutionUncheckedUpdateWithoutBackupsInput>
  }

  export type InstitutionUpdateWithoutBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserUpsertWithoutDataBackupsInput = {
    update: XOR<UserUpdateWithoutDataBackupsInput, UserUncheckedUpdateWithoutDataBackupsInput>
    create: XOR<UserCreateWithoutDataBackupsInput, UserUncheckedCreateWithoutDataBackupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataBackupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataBackupsInput, UserUncheckedUpdateWithoutDataBackupsInput>
  }

  export type UserUpdateWithoutDataBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDataBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateWithoutTemplatesInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutTemplatesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutTemplatesInput, InstitutionUncheckedCreateWithoutTemplatesInput>
  }

  export type UserCreateWithoutTemplatesInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTemplatesInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemplatesInput, UserUncheckedCreateWithoutTemplatesInput>
  }

  export type InstitutionUpsertWithoutTemplatesInput = {
    update: XOR<InstitutionUpdateWithoutTemplatesInput, InstitutionUncheckedUpdateWithoutTemplatesInput>
    create: XOR<InstitutionCreateWithoutTemplatesInput, InstitutionUncheckedCreateWithoutTemplatesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutTemplatesInput, InstitutionUncheckedUpdateWithoutTemplatesInput>
  }

  export type InstitutionUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserUpsertWithoutTemplatesInput = {
    update: XOR<UserUpdateWithoutTemplatesInput, UserUncheckedUpdateWithoutTemplatesInput>
    create: XOR<UserCreateWithoutTemplatesInput, UserUncheckedCreateWithoutTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTemplatesInput, UserUncheckedUpdateWithoutTemplatesInput>
  }

  export type UserUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutIntegrationsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutIntegrationsInput, InstitutionUncheckedCreateWithoutIntegrationsInput>
  }

  export type InstitutionUpsertWithoutIntegrationsInput = {
    update: XOR<InstitutionUpdateWithoutIntegrationsInput, InstitutionUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<InstitutionCreateWithoutIntegrationsInput, InstitutionUncheckedCreateWithoutIntegrationsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutIntegrationsInput, InstitutionUncheckedUpdateWithoutIntegrationsInput>
  }

  export type InstitutionUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateWithoutApiClientsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutApiClientsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutApiClientsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutApiClientsInput, InstitutionUncheckedCreateWithoutApiClientsInput>
  }

  export type ApiUsageLogCreateWithoutApiClientInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type ApiUsageLogUncheckedCreateWithoutApiClientInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type ApiUsageLogCreateOrConnectWithoutApiClientInput = {
    where: ApiUsageLogWhereUniqueInput
    create: XOR<ApiUsageLogCreateWithoutApiClientInput, ApiUsageLogUncheckedCreateWithoutApiClientInput>
  }

  export type ApiUsageLogCreateManyApiClientInputEnvelope = {
    data: ApiUsageLogCreateManyApiClientInput | ApiUsageLogCreateManyApiClientInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyRotationCreateWithoutApiClientInput = {
    id?: string
    keyHash: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyRotationUncheckedCreateWithoutApiClientInput = {
    id?: string
    keyHash: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyRotationCreateOrConnectWithoutApiClientInput = {
    where: ApiKeyRotationWhereUniqueInput
    create: XOR<ApiKeyRotationCreateWithoutApiClientInput, ApiKeyRotationUncheckedCreateWithoutApiClientInput>
  }

  export type ApiKeyRotationCreateManyApiClientInputEnvelope = {
    data: ApiKeyRotationCreateManyApiClientInput | ApiKeyRotationCreateManyApiClientInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutApiClientsInput = {
    update: XOR<InstitutionUpdateWithoutApiClientsInput, InstitutionUncheckedUpdateWithoutApiClientsInput>
    create: XOR<InstitutionCreateWithoutApiClientsInput, InstitutionUncheckedCreateWithoutApiClientsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutApiClientsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutApiClientsInput, InstitutionUncheckedUpdateWithoutApiClientsInput>
  }

  export type InstitutionUpdateWithoutApiClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutApiClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type ApiUsageLogUpsertWithWhereUniqueWithoutApiClientInput = {
    where: ApiUsageLogWhereUniqueInput
    update: XOR<ApiUsageLogUpdateWithoutApiClientInput, ApiUsageLogUncheckedUpdateWithoutApiClientInput>
    create: XOR<ApiUsageLogCreateWithoutApiClientInput, ApiUsageLogUncheckedCreateWithoutApiClientInput>
  }

  export type ApiUsageLogUpdateWithWhereUniqueWithoutApiClientInput = {
    where: ApiUsageLogWhereUniqueInput
    data: XOR<ApiUsageLogUpdateWithoutApiClientInput, ApiUsageLogUncheckedUpdateWithoutApiClientInput>
  }

  export type ApiUsageLogUpdateManyWithWhereWithoutApiClientInput = {
    where: ApiUsageLogScalarWhereInput
    data: XOR<ApiUsageLogUpdateManyMutationInput, ApiUsageLogUncheckedUpdateManyWithoutApiClientInput>
  }

  export type ApiUsageLogScalarWhereInput = {
    AND?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
    OR?: ApiUsageLogScalarWhereInput[]
    NOT?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
    id?: StringFilter<"ApiUsageLog"> | string
    apiClientId?: StringFilter<"ApiUsageLog"> | string
    endpoint?: StringFilter<"ApiUsageLog"> | string
    method?: StringFilter<"ApiUsageLog"> | string
    statusCode?: IntFilter<"ApiUsageLog"> | number
    latencyMs?: IntNullableFilter<"ApiUsageLog"> | number | null
    createdAt?: DateTimeFilter<"ApiUsageLog"> | Date | string
  }

  export type ApiKeyRotationUpsertWithWhereUniqueWithoutApiClientInput = {
    where: ApiKeyRotationWhereUniqueInput
    update: XOR<ApiKeyRotationUpdateWithoutApiClientInput, ApiKeyRotationUncheckedUpdateWithoutApiClientInput>
    create: XOR<ApiKeyRotationCreateWithoutApiClientInput, ApiKeyRotationUncheckedCreateWithoutApiClientInput>
  }

  export type ApiKeyRotationUpdateWithWhereUniqueWithoutApiClientInput = {
    where: ApiKeyRotationWhereUniqueInput
    data: XOR<ApiKeyRotationUpdateWithoutApiClientInput, ApiKeyRotationUncheckedUpdateWithoutApiClientInput>
  }

  export type ApiKeyRotationUpdateManyWithWhereWithoutApiClientInput = {
    where: ApiKeyRotationScalarWhereInput
    data: XOR<ApiKeyRotationUpdateManyMutationInput, ApiKeyRotationUncheckedUpdateManyWithoutApiClientInput>
  }

  export type ApiKeyRotationScalarWhereInput = {
    AND?: ApiKeyRotationScalarWhereInput | ApiKeyRotationScalarWhereInput[]
    OR?: ApiKeyRotationScalarWhereInput[]
    NOT?: ApiKeyRotationScalarWhereInput | ApiKeyRotationScalarWhereInput[]
    id?: StringFilter<"ApiKeyRotation"> | string
    apiClientId?: StringFilter<"ApiKeyRotation"> | string
    keyHash?: StringFilter<"ApiKeyRotation"> | string
    createdAt?: DateTimeFilter<"ApiKeyRotation"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKeyRotation"> | Date | string | null
  }

  export type ApiClientCreateWithoutUsageLogsInput = {
    id?: string
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutApiClientsInput
    rotations?: ApiKeyRotationCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    institutionId?: string | null
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    rotations?: ApiKeyRotationUncheckedCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientCreateOrConnectWithoutUsageLogsInput = {
    where: ApiClientWhereUniqueInput
    create: XOR<ApiClientCreateWithoutUsageLogsInput, ApiClientUncheckedCreateWithoutUsageLogsInput>
  }

  export type ApiClientUpsertWithoutUsageLogsInput = {
    update: XOR<ApiClientUpdateWithoutUsageLogsInput, ApiClientUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ApiClientCreateWithoutUsageLogsInput, ApiClientUncheckedCreateWithoutUsageLogsInput>
    where?: ApiClientWhereInput
  }

  export type ApiClientUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ApiClientWhereInput
    data: XOR<ApiClientUpdateWithoutUsageLogsInput, ApiClientUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ApiClientUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutApiClientsNestedInput
    rotations?: ApiKeyRotationUpdateManyWithoutApiClientNestedInput
  }

  export type ApiClientUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotations?: ApiKeyRotationUncheckedUpdateManyWithoutApiClientNestedInput
  }

  export type InstitutionCreateWithoutWebhooksInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutWebhooksInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    institutionLogs?: InstitutionLogUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutWebhooksInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutWebhooksInput, InstitutionUncheckedCreateWithoutWebhooksInput>
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    id?: string
    status: string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: number
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: string
    status: string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: number
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionUpsertWithoutWebhooksInput = {
    update: XOR<InstitutionUpdateWithoutWebhooksInput, InstitutionUncheckedUpdateWithoutWebhooksInput>
    create: XOR<InstitutionCreateWithoutWebhooksInput, InstitutionUncheckedCreateWithoutWebhooksInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutWebhooksInput, InstitutionUncheckedUpdateWithoutWebhooksInput>
  }

  export type InstitutionUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    status?: StringFilter<"WebhookDelivery"> | string
    response?: JsonNullableFilter<"WebhookDelivery">
    attempt?: IntFilter<"WebhookDelivery"> | number
    sentAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    institutionId: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiClientCreateWithoutRotationsInput = {
    id?: string
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutApiClientsInput
    usageLogs?: ApiUsageLogCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientUncheckedCreateWithoutRotationsInput = {
    id?: string
    institutionId?: string | null
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    usageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutApiClientInput
  }

  export type ApiClientCreateOrConnectWithoutRotationsInput = {
    where: ApiClientWhereUniqueInput
    create: XOR<ApiClientCreateWithoutRotationsInput, ApiClientUncheckedCreateWithoutRotationsInput>
  }

  export type ApiClientUpsertWithoutRotationsInput = {
    update: XOR<ApiClientUpdateWithoutRotationsInput, ApiClientUncheckedUpdateWithoutRotationsInput>
    create: XOR<ApiClientCreateWithoutRotationsInput, ApiClientUncheckedCreateWithoutRotationsInput>
    where?: ApiClientWhereInput
  }

  export type ApiClientUpdateToOneWithWhereWithoutRotationsInput = {
    where?: ApiClientWhereInput
    data: XOR<ApiClientUpdateWithoutRotationsInput, ApiClientUncheckedUpdateWithoutRotationsInput>
  }

  export type ApiClientUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutApiClientsNestedInput
    usageLogs?: ApiUsageLogUpdateManyWithoutApiClientNestedInput
  }

  export type ApiClientUncheckedUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiUsageLogUncheckedUpdateManyWithoutApiClientNestedInput
  }

  export type UserCreateWithoutDashboardsInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDashboardsInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDashboardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
  }

  export type UserUpsertWithoutDashboardsInput = {
    update: XOR<UserUpdateWithoutDashboardsInput, UserUncheckedUpdateWithoutDashboardsInput>
    create: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDashboardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDashboardsInput, UserUncheckedUpdateWithoutDashboardsInput>
  }

  export type UserUpdateWithoutDashboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDashboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    logs?: InstitutionLogCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    logs?: InstitutionLogUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateWithoutInstitutionLogsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    plan?: PlanCreateNestedOneWithoutInstitutionsInput
    users?: UserCreateNestedManyWithoutInstitutionInput
    roles?: RoleCreateNestedManyWithoutInstitutionInput
    careers?: CareerCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutInstitutionInput
    templates?: TemplateCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutInstitutionLogsInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutInstitutionInput
    roles?: RoleUncheckedCreateNestedManyWithoutInstitutionInput
    careers?: CareerUncheckedCreateNestedManyWithoutInstitutionInput
    subscriptions?: InstitutionSubscriptionUncheckedCreateNestedManyWithoutInstitutionInput
    institutionPayments?: InstitutionPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutInstitutionInput
    templates?: TemplateUncheckedCreateNestedManyWithoutInstitutionInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutInstitutionInput
    apiClients?: ApiClientUncheckedCreateNestedManyWithoutInstitutionInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstitutionInput
    backups?: DataBackupUncheckedCreateNestedManyWithoutInstitutionInput
    feeSchedules?: FeeScheduleUncheckedCreateNestedManyWithoutInstitutionInput
    ABACPolicy?: ABACPolicyUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    tutorProfile?: TutorProfileUncheckedCreateNestedManyWithoutInstitutionInput
    studentPayments?: StudentPaymentUncheckedCreateNestedManyWithoutInstitutionInput
    aiAgents?: AIAgentUncheckedCreateNestedManyWithoutInstitutionInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutInstitutionLogsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutInstitutionLogsInput, InstitutionUncheckedCreateWithoutInstitutionLogsInput>
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    careers?: CareerCreateNestedManyWithoutCreatedByInput
    courses?: CourseCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedManyWithoutUserInput
    announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupCreateNestedManyWithoutCreatedByInput
    templates?: TemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    institutionId?: string | null
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    tutorProfile?: TutorProfileUncheckedCreateNestedOneWithoutUserInput
    dashboards?: DashboardConfigUncheckedCreateNestedManyWithoutUserInput
    aiUsages?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    careers?: CareerUncheckedCreateNestedManyWithoutCreatedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatedByInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutCreatedByInput
    virtualClassrooms?: VirtualClassroomUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutNotedByInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedCreateNestedManyWithoutRecordedByInput
    certificate?: CertificateUncheckedCreateNestedManyWithoutIssuedByInput
    aIConversation?: AIConversationUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    dataBackups?: DataBackupUncheckedCreateNestedManyWithoutCreatedByInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type InstitutionUpsertWithoutInstitutionLogsInput = {
    update: XOR<InstitutionUpdateWithoutInstitutionLogsInput, InstitutionUncheckedUpdateWithoutInstitutionLogsInput>
    create: XOR<InstitutionCreateWithoutInstitutionLogsInput, InstitutionUncheckedCreateWithoutInstitutionLogsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutInstitutionLogsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutInstitutionLogsInput, InstitutionUncheckedUpdateWithoutInstitutionLogsInput>
  }

  export type InstitutionUpdateWithoutInstitutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutInstitutionsNestedInput
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutInstitutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InstitutionCreateManyPlanInput = {
    id?: string
    name: string
    slug: string
    contactEmail: string
    phone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    createdAt?: Date | string
  }

  export type InstitutionSubscriptionCreateManyPlanInput = {
    id?: string
    institutionId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
  }

  export type InstitutionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutInstitutionNestedInput
    roles?: RoleUncheckedUpdateManyWithoutInstitutionNestedInput
    careers?: CareerUncheckedUpdateManyWithoutInstitutionNestedInput
    subscriptions?: InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionPayments?: InstitutionPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    institutionLogs?: InstitutionLogUncheckedUpdateManyWithoutInstitutionNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutInstitutionNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutInstitutionNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutInstitutionNestedInput
    apiClients?: ApiClientUncheckedUpdateManyWithoutInstitutionNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstitutionNestedInput
    backups?: DataBackupUncheckedUpdateManyWithoutInstitutionNestedInput
    feeSchedules?: FeeScheduleUncheckedUpdateManyWithoutInstitutionNestedInput
    ABACPolicy?: ABACPolicyUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateManyWithoutInstitutionNestedInput
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutInstitutionNestedInput
    aiAgents?: AIAgentUncheckedUpdateManyWithoutInstitutionNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: InstitutionPaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type InstitutionSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstitutionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type InstitutionSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInstitutionInput = {
    id?: string
    email: string
    password?: string | null
    fullName: string
    ci?: string | null
    phone?: string | null
    isActive?: boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateManyInstitutionInput = {
    id?: string
    name: $Enums.RoleName
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
  }

  export type CareerCreateManyInstitutionInput = {
    id?: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type InstitutionSubscriptionCreateManyInstitutionInput = {
    id?: string
    planId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.SubscriptionStatus
    autoRenew?: boolean
    billingCycle?: string | null
    createdAt?: Date | string
  }

  export type InstitutionPaymentCreateManyInstitutionInput = {
    id?: string
    subscriptionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
  }

  export type InstitutionLogCreateManyInstitutionInput = {
    id?: string
    userId?: string | null
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogCreateManyInstitutionInput = {
    id?: string
    userId: string
    classroomId?: string | null
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type TemplateCreateManyInstitutionInput = {
    id?: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type IntegrationCreateManyInstitutionInput = {
    id?: string
    name: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ApiClientCreateManyInstitutionInput = {
    id?: string
    clientId?: string
    clientName: string
    clientType: string
    apiKeyHash: string
    scopes?: ApiClientCreatescopesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AnnouncementCreateManyInstitutionInput = {
    id?: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type DataBackupCreateManyInstitutionInput = {
    id?: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type FeeScheduleCreateManyInstitutionInput = {
    id?: string
    careerId?: string | null
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ABACPolicyCreateManyInstitutionInput = {
    id?: string
    name: string
    description?: string | null
    resource: string
    action: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: $Enums.PolicyEffect
    isActive?: boolean
    createdAt?: Date | string
  }

  export type StudentCreateManyInstitutionInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    careerId?: string | null
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TutorProfileCreateManyInstitutionInput = {
    id?: string
    userId: string
    relationship?: string | null
    phone?: string | null
    address?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StudentPaymentCreateManyInstitutionInput = {
    id?: string
    studentId: string
    feeInstallmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIAgentCreateManyInstitutionInput = {
    id?: string
    type: string
    name: string
    personality: string
    specialization?: string | null
    maxTokensPerCall?: number
    temperature?: number
    systemPrompt: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WebhookCreateManyInstitutionInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    careers?: CareerUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    tutorProfile?: TutorProfileUncheckedUpdateOneWithoutUserNestedInput
    dashboards?: DashboardConfigUncheckedUpdateManyWithoutUserNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    logs?: InstitutionLogUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    careers?: CareerUncheckedUpdateManyWithoutCreatedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatedByNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutCreatedByNestedInput
    virtualClassrooms?: VirtualClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutNotedByNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutIssuedByNestedInput
    aIConversation?: AIConversationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    dataBackups?: DataBackupUncheckedUpdateManyWithoutCreatedByNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    ci?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    attributes?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCareersNestedInput
    courses?: CourseUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUpdateManyWithoutCareerNestedInput
    students?: StudentUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput
    students?: StudentUncheckedUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionSubscriptionUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutInstitutionSubscriptionNestedInput
    payments?: InstitutionPaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type InstitutionSubscriptionUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstitutionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type InstitutionSubscriptionUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    billingCycle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: InstitutionSubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type InstitutionPaymentUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type InstitutionLogUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiUsagesNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutAiUsagesNestedInput
  }

  export type AIUsageLogUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiClientUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiUsageLogUpdateManyWithoutApiClientNestedInput
    rotations?: ApiKeyRotationUpdateManyWithoutApiClientNestedInput
  }

  export type ApiClientUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLogs?: ApiUsageLogUncheckedUpdateManyWithoutApiClientNestedInput
    rotations?: ApiKeyRotationUncheckedUpdateManyWithoutApiClientNestedInput
  }

  export type ApiClientUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientType?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    scopes?: ApiClientUpdatescopesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutDataBackupsNestedInput
  }

  export type DataBackupUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeScheduleUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneWithoutFeeScheduleNestedInput
    installmentsList?: FeeInstallmentUpdateManyWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentsList?: FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABACPolicyUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABACPolicyUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABACPolicyUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    effect?: EnumPolicyEffectFieldUpdateOperationsInput | $Enums.PolicyEffect
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    career?: CareerUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    careerId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorProfileUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTutorProfileNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutTutorNestedInput
  }

  export type TutorProfileUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type TutorProfileUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPaymentsNestedInput
    feeInstallment?: FeeInstallmentUpdateOneWithoutStudentPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    feeInstallmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    feeInstallmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUpdateManyWithoutAgentNestedInput
    classrooms?: VirtualClassroomUpdateManyWithoutAiagentNestedInput
  }

  export type AIAgentUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: AIConversationUncheckedUpdateManyWithoutAgentNestedInput
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutAiagentNestedInput
  }

  export type AIAgentUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    maxTokensPerCall?: IntFieldUpdateOperationsInput | number
    temperature?: FloatFieldUpdateOperationsInput | number
    systemPrompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentCreateManySubscriptionInput = {
    id?: string
    institutionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: string | null
    createdAt?: Date | string
  }

  export type InstitutionPaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutInstitutionPaymentsNestedInput
  }

  export type InstitutionPaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionPaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardConfigCreateManyUserInput = {
    id?: string
    type: string
    config: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AIUsageLogCreateManyUserInput = {
    id?: string
    institutionId: string
    classroomId?: string | null
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type InstitutionLogCreateManyUserInput = {
    id?: string
    institutionId: string
    module?: string | null
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    recipientId: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyRecipientInput = {
    id?: string
    senderId: string
    subject?: string | null
    body: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    title: string
    body: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    readAt?: Date | string | null
    pushSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
  }

  export type CareerCreateManyCreatedByInput = {
    id?: string
    institutionId: string
    name: string
    code?: string | null
    level: $Enums.LevelType
    description?: string | null
    createdAt?: Date | string
  }

  export type CourseCreateManyCreatedByInput = {
    id?: string
    careerId: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdAt?: Date | string
  }

  export type LessonPlanCreateManyCreatedByInput = {
    id?: string
    classroomId: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VirtualClassroomCreateManyTeacherInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
  }

  export type GradeCreateManyCreatedByInput = {
    id?: string
    studentSubjectId: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyNotedByInput = {
    id?: string
    studentId: string
    classroomId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type DisciplinaryRecordCreateManyRecordedByInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type CertificateCreateManyIssuedByInput = {
    id?: string
    studentId: string
    courseId?: string | null
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AIConversationCreateManyUserInput = {
    id?: string
    agentId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type NotificationPreferenceCreateManyUserInput = {
    id?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnnouncementCreateManyCreatedByInput = {
    id?: string
    institutionId: string
    title: string
    body: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DataBackupCreateManyCreatedByInput = {
    id?: string
    institutionId: string
    name: string
    description?: string | null
    storageUrl: string
    sizeBytes?: number | null
    createdAt?: Date | string
  }

  export type TemplateCreateManyCreatedByInput = {
    id?: string
    institutionId: string
    name: string
    type: string
    body: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DashboardConfigUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardConfigUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardConfigUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutAiUsageLogsNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutAiUsagesNestedInput
  }

  export type AIUsageLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutInstitutionLogsNestedInput
  }

  export type InstitutionLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutCareersNestedInput
    courses?: CourseUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUpdateManyWithoutCareerNestedInput
    students?: StudentUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCareerNestedInput
    periods?: AcademicPeriodUncheckedUpdateManyWithoutCareerNestedInput
    students?: StudentUncheckedUpdateManyWithoutCareerNestedInput
    feeSchedule?: FeeScheduleUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelTypeFieldUpdateOperationsInput | $Enums.LevelType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutCoursesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCoursesNestedInput
    subjects?: SubjectUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: VirtualClassroomUpdateOneRequiredWithoutLessonPlansNestedInput
  }

  export type LessonPlanUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassroomUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSubject?: StudentSubjectUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentSubjectId?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentSubjectId?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutNotedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
    classroom?: VirtualClassroomUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutNotedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutNotedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisciplinaryRecordUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutDisciplinaryRecordNestedInput
    subject?: SubjectUpdateOneWithoutDisciplinaryRecordNestedInput
  }

  export type DisciplinaryRecordUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisciplinaryRecordUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CertificateUpdateWithoutIssuedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneWithoutCertificateNestedInput
    subject?: SubjectUpdateOneWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutIssuedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUncheckedUpdateManyWithoutIssuedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AIConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agent?: AIAgentUpdateOneRequiredWithoutConversationsNestedInput
    messages?: AIMessageUpdateManyWithoutConversationNestedInput
  }

  export type AIConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    messages?: AIMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AIConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutBackupsNestedInput
  }

  export type DataBackupUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataBackupUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateManyCareerInput = {
    id?: string
    academicPeriodId?: string | null
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AcademicPeriodCreateManyCareerInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type StudentCreateManyCareerInput = {
    id?: string
    userId: string
    studentNumber?: string | null
    institutionId: string
    enrollmentDate?: Date | string
    status?: $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeeScheduleCreateManyCareerInput = {
    id?: string
    institutionId: string
    name: string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    installments?: number
    frequency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CourseUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicPeriod?: AcademicPeriodUpdateOneWithoutCoursesNestedInput
    createdBy?: UserUpdateOneWithoutCoursesNestedInput
    subjects?: SubjectUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutAcademicPeriodNestedInput
    enrollments?: EnrollmentUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateManyWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    subjects?: StudentSubjectUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    tutorAssignments?: TutorStudentUncheckedUpdateManyWithoutStudentNestedInput
    payments?: StudentPaymentUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutStudentNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeScheduleUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutFeeSchedulesNestedInput
    installmentsList?: FeeInstallmentUpdateManyWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentsList?: FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleNestedInput
    paymentPlan?: PaymentPlanUncheckedUpdateManyWithoutFeeScheduleNestedInput
  }

  export type FeeScheduleUncheckedUpdateManyWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    installments?: IntFieldUpdateOperationsInput | number
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateManyAcademicPeriodInput = {
    id?: string
    careerId: string
    name: string
    code?: string | null
    description?: string | null
    credits?: number | null
    durationSemesters?: number | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type EnrollmentCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    courseId: string
    enrolledAt?: Date | string
    status?: string | null
  }

  export type CourseUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutCoursesNestedInput
    createdBy?: UserUpdateOneWithoutCoursesNestedInput
    subjects?: SubjectUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    durationSemesters?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectCreateManyCourseInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    semester?: number | null
    credits?: number | null
    createdAt?: Date | string
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: string
    studentId: string
    academicPeriodId?: string | null
    enrolledAt?: Date | string
    status?: string | null
  }

  export type CertificateCreateManyCourseInput = {
    id?: string
    studentId: string
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubjectUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: VirtualClassroomUncheckedUpdateManyWithoutSubjectNestedInput
    studentSubjects?: StudentSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    disciplinaryRecord?: DisciplinaryRecordUncheckedUpdateManyWithoutSubjectNestedInput
    certificate?: CertificateUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    subject?: SubjectUpdateOneWithoutCertificateNestedInput
    issuedBy?: UserUpdateOneWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VirtualClassroomCreateManySubjectInput = {
    id?: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    aiagentId?: string | null
  }

  export type StudentSubjectCreateManySubjectInput = {
    id?: string
    studentId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type DisciplinaryRecordCreateManySubjectInput = {
    id?: string
    studentId: string
    recordedById?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type CertificateCreateManySubjectInput = {
    id?: string
    studentId: string
    courseId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VirtualClassroomUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    aiagent?: AIAgentUpdateOneWithoutClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiagentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubjectsNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutStudentSubjectNestedInput
    grades?: GradeUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisciplinaryRecordUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutDisciplinaryRecordNestedInput
    recordedBy?: UserUpdateOneWithoutDisciplinaryRecordNestedInput
  }

  export type DisciplinaryRecordUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisciplinaryRecordUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CertificateUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneWithoutCertificateNestedInput
    issuedBy?: UserUpdateOneWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LessonPlanCreateManyClassroomInput = {
    id?: string
    date: Date | string
    topic: string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyClassroomInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notedById?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogCreateManyClassroomInput = {
    id?: string
    userId: string
    institutionId: string
    promptSummary?: string | null
    responseSummary?: string | null
    tokensUsed?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type StudentSubjectCreateManyClassroomInput = {
    id?: string
    studentId: string
    subjectId: string
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type LessonPlanUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutLessonPlansNestedInput
  }

  export type LessonPlanUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: StringFieldUpdateOperationsInput | string
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
    notedBy?: UserUpdateOneWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notedById?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notedById?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiUsagesNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutAiUsageLogsNestedInput
  }

  export type AIUsageLogUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    promptSummary?: NullableStringFieldUpdateOperationsInput | string | null
    responseSummary?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutStudentSubjectsNestedInput
    grades?: GradeUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyStudentInput = {
    id?: string
    courseId: string
    academicPeriodId?: string | null
    enrolledAt?: Date | string
    status?: string | null
  }

  export type StudentSubjectCreateManyStudentInput = {
    id?: string
    subjectId: string
    classroomId?: string | null
    semester?: number | null
    year?: number | null
    finalGrade?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyStudentInput = {
    id?: string
    classroomId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    notedById?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type TutorStudentCreateManyStudentInput = {
    id?: string
    tutorId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type StudentPaymentCreateManyStudentInput = {
    id?: string
    institutionId: string
    feeInstallmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CertificateCreateManyStudentInput = {
    id?: string
    courseId?: string | null
    subjectId?: string | null
    type: $Enums.CertificateType
    issuedAt?: Date | string
    fileUrl?: string | null
    issuedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DisciplinaryRecordCreateManyStudentInput = {
    id?: string
    subjectId?: string | null
    recordedById?: string | null
    type?: string | null
    description: string
    actionTaken?: string | null
    date?: Date | string
    seenByTutor?: boolean
  }

  export type PaymentPlanCreateManyStudentInput = {
    id?: string
    feeScheduleId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type EnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentSubjectUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutStudentSubjectsNestedInput
    classroom?: VirtualClassroomUpdateOneWithoutStudentSubjectNestedInput
    grades?: GradeUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStudentSubjectNestedInput
  }

  export type StudentSubjectUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    finalGrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: VirtualClassroomUpdateOneRequiredWithoutAttendancesNestedInput
    notedBy?: UserUpdateOneWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notedById?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classroomId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    notedById?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutorProfileUpdateOneRequiredWithoutTutorAssignmentsNestedInput
  }

  export type TutorStudentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tutorId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tutorId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutStudentPaymentsNestedInput
    feeInstallment?: FeeInstallmentUpdateOneWithoutStudentPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    feeInstallmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    feeInstallmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    course?: CourseUpdateOneWithoutCertificateNestedInput
    subject?: SubjectUpdateOneWithoutCertificateNestedInput
    issuedBy?: UserUpdateOneWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CertificateUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DisciplinaryRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectUpdateOneWithoutDisciplinaryRecordNestedInput
    recordedBy?: UserUpdateOneWithoutDisciplinaryRecordNestedInput
  }

  export type DisciplinaryRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DisciplinaryRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedById?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seenByTutor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentPlanUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeSchedule?: FeeScheduleUpdateOneRequiredWithoutPaymentPlanNestedInput
  }

  export type PaymentPlanUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeScheduleId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyStudentSubjectInput = {
    id?: string
    type: $Enums.GradeType
    weight?: Decimal | DecimalJsLike | number | string | null
    value: Decimal | DecimalJsLike | number | string
    comments?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type GradeUpdateWithoutStudentSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutStudentSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutStudentSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentCreateManyTutorInput = {
    id?: string
    studentId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type TutorStudentUpdateWithoutTutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTutorAssignmentsNestedInput
  }

  export type TutorStudentUncheckedUpdateWithoutTutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorStudentUncheckedUpdateManyWithoutTutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeInstallmentCreateManyFeeScheduleInput = {
    id?: string
    sequence: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PaymentPlanCreateManyFeeScheduleInput = {
    id?: string
    studentId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
  }

  export type FeeInstallmentUpdateWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPayments?: StudentPaymentUpdateManyWithoutFeeInstallmentNestedInput
  }

  export type FeeInstallmentUncheckedUpdateWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPayments?: StudentPaymentUncheckedUpdateManyWithoutFeeInstallmentNestedInput
  }

  export type FeeInstallmentUncheckedUpdateManyWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanUpdateWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPaymentPlanNestedInput
  }

  export type PaymentPlanUncheckedUpdateWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentPlanUncheckedUpdateManyWithoutFeeScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentCreateManyFeeInstallmentInput = {
    id?: string
    studentId: string
    institutionId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudentPaymentUpdateWithoutFeeInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutPaymentsNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentPaymentsNestedInput
  }

  export type StudentPaymentUncheckedUpdateWithoutFeeInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentPaymentUncheckedUpdateManyWithoutFeeInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayData?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIConversationCreateManyAgentInput = {
    id?: string
    userId: string
    sessionId: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    totalTokens?: number
    totalCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type VirtualClassroomCreateManyAiagentInput = {
    id?: string
    subjectId: string
    code?: string | null
    title?: string | null
    teacherId?: string | null
    aiEnabled?: boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AIConversationUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutAIConversationNestedInput
    messages?: AIMessageUpdateManyWithoutConversationNestedInput
  }

  export type AIConversationUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    messages?: AIMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AIConversationUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type VirtualClassroomUpdateWithoutAiagentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutClassroomsNestedInput
    teacher?: UserUpdateOneWithoutVirtualClassroomsNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateWithoutAiagentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutClassroomNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassroomNestedInput
    aiUsages?: AIUsageLogUncheckedUpdateManyWithoutClassroomNestedInput
    studentSubject?: StudentSubjectUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type VirtualClassroomUncheckedUpdateManyWithoutAiagentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIMessageCreateManyConversationInput = {
    id?: string
    role: string
    content: string
    tokens?: number | null
    createdAt?: Date | string
  }

  export type AIMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogCreateManyApiClientInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type ApiKeyRotationCreateManyApiClientInput = {
    id?: string
    keyHash: string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiUsageLogUpdateWithoutApiClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUncheckedUpdateWithoutApiClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUncheckedUpdateManyWithoutApiClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyRotationUpdateWithoutApiClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyRotationUncheckedUpdateWithoutApiClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyRotationUncheckedUpdateManyWithoutApiClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: string
    status: string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: number
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableJsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}